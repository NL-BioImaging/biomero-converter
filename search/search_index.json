{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"image-db-to-ome","text":"<ul> <li>Extract and process image data from ImageXpress Pico, Molecular Devices, CellReporterXpress experiment and image db files</li> <li>Export to ome-tiff and ome-zarr supporting Screen Plate Well / High Content Screening format </li> </ul>"},{"location":"convert/","title":"converter.convert() Usage","text":"<p>The <code>convert()</code> function in <code>converter.py</code> is used to convert an input file to OME format and write the result to one or more output folders.</p>"},{"location":"convert/#example-usage","title":"Example Usage","text":"<pre><code>from converter import convert\n\ninput_filename = \"path/to/input_file\"\noutput_folder = \"path/to/output_folder\"\nalt_output_folder = \"path/to/alternative_output_folder\"\n\nresult_json = convert(\n    input_filename,\n    output_folder,\n    alt_output_folder,\n    output_format=\"omezarr2\",\n    show_progress=False,\n    verbose=False\n)\n\nprint(result_json)\n</code></pre>"},{"location":"convert/#arguments","title":"Arguments","text":"<ul> <li><code>input_filename</code> (str): Path to the input file.</li> <li><code>output_folder</code> (str): Output folder path.</li> <li><code>alt_output_folder</code> (str, optional): Alternative output folder path.</li> <li><code>output_format</code> (str): Output format string (default: <code>'omezarr2'</code>).</li> <li><code>show_progress</code> (bool): If <code>True</code>, prints progress.</li> <li><code>verbose</code> (bool): If <code>True</code>, enables verbose logging.</li> </ul>"},{"location":"convert/#returns","title":"Returns","text":"<p>A JSON string containing an array with conversion result info, e.g.:</p> <pre><code>[\n  {\n    \"name\": \"experiment_name\",\n    \"full_path\": \"path/to/output_folder/experiment_name.ome.zarr\",\n    \"alt_path\": \"path/to/alternative_output_folder/experiment_name.ome.zarr\"\n  }\n]\n</code></pre>"},{"location":"main/","title":"Using Docker to Run the Main Script","text":"<p>You can use Docker to run the conversion process by mounting your input and output folders and passing the required arguments.</p>"},{"location":"main/#example","title":"Example","text":"<pre><code>docker run --rm \\\n  -v /local/input_folder:/data/input \\\n  -v /local/output_folder:/data/output \\\n  image-db-to-ome:latest \\\n  python main.py \\\n    --inputfile /data/input/input_file.tiff \\\n    --outputfolder /data/output \\\n    --outputformat omezarr2 \\\n    --show_progress \\\n    --verbose\n</code></pre> <p>Replace <code>/local/input_folder</code> and <code>/local/output_folder</code> with your actual local paths. Adjust the image name (<code>image-db-to-ome:latest</code>) as needed.</p>"},{"location":"main/#arguments","title":"Arguments","text":"<p>Refer to the main script for all available arguments:</p> <ul> <li><code>--inputfile</code>: Path to the input file (required)</li> <li><code>--outputfolder</code>: Path to the output folder (required)</li> <li><code>--altoutputfolder</code>: Alternative output folder (optional)</li> <li><code>--outputformat</code>: Output format version (default: <code>omezarr2</code>)</li> <li><code>--show_progress</code>: Show progress bar (flag)</li> <li><code>--verbose</code>: Enable verbose logging (flag)</li> </ul>"},{"location":"overview/","title":"Converter Overview","text":"<p>This project provides a converter that transforms source image data into OME-Tiff or OME-Zarr format. When creating a github release, a Docker image is built and published to Docker Hub with corresponding version tags here.</p>"},{"location":"overview/#architecture","title":"Architecture","text":"<p>The converter workflow consists of:</p> <ul> <li>Creating a Source reader to access image data and metadata.</li> <li>Creating a Writer to generate OME output.</li> <li>The Writer queries the Source for metadata and data, then writes the output.</li> </ul> <pre><code>flowchart TD\n    Converter[\"Converter\"]\n    Source[\"Source Reader\"]\n    Writer[\"Writer\"]\n    Output[\"OME Output\"]\n\n    Converter --&gt; Source\n    Converter --&gt; Writer\n    Writer --&gt;|Query Metadata| Source\n    Writer --&gt;|Query Data| Source\n    Writer --&gt; Output</code></pre>"},{"location":"references/","title":"References","text":""},{"location":"references/#converter.convert","title":"<code>convert(input_filename, output_folder, alt_output_folder=None, output_format='omezarr2', show_progress=False, verbose=False)</code>","text":"<p>Convert an input file to OME format and write to output folder(s).</p> <p>Parameters:</p> Name Type Description Default <code>input_filename</code> <code>str</code> <p>Path to the input file.</p> required <code>output_folder</code> <code>str</code> <p>Output folder path.</p> required <code>alt_output_folder</code> <code>str</code> <p>Alternative output folder path.</p> <code>None</code> <code>output_format</code> <code>str</code> <p>Output format string.</p> <code>'omezarr2'</code> <code>show_progress</code> <code>bool</code> <p>If True, print progress.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, enable verbose logging.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <p>JSON string with conversion result info array.</p> Source code in <code>converter.py</code> <pre><code>def convert(input_filename, output_folder, alt_output_folder=None,\n            output_format='omezarr2', show_progress=False, verbose=False):\n    \"\"\"\n    Convert an input file to OME format and write to output folder(s).\n\n    Args:\n        input_filename (str): Path to the input file.\n        output_folder (str): Output folder path.\n        alt_output_folder (str, optional): Alternative output folder path.\n        output_format (str): Output format string.\n        show_progress (bool): If True, print progress.\n        verbose (bool): If True, enable verbose logging.\n\n    Returns:\n        str: JSON string with conversion result info array.\n    \"\"\"\n\n    logging.info(f'Importing {input_filename}')\n    source = create_source(input_filename)\n    writer, output_ext = create_writer(output_format, verbose=verbose)\n    if not os.path.exists(output_folder):\n        os.makedirs(output_folder)\n\n    source.init_metadata()\n    name = source.get_name()\n    output_path = os.path.join(output_folder, name + output_ext)\n    full_output_path = writer.write(output_path, source)\n    source.close()\n\n    if show_progress:\n        print(f'Converting {input_filename} to {output_path}')\n\n    result = {'name': name}\n    if isinstance(full_output_path, list):\n        full_path = full_output_path[0]\n    else:\n        full_path = full_output_path\n    result['full_path'] = full_path\n    message = f\"Exported   {result['full_path']}\"\n\n    if alt_output_folder:\n        if not os.path.exists(alt_output_folder):\n            os.makedirs(alt_output_folder)\n        alt_output_path = os.path.join(alt_output_folder, name + output_ext)\n        if isinstance(full_output_path, list):\n            for path in full_output_path:\n                alt_output_path = os.path.join(alt_output_folder, os.path.basename(path))\n                shutil.copy2(path, alt_output_path)\n        elif os.path.isdir(full_output_path):\n            shutil.copytree(full_output_path, alt_output_path, dirs_exist_ok=True)\n        else:\n            shutil.copy2(full_output_path, alt_output_path)\n        result['alt_path'] = os.path.join(alt_output_folder, os.path.basename(full_path))\n        message += f' and {result[\"alt_path\"]}'\n\n    logging.info(message)\n    if show_progress:\n        print(message)\n\n    return json.dumps([result])\n</code></pre>"},{"location":"references/#converter.init_logging","title":"<code>init_logging(log_filename, verbose=False)</code>","text":"<p>Initialize logging to file and optionally to console.</p> <p>Parameters:</p> Name Type Description Default <code>log_filename</code> <code>str</code> <p>Path to the log file.</p> required <code>verbose</code> <code>bool</code> <p>If True, also log to console.</p> <code>False</code> Source code in <code>converter.py</code> <pre><code>def init_logging(log_filename, verbose=False):\n    \"\"\"\n    Initialize logging to file and optionally to console.\n\n    Args:\n        log_filename (str): Path to the log file.\n        verbose (bool): If True, also log to console.\n    \"\"\"\n    basepath = os.path.dirname(log_filename)\n    if basepath and not os.path.exists(basepath):\n        os.makedirs(basepath)\n    handlers = [logging.FileHandler(log_filename, encoding='utf-8')]\n    if verbose:\n        handlers += [logging.StreamHandler()]\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s: %(message)s',\n                        handlers=handlers,\n                        encoding='utf-8')\n\n    logging.getLogger('ome_zarr').setLevel(logging.WARNING)     # mute verbose ome_zarr logging\n</code></pre>"},{"location":"references/#src.DbReader","title":"<code>DbReader</code>","text":""},{"location":"references/#src.DbReader.DBReader","title":"<code>DBReader</code>","text":"<p>Reads and queries a SQLite database, returning results as dictionaries.</p> Source code in <code>src\\DbReader.py</code> <pre><code>class DBReader:\n    \"\"\"\n    Reads and queries a SQLite database, returning results as dictionaries.\n    \"\"\"\n\n    def __init__(self, db_file):\n        \"\"\"\n        Initialize DBReader with a database file.\n\n        Args:\n            db_file (str): Path to the SQLite database file.\n        \"\"\"\n        self.conn = sqlite3.connect(db_file)\n        self.conn.row_factory = DBReader.dict_factory\n\n    @staticmethod\n    def dict_factory(cursor, row):\n        \"\"\"\n        Converts a database row to a dictionary.\n\n        Args:\n            cursor: SQLite cursor object.\n            row: Row data.\n\n        Returns:\n            dict: Mapping column names to values.\n        \"\"\"\n        dct = {}\n        for index, column in enumerate(cursor.description):\n            dct[column[0]] = row[index]\n        return dct\n\n    def fetch_all(self, query, params=(), return_dicts=True):\n        \"\"\"\n        Executes a query and fetches all results.\n\n        Args:\n            query (str): SQL query string.\n            params (tuple): Query parameters.\n            return_dicts (bool): If True, returns list of dicts; else, returns first column values.\n\n        Returns:\n            list: Query results.\n        \"\"\"\n        cursor = self.conn.cursor()\n        cursor.execute(query, params)\n        dct = cursor.fetchall()\n        if return_dicts:\n            values = dct\n        else:\n            values = [list(row.values())[0] for row in dct]\n        return values\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        self.conn.close()\n</code></pre>"},{"location":"references/#src.DbReader.DBReader.conn","title":"<code>conn = sqlite3.connect(db_file)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.DbReader.DBReader.__init__","title":"<code>__init__(db_file)</code>","text":"<p>Initialize DBReader with a database file.</p> <p>Parameters:</p> Name Type Description Default <code>db_file</code> <code>str</code> <p>Path to the SQLite database file.</p> required Source code in <code>src\\DbReader.py</code> <pre><code>def __init__(self, db_file):\n    \"\"\"\n    Initialize DBReader with a database file.\n\n    Args:\n        db_file (str): Path to the SQLite database file.\n    \"\"\"\n    self.conn = sqlite3.connect(db_file)\n    self.conn.row_factory = DBReader.dict_factory\n</code></pre>"},{"location":"references/#src.DbReader.DBReader.close","title":"<code>close()</code>","text":"<p>Closes the database connection.</p> Source code in <code>src\\DbReader.py</code> <pre><code>def close(self):\n    \"\"\"\n    Closes the database connection.\n    \"\"\"\n    self.conn.close()\n</code></pre>"},{"location":"references/#src.DbReader.DBReader.dict_factory","title":"<code>dict_factory(cursor, row)</code>  <code>staticmethod</code>","text":"<p>Converts a database row to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <p>SQLite cursor object.</p> required <code>row</code> <p>Row data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Mapping column names to values.</p> Source code in <code>src\\DbReader.py</code> <pre><code>@staticmethod\ndef dict_factory(cursor, row):\n    \"\"\"\n    Converts a database row to a dictionary.\n\n    Args:\n        cursor: SQLite cursor object.\n        row: Row data.\n\n    Returns:\n        dict: Mapping column names to values.\n    \"\"\"\n    dct = {}\n    for index, column in enumerate(cursor.description):\n        dct[column[0]] = row[index]\n    return dct\n</code></pre>"},{"location":"references/#src.DbReader.DBReader.fetch_all","title":"<code>fetch_all(query, params=(), return_dicts=True)</code>","text":"<p>Executes a query and fetches all results.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>SQL query string.</p> required <code>params</code> <code>tuple</code> <p>Query parameters.</p> <code>()</code> <code>return_dicts</code> <code>bool</code> <p>If True, returns list of dicts; else, returns first column values.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>list</code> <p>Query results.</p> Source code in <code>src\\DbReader.py</code> <pre><code>def fetch_all(self, query, params=(), return_dicts=True):\n    \"\"\"\n    Executes a query and fetches all results.\n\n    Args:\n        query (str): SQL query string.\n        params (tuple): Query parameters.\n        return_dicts (bool): If True, returns list of dicts; else, returns first column values.\n\n    Returns:\n        list: Query results.\n    \"\"\"\n    cursor = self.conn.cursor()\n    cursor.execute(query, params)\n    dct = cursor.fetchall()\n    if return_dicts:\n        values = dct\n    else:\n        values = [list(row.values())[0] for row in dct]\n    return values\n</code></pre>"},{"location":"references/#src.ISyntaxSource","title":"<code>ISyntaxSource</code>","text":""},{"location":"references/#src.ISyntaxSource.ISyntaxSource","title":"<code>ISyntaxSource</code>","text":"<p>               Bases: <code>ImageSource</code></p> <p>Loads image and metadata from ISyntax format files.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>class ISyntaxSource(ImageSource):\n    \"\"\"\n    Loads image and metadata from ISyntax format files.\n    \"\"\"\n    def init_metadata(self):\n        \"\"\"\n        Initializes and loads metadata from the ISyntax file.\n\n        Returns:\n            dict: Metadata dictionary.\n        \"\"\"\n        # read XML metadata header\n        data = b''\n        block_size = 1024 * 1024\n        end_char = b'\\x04'   # EOT character\n        with open(self.uri, mode='rb') as file:\n            done = False\n            while not done:\n                data_block = file.read(block_size)\n                if end_char in data_block:\n                    index = data_block.index(end_char)\n                    data_block = data_block[:index]\n                    done = True\n                data += data_block\n\n        self.metadata = xml_content_to_dict(ElementTree.XML(data.decode()))\n        if 'DPUfsImport' in self.metadata:\n            self.metadata = self.metadata['DPUfsImport']\n\n        image = None\n        image_type = ''\n        for image0 in self.metadata.get('PIM_DP_SCANNED_IMAGES', []):\n            image = image0.get('DPScannedImage', {})\n            image_type = image.get('PIM_DP_IMAGE_TYPE').lower()\n            if image_type in ['wsi']:\n                break\n\n        if image is not None:\n            self.image_type = image_type\n            nbits = image.get('UFS_IMAGE_BLOCK_HEADER_TEMPLATES', [{}])[0].get('UFSImageBlockHeaderTemplate', {}).get('DICOM_BITS_STORED', 16)\n            nbits = int(np.ceil(nbits / 8)) * 8\n        else:\n            self.image_type = ''\n            nbits = 16\n\n        self.is_plate = 'screen' in self.image_type or 'plate' in self.image_type or 'wells' in self.image_type\n\n        # original color channels get converted in pyisyntax package to 8-bit RGBA\n        nbits = 8\n        self.dim_order = 'yxc'\n        self.channels = []\n        self.nchannels = 4\n\n        self.isyntax = ISyntax.open(self.uri)\n        self.width, self.height = self.isyntax.dimensions\n        self.shape = 1, self.nchannels, 1, self.height, self.width\n        self.dtype = np.dtype(f'uint{nbits}')\n\n        return self.metadata\n\n    def is_screen(self):\n        \"\"\"\n        Checks if the source is a plate/screen.\n\n        Returns:\n            bool: True if plate/screen.\n        \"\"\"\n        return self.is_plate\n\n    def get_shape(self):\n        \"\"\"\n        Returns the shape of the image data.\n\n        Returns:\n            tuple: Shape of the image data.\n        \"\"\"\n        return self.shape\n\n    def get_data(self, well_id=None, field_id=None):\n        \"\"\"\n        Gets image data for a specific well and field.\n\n        Args:\n            well_id (str, optional): Well identifier.\n            field_id (int, optional): Field index.\n\n        Returns:\n            ndarray: Image data.\n        \"\"\"\n        return self.isyntax.read_region(0, 0, self.width, self.height)\n\n    def get_name(self):\n        \"\"\"\n        Gets the file title.\n\n        Returns:\n            str: Name.\n        \"\"\"\n        return get_filetitle(self.uri)\n\n    def get_dim_order(self):\n        \"\"\"\n        Returns the dimension order string.\n\n        Returns:\n            str: Dimension order.\n        \"\"\"\n        return self.dim_order\n\n    def get_pixel_size_um(self):\n        \"\"\"\n        Returns the pixel size in micrometers.\n\n        Returns:\n            dict: Pixel size for x and y.\n        \"\"\"\n        return {'x': self.isyntax.mpp_x, 'y': self.isyntax.mpp_y}\n\n    def get_dtype(self):\n        \"\"\"\n        Returns the numpy dtype of the image data.\n\n        Returns:\n            dtype: Numpy dtype.\n        \"\"\"\n        return self.dtype\n\n    def get_position_um(self, well_id=None):\n        \"\"\"\n        Returns the position in micrometers (empty for ISyntax).\n\n        Returns:\n            dict: Empty dict.\n        \"\"\"\n        return {}\n\n    def get_channels(self):\n        \"\"\"\n        Returns channel metadata.\n\n        Returns:\n            list: List of channel dicts.\n        \"\"\"\n        return self.channels\n\n    def get_nchannels(self):\n        \"\"\"\n        Returns the number of channels.\n\n        Returns:\n            int: Number of channels.\n        \"\"\"\n        return self.nchannels\n\n    def get_rows(self):\n        \"\"\"\n        Returns the list of row identifiers (empty for ISyntax).\n\n        Returns:\n            list: Empty list.\n        \"\"\"\n        return []\n\n    def get_columns(self):\n        \"\"\"\n        Returns the list of column identifiers (empty for ISyntax).\n\n        Returns:\n            list: Empty list.\n        \"\"\"\n        return []\n\n    def get_wells(self):\n        \"\"\"\n        Returns the list of well identifiers (empty for ISyntax).\n\n        Returns:\n            list: Empty list.\n        \"\"\"\n        return []\n\n    def get_time_points(self):\n        \"\"\"\n        Returns the list of time points (empty for ISyntax).\n\n        Returns:\n            list: Empty list.\n        \"\"\"\n        return []\n\n    def get_fields(self):\n        \"\"\"\n        Returns the list of field indices (empty for ISyntax).\n\n        Returns:\n            list: Empty list.\n        \"\"\"\n        return []\n\n    def get_acquisitions(self):\n        \"\"\"\n        Returns acquisition metadata (empty for ISyntax).\n\n        Returns:\n            list: Empty list.\n        \"\"\"\n        return []\n\n    def get_total_data_size(self):\n        \"\"\"\n        Returns the estimated total data size.\n\n        Returns:\n            int: Total data size in bytes.\n        \"\"\"\n        total_size = np.prod(self.shape)\n        if self.is_plate:\n            total_size *= len(self.get_wells()) * len(self.get_fields())\n        return total_size\n\n    def close(self):\n        \"\"\"\n        Closes the ISyntax file.\n        \"\"\"\n        self.isyntax.close()\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.close","title":"<code>close()</code>","text":"<p>Closes the ISyntax file.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def close(self):\n    \"\"\"\n    Closes the ISyntax file.\n    \"\"\"\n    self.isyntax.close()\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_acquisitions","title":"<code>get_acquisitions()</code>","text":"<p>Returns acquisition metadata (empty for ISyntax).</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def get_acquisitions(self):\n    \"\"\"\n    Returns acquisition metadata (empty for ISyntax).\n\n    Returns:\n        list: Empty list.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_channels","title":"<code>get_channels()</code>","text":"<p>Returns channel metadata.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of channel dicts.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def get_channels(self):\n    \"\"\"\n    Returns channel metadata.\n\n    Returns:\n        list: List of channel dicts.\n    \"\"\"\n    return self.channels\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_columns","title":"<code>get_columns()</code>","text":"<p>Returns the list of column identifiers (empty for ISyntax).</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def get_columns(self):\n    \"\"\"\n    Returns the list of column identifiers (empty for ISyntax).\n\n    Returns:\n        list: Empty list.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_data","title":"<code>get_data(well_id=None, field_id=None)</code>","text":"<p>Gets image data for a specific well and field.</p> <p>Parameters:</p> Name Type Description Default <code>well_id</code> <code>str</code> <p>Well identifier.</p> <code>None</code> <code>field_id</code> <code>int</code> <p>Field index.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ndarray</code> <p>Image data.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def get_data(self, well_id=None, field_id=None):\n    \"\"\"\n    Gets image data for a specific well and field.\n\n    Args:\n        well_id (str, optional): Well identifier.\n        field_id (int, optional): Field index.\n\n    Returns:\n        ndarray: Image data.\n    \"\"\"\n    return self.isyntax.read_region(0, 0, self.width, self.height)\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"<p>Returns the dimension order string.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Dimension order.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def get_dim_order(self):\n    \"\"\"\n    Returns the dimension order string.\n\n    Returns:\n        str: Dimension order.\n    \"\"\"\n    return self.dim_order\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_dtype","title":"<code>get_dtype()</code>","text":"<p>Returns the numpy dtype of the image data.</p> <p>Returns:</p> Name Type Description <code>dtype</code> <p>Numpy dtype.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def get_dtype(self):\n    \"\"\"\n    Returns the numpy dtype of the image data.\n\n    Returns:\n        dtype: Numpy dtype.\n    \"\"\"\n    return self.dtype\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_fields","title":"<code>get_fields()</code>","text":"<p>Returns the list of field indices (empty for ISyntax).</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def get_fields(self):\n    \"\"\"\n    Returns the list of field indices (empty for ISyntax).\n\n    Returns:\n        list: Empty list.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_name","title":"<code>get_name()</code>","text":"<p>Gets the file title.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Name.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def get_name(self):\n    \"\"\"\n    Gets the file title.\n\n    Returns:\n        str: Name.\n    \"\"\"\n    return get_filetitle(self.uri)\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"<p>Returns the number of channels.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of channels.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def get_nchannels(self):\n    \"\"\"\n    Returns the number of channels.\n\n    Returns:\n        int: Number of channels.\n    \"\"\"\n    return self.nchannels\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"<p>Returns the pixel size in micrometers.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Pixel size for x and y.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def get_pixel_size_um(self):\n    \"\"\"\n    Returns the pixel size in micrometers.\n\n    Returns:\n        dict: Pixel size for x and y.\n    \"\"\"\n    return {'x': self.isyntax.mpp_x, 'y': self.isyntax.mpp_y}\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_position_um","title":"<code>get_position_um(well_id=None)</code>","text":"<p>Returns the position in micrometers (empty for ISyntax).</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Empty dict.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def get_position_um(self, well_id=None):\n    \"\"\"\n    Returns the position in micrometers (empty for ISyntax).\n\n    Returns:\n        dict: Empty dict.\n    \"\"\"\n    return {}\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_rows","title":"<code>get_rows()</code>","text":"<p>Returns the list of row identifiers (empty for ISyntax).</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def get_rows(self):\n    \"\"\"\n    Returns the list of row identifiers (empty for ISyntax).\n\n    Returns:\n        list: Empty list.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_shape","title":"<code>get_shape()</code>","text":"<p>Returns the shape of the image data.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Shape of the image data.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def get_shape(self):\n    \"\"\"\n    Returns the shape of the image data.\n\n    Returns:\n        tuple: Shape of the image data.\n    \"\"\"\n    return self.shape\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_time_points","title":"<code>get_time_points()</code>","text":"<p>Returns the list of time points (empty for ISyntax).</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def get_time_points(self):\n    \"\"\"\n    Returns the list of time points (empty for ISyntax).\n\n    Returns:\n        list: Empty list.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_total_data_size","title":"<code>get_total_data_size()</code>","text":"<p>Returns the estimated total data size.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Total data size in bytes.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def get_total_data_size(self):\n    \"\"\"\n    Returns the estimated total data size.\n\n    Returns:\n        int: Total data size in bytes.\n    \"\"\"\n    total_size = np.prod(self.shape)\n    if self.is_plate:\n        total_size *= len(self.get_wells()) * len(self.get_fields())\n    return total_size\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_wells","title":"<code>get_wells()</code>","text":"<p>Returns the list of well identifiers (empty for ISyntax).</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def get_wells(self):\n    \"\"\"\n    Returns the list of well identifiers (empty for ISyntax).\n\n    Returns:\n        list: Empty list.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.init_metadata","title":"<code>init_metadata()</code>","text":"<p>Initializes and loads metadata from the ISyntax file.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Metadata dictionary.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def init_metadata(self):\n    \"\"\"\n    Initializes and loads metadata from the ISyntax file.\n\n    Returns:\n        dict: Metadata dictionary.\n    \"\"\"\n    # read XML metadata header\n    data = b''\n    block_size = 1024 * 1024\n    end_char = b'\\x04'   # EOT character\n    with open(self.uri, mode='rb') as file:\n        done = False\n        while not done:\n            data_block = file.read(block_size)\n            if end_char in data_block:\n                index = data_block.index(end_char)\n                data_block = data_block[:index]\n                done = True\n            data += data_block\n\n    self.metadata = xml_content_to_dict(ElementTree.XML(data.decode()))\n    if 'DPUfsImport' in self.metadata:\n        self.metadata = self.metadata['DPUfsImport']\n\n    image = None\n    image_type = ''\n    for image0 in self.metadata.get('PIM_DP_SCANNED_IMAGES', []):\n        image = image0.get('DPScannedImage', {})\n        image_type = image.get('PIM_DP_IMAGE_TYPE').lower()\n        if image_type in ['wsi']:\n            break\n\n    if image is not None:\n        self.image_type = image_type\n        nbits = image.get('UFS_IMAGE_BLOCK_HEADER_TEMPLATES', [{}])[0].get('UFSImageBlockHeaderTemplate', {}).get('DICOM_BITS_STORED', 16)\n        nbits = int(np.ceil(nbits / 8)) * 8\n    else:\n        self.image_type = ''\n        nbits = 16\n\n    self.is_plate = 'screen' in self.image_type or 'plate' in self.image_type or 'wells' in self.image_type\n\n    # original color channels get converted in pyisyntax package to 8-bit RGBA\n    nbits = 8\n    self.dim_order = 'yxc'\n    self.channels = []\n    self.nchannels = 4\n\n    self.isyntax = ISyntax.open(self.uri)\n    self.width, self.height = self.isyntax.dimensions\n    self.shape = 1, self.nchannels, 1, self.height, self.width\n    self.dtype = np.dtype(f'uint{nbits}')\n\n    return self.metadata\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.is_screen","title":"<code>is_screen()</code>","text":"<p>Checks if the source is a plate/screen.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if plate/screen.</p> Source code in <code>src\\ISyntaxSource.py</code> <pre><code>def is_screen(self):\n    \"\"\"\n    Checks if the source is a plate/screen.\n\n    Returns:\n        bool: True if plate/screen.\n    \"\"\"\n    return self.is_plate\n</code></pre>"},{"location":"references/#src.ImageDbSource","title":"<code>ImageDbSource</code>","text":""},{"location":"references/#src.ImageDbSource.ImageDbSource","title":"<code>ImageDbSource</code>","text":"<p>               Bases: <code>ImageSource</code></p> <p>Loads image and metadata from a database source for high-content screening.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>class ImageDbSource(ImageSource):\n    \"\"\"\n    Loads image and metadata from a database source for high-content screening.\n    \"\"\"\n    def __init__(self, uri, metadata={}):\n        \"\"\"\n        Initialize ImageDbSource.\n\n        Args:\n            uri (str): Path to the database file.\n            metadata (dict): Optional metadata dictionary.\n        \"\"\"\n        super().__init__(uri, metadata)\n        self.db = DBReader(self.uri)\n        self.data = None\n        self.data_well_id = None\n        self.metadata['dim_order'] = 'tczyx'\n\n    def init_metadata(self):\n        \"\"\"\n        Initializes and loads metadata from the database.\n\n        Returns:\n            dict: Metadata dictionary.\n        \"\"\"\n        self._get_time_series_info()\n        self._get_experiment_metadata()\n        self._get_well_info()\n        self._get_image_info()\n        self._get_sizes()\n        return self.metadata\n\n    def get_shape(self):\n        \"\"\"\n        Returns the shape of the image data.\n\n        Returns:\n            tuple: Shape of the image data.\n        \"\"\"\n        return self.shape\n\n    def _get_time_series_info(self):\n        \"\"\"\n        Loads time series and image file info into metadata.\n        \"\"\"\n        time_series_ids = sorted(self.db.fetch_all('SELECT DISTINCT TimeSeriesElementId FROM SourceImageBase', return_dicts=False))\n        self.metadata['time_points'] = time_series_ids\n\n        level_ids = sorted(self.db.fetch_all('SELECT DISTINCT level FROM SourceImageBase', return_dicts=False))\n        self.metadata['levels'] = level_ids\n\n        image_files = {time_series_id: os.path.join(os.path.dirname(self.uri), f'images-{time_series_id}.db')\n                       for time_series_id in time_series_ids}\n        self.metadata['image_files'] = image_files\n\n    def _get_experiment_metadata(self):\n        \"\"\"\n        Loads experiment metadata and acquisition info into metadata.\n        \"\"\"\n        creation_info = self.db.fetch_all('SELECT DateCreated, Creator, Name FROM ExperimentBase')[0]\n        creation_info['DateCreated'] = convert_dotnet_ticks_to_datetime(creation_info['DateCreated'])\n        self.metadata.update(creation_info)\n\n        acquisitions = self.db.fetch_all('SELECT Name, Description, DateCreated, DateModified FROM AcquisitionExp')\n        for acquisition in acquisitions:\n            acquisition['DateCreated'] = convert_dotnet_ticks_to_datetime(acquisition['DateCreated'])\n            acquisition['DateModified'] = convert_dotnet_ticks_to_datetime(acquisition['DateModified'])\n        self.metadata['acquisitions'] = acquisitions\n\n    def _get_well_info(self):\n        \"\"\"\n        Loads well and channel information into metadata.\n        \"\"\"\n        well_info = self.db.fetch_all('''\n            SELECT SensorSizeYPixels, SensorSizeXPixels, Objective, PixelSizeUm, SensorBitness, SitesX, SitesY\n            FROM AcquisitionExp, AutomaticZonesParametersExp\n        ''')[0]\n\n        # Filter multiple duplicate channel entries\n        channel_infos = self.db.fetch_all('''\n            SELECT DISTINCT ChannelNumber, Emission, Excitation, Dye, Color\n            FROM ImagechannelExp\n            ORDER BY ChannelNumber\n        ''')\n        self.metadata['channels'] = channel_infos\n        self.metadata['num_channels'] = len(channel_infos)\n\n        wells = self.db.fetch_all('SELECT DISTINCT Name FROM Well')\n        zone_names = [well['Name'] for well in wells]\n        rows = set()\n        cols = set()\n        for zone_name in zone_names:\n            row, col = split_well_name(zone_name)\n            rows.add(row)\n            cols.add(col)\n        well_info['rows'] = sorted(list(rows))\n        well_info['columns'] = sorted(list(cols), key=lambda x: int(x))\n        num_sites = well_info['SitesX'] * well_info['SitesY']\n        well_info['num_sites'] = num_sites\n        well_info['fields'] = list(range(num_sites))\n\n        image_wells = self.db.fetch_all('SELECT Name, ZoneIndex, CoordX, CoordY FROM Well WHERE HasImages = 1')\n        self.metadata['wells'] = dict(sorted({well['Name']: well for well in image_wells}.items(),\n                                             key=lambda x: split_well_name(x[0], col_as_int=True)))\n\n        xmax, ymax = 0, 0\n        for well_id in self.metadata['wells']:\n            well_data = self._read_well_info(well_id)\n            xmax = max(xmax, np.max([info['CoordX'] + info['SizeX'] for info in well_data]))\n            ymax = max(ymax, np.max([info['CoordY'] + info['SizeY'] for info in well_data]))\n        pixel_size = well_info.get('PixelSizeUm', 1)\n        well_info['max_sizex_um'] = xmax * pixel_size\n        well_info['max_sizey_um'] = ymax * pixel_size\n\n        self.metadata['well_info'] = well_info\n\n    def _get_image_info(self):\n        \"\"\"\n        Loads image bit depth and dtype info into metadata.\n        \"\"\"\n        bits_per_pixel = self.db.fetch_all('SELECT DISTINCT BitsPerPixel FROM SourceImageBase', return_dicts=False)[0]\n        self.metadata['bits_per_pixel'] = bits_per_pixel\n        bits_per_pixel = int(np.ceil(bits_per_pixel / 8)) * 8\n        if bits_per_pixel == 24:\n            bits_per_pixel = 32\n        self.metadata['dtype'] = np.dtype(f'uint{bits_per_pixel}')\n\n    def _get_sizes(self):\n        \"\"\"\n        Calculates and stores image shape and estimated data size.\n        \"\"\"\n        well_info = self.metadata['well_info']\n        nbytes = self.metadata['dtype'].itemsize\n        self.shape = len(self.metadata['time_points']), self.metadata['num_channels'], 1, well_info['SensorSizeYPixels'], well_info['SensorSizeXPixels']\n        max_data_size = np.prod(self.shape) * nbytes * len(self.metadata['wells']) * well_info['num_sites']\n        self.metadata['max_data_size'] = max_data_size\n\n    def _read_well_info(self, well_id, channel=None, time_point=None, level=0):\n        \"\"\"\n        Reads image info for a specific well, optionally filtered by channel and time point.\n\n        Args:\n            well_id (str): Well identifier.\n            channel (int, optional): Channel ID.\n            time_point (int, optional): Time point ID.\n            level (int, optional): Image level index.\n\n        Returns:\n            list: Well image info dictionaries.\n        \"\"\"\n        well_id = strip_leading_zeros(well_id)\n        well_ids = self.metadata.get('wells', {})\n\n        if well_id not in well_ids:\n            raise ValueError(f'Invalid Well: {well_id}. Available values: {well_ids}')\n\n        zone_index = well_ids[well_id]['ZoneIndex']\n        well_info = self.db.fetch_all('''\n            SELECT *\n            FROM SourceImageBase\n            WHERE ZoneIndex = ? AND level = ?\n            ORDER BY CoordX ASC, CoordY ASC\n        ''', (zone_index, level))\n\n        if channel is not None:\n             well_info = [info for info in well_info if info['ChannelId'] == channel]\n        if time_point is not None:\n             well_info = [info for info in well_info if info['TimeSeriesElementId'] == time_point]\n        if not well_info:\n            raise ValueError(f'No data found for well {well_id}')\n        return well_info\n\n    def _assemble_image_data(self, well_info):\n        \"\"\"\n        Assembles image data array using well info.\n\n        Args:\n            well_info (list): List of well image info dicts.\n        \"\"\"\n        dtype = self.metadata['dtype']\n        well_info = np.asarray(well_info)\n        xmax = np.max([info['CoordX'] + info['SizeX'] for info in well_info])\n        ymax = np.max([info['CoordY'] + info['SizeY'] for info in well_info])\n        zmax = np.max([info.get('CoordZ', 0) + info.get('SizeZ', 1) for info in well_info])\n        nc = len(set([info['ChannelId'] for info in well_info]))\n        nt = len(self.metadata['time_points'])\n        data = np.zeros((nt, nc, zmax, ymax, xmax), dtype=dtype)\n\n        for timei, time_id in enumerate(self.metadata['time_points']):\n            image_file = self.metadata['image_files'][time_id]\n            with open(image_file, 'rb') as fid:\n                for info in well_info:\n                    if info['TimeSeriesElementId'] == time_id:\n                        fid.seek(info['ImageIndex'])\n                        coordx, coordy, coordz = info['CoordX'], info['CoordY'], info.get('CoordZ', 0)\n                        sizex, sizey, sizez = info['SizeX'], info['SizeY'], info.get('SizeZ', 1)\n                        channeli = info['ChannelId']\n                        tile = np.fromfile(fid, dtype=dtype, count=sizez * sizey * sizex)\n                        data[timei, channeli, coordz:coordz + sizez, coordy:coordy + sizey, coordx:coordx + sizex] = tile.reshape((sizez, sizey, sizex))\n\n        self.data = data\n\n    def _extract_site(self, site_id=None):\n        \"\"\"\n        Extracts image data for a specific site or all sites.\n\n        Args:\n            site_id (int, optional): Site index. If None, returns all data.\n\n        Returns:\n            ndarray or list: Image data for the site(s).\n        \"\"\"\n        well_info = self.metadata['well_info']\n        sitesx = well_info['SitesX']\n        sitesy = well_info['SitesY']\n        sitesz = well_info.get('SitesZ', 1)\n        num_sites = well_info['num_sites']\n        sizex = well_info['SensorSizeXPixels']\n        sizey = well_info['SensorSizeYPixels']\n        sizez = well_info.get('SensorSizeZPixels', 1)\n\n        if site_id is None:\n            # Return full image data\n            return self.data\n\n        site_id = int(site_id)\n        if site_id &lt; 0:\n            # Return list of all fields\n            data = []\n            for zi in range(sitesz):\n                for yi in range(sitesy):\n                    for xi in range(sitesx):\n                        startx = xi * sizex\n                        starty = yi * sizey\n                        startz = zi * sizez\n                        data.append(self.data[..., startz:startz + sizez, starty:starty + sizey, startx:startx + sizex])\n            return data\n        elif 0 &lt;= site_id &lt; num_sites:\n            # Return specific site\n            xi = site_id % sitesx\n            yi = (site_id // sitesx) % sitesy\n            zi = site_id // sitesx // sitesy\n            startx = xi * sizex\n            starty = yi * sizey\n            startz = zi * sizez\n            return self.data[..., startz:startz + sizez, starty:starty + sizey, startx:startx + sizex]\n        else:\n            raise ValueError(f'Invalid site: {site_id}')\n\n    def is_screen(self):\n        \"\"\"\n        Checks if the source is a screen (has wells).\n\n        Returns:\n            bool: True if wells exist.\n        \"\"\"\n        return len(self.metadata['wells']) &gt; 0\n\n    def get_data(self, well_id=None, field_id=None):\n        \"\"\"\n        Gets image data for a specific well and field.\n\n        Args:\n            well_id (str, optional): Well identifier.\n            field_id (int, optional): Field index.\n\n        Returns:\n            ndarray: Image data.\n        \"\"\"\n        if well_id != self.data_well_id:\n            self._assemble_image_data(self._read_well_info(well_id))\n            self.data_well_id = well_id\n        return self._extract_site(field_id)\n\n    def get_name(self):\n        \"\"\"\n        Gets the experiment or file name.\n\n        Returns:\n            str: Name.\n        \"\"\"\n        name = self.metadata.get('Name')\n        if not name:\n            name = splitall(os.path.splitext(self.uri)[0])[-2]\n        return name\n\n    def get_rows(self):\n        \"\"\"\n        Returns the list of row identifiers.\n\n        Returns:\n            list: Row identifiers.\n        \"\"\"\n        return self.metadata['well_info']['rows']\n\n    def get_columns(self):\n        \"\"\"\n        Returns the list of column identifiers.\n\n        Returns:\n            list: Column identifiers.\n        \"\"\"\n        return self.metadata['well_info']['columns']\n\n    def get_wells(self):\n        \"\"\"\n        Returns the list of well identifiers.\n\n        Returns:\n            list: Well identifiers.\n        \"\"\"\n        return list(self.metadata['wells'])\n\n    def get_time_points(self):\n        \"\"\"\n        Returns the list of time points.\n\n        Returns:\n            list: Time point IDs.\n        \"\"\"\n        return self.metadata['time_points']\n\n    def get_fields(self):\n        \"\"\"\n        Returns the list of field indices.\n\n        Returns:\n            list: Field indices.\n        \"\"\"\n        return self.metadata['well_info']['fields']\n\n    def get_dim_order(self):\n        \"\"\"\n        Returns the dimension order string.\n\n        Returns:\n            str: Dimension order.\n        \"\"\"\n        return self.metadata.get('dim_order', 'tczyx')\n\n    def get_dtype(self):\n        \"\"\"\n        Returns the numpy dtype of the image data.\n\n        Returns:\n            dtype: Numpy dtype.\n        \"\"\"\n        return self.metadata.get('dtype')\n\n    def get_pixel_size_um(self):\n        \"\"\"\n        Returns the pixel size in micrometers.\n\n        Returns:\n            dict: Pixel size for x and y.\n        \"\"\"\n        pixel_size = self.metadata['well_info'].get('PixelSizeUm', 1)\n        return {'x': pixel_size, 'y': pixel_size}\n\n    def get_position_um(self, well_id=None):\n        \"\"\"\n        Returns the position in micrometers for a well.\n\n        Args:\n            well_id (str): Well identifier.\n\n        Returns:\n            dict: Position in micrometers.\n        \"\"\"\n        well = self.metadata['wells'][well_id]\n        well_info = self.metadata['well_info']\n        x = well.get('CoordX', 0) * well_info['max_sizex_um']\n        y = well.get('CoordY', 0) * well_info['max_sizey_um']\n        return {'x': x, 'y': y}\n\n    def get_channels(self):\n        \"\"\"\n        Returns channel metadata.\n\n        Returns:\n            list: List of channel dicts.\n        \"\"\"\n        channels = []\n        for channel0 in self.metadata['channels']:\n            channel = {}\n            if 'Dye' in channel0 and channel0['Dye']:\n                channel['label'] = channel0['Dye']\n            if 'Color' in channel0:\n                channel['color'] = hexrgb_to_rgba(channel0['Color'].lstrip('#'))\n            channels.append(channel)\n        return channels\n\n    def get_nchannels(self):\n        \"\"\"\n        Returns the number of channels.\n\n        Returns:\n            int: Number of channels.\n        \"\"\"\n        return max(self.metadata['num_channels'], 1)\n\n    def get_acquisitions(self):\n        \"\"\"\n        Returns acquisition metadata.\n\n        Returns:\n            list: List of acquisition dicts.\n        \"\"\"\n        acquisitions = []\n        for index, acq in enumerate(self.metadata.get('acquisitions', [])):\n            acquisitions.append({\n                'id': index,\n                'name': acq['Name'],\n                'description': acq['Description'],\n                'date_created': acq['DateCreated'].isoformat(),\n                'date_modified': acq['DateModified'].isoformat()\n            })\n        return acquisitions\n\n    def get_total_data_size(self):\n        \"\"\"\n        Returns the estimated total data size.\n\n        Returns:\n            int: Total data size in bytes.\n        \"\"\"\n        return self.metadata['max_data_size']\n\n    def print_well_matrix(self):\n        \"\"\"\n        Returns a string representation of the well matrix.\n\n        Returns:\n            str: Well matrix.\n        \"\"\"\n        s = ''\n\n        well_info = self.metadata['well_info']\n        rows, cols = well_info['rows'], well_info['columns']\n        used_wells = [well for well in self.metadata['wells']]\n\n        well_matrix = []\n        for row_id in rows:\n            row = ''\n            for col_id in cols:\n                well_id = f'{row_id}{col_id}'\n                row += '+' if well_id in used_wells else ' '\n            well_matrix.append(row)\n\n        header = ' '.join([pad_leading_zero(col) for col in cols])\n        s += ' ' + header + '\\n'\n        for idx, row in enumerate(well_matrix):\n            s += f'{rows[idx]} ' + '  '.join(row) + '\\n'\n        return s\n\n    def print_timepoint_well_matrix(self):\n        \"\"\"\n        Returns a string representation of the timepoint-well matrix.\n\n        Returns:\n            str: Timepoint-well matrix.\n        \"\"\"\n        s = ''\n\n        time_points = self.metadata['time_points']\n        wells = [well for well in self.metadata['wells']]\n\n        well_matrix = []\n        for timepoint in time_points:\n            wells_at_timepoint = self.db.fetch_all('''\n                SELECT DISTINCT Well.Name FROM SourceImageBase\n                JOIN Well ON SourceImageBase.ZoneIndex = Well.ZoneIndex\n                WHERE TimeSeriesElementId = ?\n            ''', (timepoint,), return_dicts=False)\n\n            row = ['+' if well in wells_at_timepoint else ' ' for well in wells]\n            well_matrix.append(row)\n\n        header = ' '.join([pad_leading_zero(well) for well in wells])\n        s += 'Timepoint ' + header + '\\n'\n        for idx, row in enumerate(well_matrix):\n            s += f'{time_points[idx]:9}  ' + '   '.join(row) + '\\n'\n        return s\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        self.db.close()\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.data","title":"<code>data = None</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageDbSource.ImageDbSource.data_well_id","title":"<code>data_well_id = None</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageDbSource.ImageDbSource.db","title":"<code>db = DBReader(self.uri)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageDbSource.ImageDbSource.__init__","title":"<code>__init__(uri, metadata={})</code>","text":"<p>Initialize ImageDbSource.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>Path to the database file.</p> required <code>metadata</code> <code>dict</code> <p>Optional metadata dictionary.</p> <code>{}</code> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def __init__(self, uri, metadata={}):\n    \"\"\"\n    Initialize ImageDbSource.\n\n    Args:\n        uri (str): Path to the database file.\n        metadata (dict): Optional metadata dictionary.\n    \"\"\"\n    super().__init__(uri, metadata)\n    self.db = DBReader(self.uri)\n    self.data = None\n    self.data_well_id = None\n    self.metadata['dim_order'] = 'tczyx'\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.close","title":"<code>close()</code>","text":"<p>Closes the database connection.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def close(self):\n    \"\"\"\n    Closes the database connection.\n    \"\"\"\n    self.db.close()\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_acquisitions","title":"<code>get_acquisitions()</code>","text":"<p>Returns acquisition metadata.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of acquisition dicts.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def get_acquisitions(self):\n    \"\"\"\n    Returns acquisition metadata.\n\n    Returns:\n        list: List of acquisition dicts.\n    \"\"\"\n    acquisitions = []\n    for index, acq in enumerate(self.metadata.get('acquisitions', [])):\n        acquisitions.append({\n            'id': index,\n            'name': acq['Name'],\n            'description': acq['Description'],\n            'date_created': acq['DateCreated'].isoformat(),\n            'date_modified': acq['DateModified'].isoformat()\n        })\n    return acquisitions\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_channels","title":"<code>get_channels()</code>","text":"<p>Returns channel metadata.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of channel dicts.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def get_channels(self):\n    \"\"\"\n    Returns channel metadata.\n\n    Returns:\n        list: List of channel dicts.\n    \"\"\"\n    channels = []\n    for channel0 in self.metadata['channels']:\n        channel = {}\n        if 'Dye' in channel0 and channel0['Dye']:\n            channel['label'] = channel0['Dye']\n        if 'Color' in channel0:\n            channel['color'] = hexrgb_to_rgba(channel0['Color'].lstrip('#'))\n        channels.append(channel)\n    return channels\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_columns","title":"<code>get_columns()</code>","text":"<p>Returns the list of column identifiers.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Column identifiers.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def get_columns(self):\n    \"\"\"\n    Returns the list of column identifiers.\n\n    Returns:\n        list: Column identifiers.\n    \"\"\"\n    return self.metadata['well_info']['columns']\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_data","title":"<code>get_data(well_id=None, field_id=None)</code>","text":"<p>Gets image data for a specific well and field.</p> <p>Parameters:</p> Name Type Description Default <code>well_id</code> <code>str</code> <p>Well identifier.</p> <code>None</code> <code>field_id</code> <code>int</code> <p>Field index.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ndarray</code> <p>Image data.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def get_data(self, well_id=None, field_id=None):\n    \"\"\"\n    Gets image data for a specific well and field.\n\n    Args:\n        well_id (str, optional): Well identifier.\n        field_id (int, optional): Field index.\n\n    Returns:\n        ndarray: Image data.\n    \"\"\"\n    if well_id != self.data_well_id:\n        self._assemble_image_data(self._read_well_info(well_id))\n        self.data_well_id = well_id\n    return self._extract_site(field_id)\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"<p>Returns the dimension order string.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Dimension order.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def get_dim_order(self):\n    \"\"\"\n    Returns the dimension order string.\n\n    Returns:\n        str: Dimension order.\n    \"\"\"\n    return self.metadata.get('dim_order', 'tczyx')\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_dtype","title":"<code>get_dtype()</code>","text":"<p>Returns the numpy dtype of the image data.</p> <p>Returns:</p> Name Type Description <code>dtype</code> <p>Numpy dtype.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def get_dtype(self):\n    \"\"\"\n    Returns the numpy dtype of the image data.\n\n    Returns:\n        dtype: Numpy dtype.\n    \"\"\"\n    return self.metadata.get('dtype')\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_fields","title":"<code>get_fields()</code>","text":"<p>Returns the list of field indices.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Field indices.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def get_fields(self):\n    \"\"\"\n    Returns the list of field indices.\n\n    Returns:\n        list: Field indices.\n    \"\"\"\n    return self.metadata['well_info']['fields']\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_name","title":"<code>get_name()</code>","text":"<p>Gets the experiment or file name.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Name.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def get_name(self):\n    \"\"\"\n    Gets the experiment or file name.\n\n    Returns:\n        str: Name.\n    \"\"\"\n    name = self.metadata.get('Name')\n    if not name:\n        name = splitall(os.path.splitext(self.uri)[0])[-2]\n    return name\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"<p>Returns the number of channels.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of channels.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def get_nchannels(self):\n    \"\"\"\n    Returns the number of channels.\n\n    Returns:\n        int: Number of channels.\n    \"\"\"\n    return max(self.metadata['num_channels'], 1)\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"<p>Returns the pixel size in micrometers.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Pixel size for x and y.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def get_pixel_size_um(self):\n    \"\"\"\n    Returns the pixel size in micrometers.\n\n    Returns:\n        dict: Pixel size for x and y.\n    \"\"\"\n    pixel_size = self.metadata['well_info'].get('PixelSizeUm', 1)\n    return {'x': pixel_size, 'y': pixel_size}\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_position_um","title":"<code>get_position_um(well_id=None)</code>","text":"<p>Returns the position in micrometers for a well.</p> <p>Parameters:</p> Name Type Description Default <code>well_id</code> <code>str</code> <p>Well identifier.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Position in micrometers.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def get_position_um(self, well_id=None):\n    \"\"\"\n    Returns the position in micrometers for a well.\n\n    Args:\n        well_id (str): Well identifier.\n\n    Returns:\n        dict: Position in micrometers.\n    \"\"\"\n    well = self.metadata['wells'][well_id]\n    well_info = self.metadata['well_info']\n    x = well.get('CoordX', 0) * well_info['max_sizex_um']\n    y = well.get('CoordY', 0) * well_info['max_sizey_um']\n    return {'x': x, 'y': y}\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_rows","title":"<code>get_rows()</code>","text":"<p>Returns the list of row identifiers.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Row identifiers.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def get_rows(self):\n    \"\"\"\n    Returns the list of row identifiers.\n\n    Returns:\n        list: Row identifiers.\n    \"\"\"\n    return self.metadata['well_info']['rows']\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_shape","title":"<code>get_shape()</code>","text":"<p>Returns the shape of the image data.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Shape of the image data.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def get_shape(self):\n    \"\"\"\n    Returns the shape of the image data.\n\n    Returns:\n        tuple: Shape of the image data.\n    \"\"\"\n    return self.shape\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_time_points","title":"<code>get_time_points()</code>","text":"<p>Returns the list of time points.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Time point IDs.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def get_time_points(self):\n    \"\"\"\n    Returns the list of time points.\n\n    Returns:\n        list: Time point IDs.\n    \"\"\"\n    return self.metadata['time_points']\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_total_data_size","title":"<code>get_total_data_size()</code>","text":"<p>Returns the estimated total data size.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Total data size in bytes.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def get_total_data_size(self):\n    \"\"\"\n    Returns the estimated total data size.\n\n    Returns:\n        int: Total data size in bytes.\n    \"\"\"\n    return self.metadata['max_data_size']\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_wells","title":"<code>get_wells()</code>","text":"<p>Returns the list of well identifiers.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Well identifiers.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def get_wells(self):\n    \"\"\"\n    Returns the list of well identifiers.\n\n    Returns:\n        list: Well identifiers.\n    \"\"\"\n    return list(self.metadata['wells'])\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.init_metadata","title":"<code>init_metadata()</code>","text":"<p>Initializes and loads metadata from the database.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Metadata dictionary.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def init_metadata(self):\n    \"\"\"\n    Initializes and loads metadata from the database.\n\n    Returns:\n        dict: Metadata dictionary.\n    \"\"\"\n    self._get_time_series_info()\n    self._get_experiment_metadata()\n    self._get_well_info()\n    self._get_image_info()\n    self._get_sizes()\n    return self.metadata\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.is_screen","title":"<code>is_screen()</code>","text":"<p>Checks if the source is a screen (has wells).</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if wells exist.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def is_screen(self):\n    \"\"\"\n    Checks if the source is a screen (has wells).\n\n    Returns:\n        bool: True if wells exist.\n    \"\"\"\n    return len(self.metadata['wells']) &gt; 0\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.print_timepoint_well_matrix","title":"<code>print_timepoint_well_matrix()</code>","text":"<p>Returns a string representation of the timepoint-well matrix.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Timepoint-well matrix.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def print_timepoint_well_matrix(self):\n    \"\"\"\n    Returns a string representation of the timepoint-well matrix.\n\n    Returns:\n        str: Timepoint-well matrix.\n    \"\"\"\n    s = ''\n\n    time_points = self.metadata['time_points']\n    wells = [well for well in self.metadata['wells']]\n\n    well_matrix = []\n    for timepoint in time_points:\n        wells_at_timepoint = self.db.fetch_all('''\n            SELECT DISTINCT Well.Name FROM SourceImageBase\n            JOIN Well ON SourceImageBase.ZoneIndex = Well.ZoneIndex\n            WHERE TimeSeriesElementId = ?\n        ''', (timepoint,), return_dicts=False)\n\n        row = ['+' if well in wells_at_timepoint else ' ' for well in wells]\n        well_matrix.append(row)\n\n    header = ' '.join([pad_leading_zero(well) for well in wells])\n    s += 'Timepoint ' + header + '\\n'\n    for idx, row in enumerate(well_matrix):\n        s += f'{time_points[idx]:9}  ' + '   '.join(row) + '\\n'\n    return s\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.print_well_matrix","title":"<code>print_well_matrix()</code>","text":"<p>Returns a string representation of the well matrix.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Well matrix.</p> Source code in <code>src\\ImageDbSource.py</code> <pre><code>def print_well_matrix(self):\n    \"\"\"\n    Returns a string representation of the well matrix.\n\n    Returns:\n        str: Well matrix.\n    \"\"\"\n    s = ''\n\n    well_info = self.metadata['well_info']\n    rows, cols = well_info['rows'], well_info['columns']\n    used_wells = [well for well in self.metadata['wells']]\n\n    well_matrix = []\n    for row_id in rows:\n        row = ''\n        for col_id in cols:\n            well_id = f'{row_id}{col_id}'\n            row += '+' if well_id in used_wells else ' '\n        well_matrix.append(row)\n\n    header = ' '.join([pad_leading_zero(col) for col in cols])\n    s += ' ' + header + '\\n'\n    for idx, row in enumerate(well_matrix):\n        s += f'{rows[idx]} ' + '  '.join(row) + '\\n'\n    return s\n</code></pre>"},{"location":"references/#src.ImageDbSource.convert_dotnet_ticks_to_datetime","title":"<code>convert_dotnet_ticks_to_datetime(net_ticks)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def convert_dotnet_ticks_to_datetime(net_ticks):\n    return datetime(1, 1, 1) + timedelta(microseconds=net_ticks // 10)\n</code></pre>"},{"location":"references/#src.ImageDbSource.convert_to_um","title":"<code>convert_to_um(value, unit)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def convert_to_um(value, unit):\n    conversions = {\n        'nm': 1e-3,\n        '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'micron': 1,\n        'mm': 1e3, 'millimeter': 1e3,\n        'cm': 1e4, 'centimeter': 1e4,\n        'm': 1e6, 'meter': 1e6\n    }\n    return value * conversions.get(unit, 1)\n</code></pre>"},{"location":"references/#src.ImageDbSource.ensure_list","title":"<code>ensure_list(item)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def ensure_list(item):\n    if not isinstance(item, (list, tuple)):\n        item = [item]\n    return item\n</code></pre>"},{"location":"references/#src.ImageDbSource.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def get_filetitle(filename):\n    return os.path.basename(os.path.splitext(filename)[0])\n</code></pre>"},{"location":"references/#src.ImageDbSource.pad_leading_zero","title":"<code>pad_leading_zero(input_string, num_digits=2)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def pad_leading_zero(input_string, num_digits=2):\n    output = str(input_string)\n    is_well = not output[0].isdigit()\n    if is_well:\n        row, col = split_well_name(output, remove_leading_zeros=True)\n        output = str(col)\n    while len(output) &lt; num_digits:\n        output = '0' + output\n    if is_well:\n        output = row + output\n    return output\n</code></pre>"},{"location":"references/#src.ImageDbSource.print_dict","title":"<code>print_dict(value, tab=0, max_len=250, bullet=False)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def print_dict(value, tab=0, max_len=250, bullet=False):\n    s = ''\n    if isinstance(value, dict):\n        for key, subvalue in value.items():\n            s += '\\n'\n            if bullet:\n                s += '-'\n                bullet = False\n            s += '\\t' * tab + str(key) + ': '\n            if isinstance(subvalue, dict):\n                s += print_dict(subvalue, tab+1)\n            elif isinstance(subvalue, list):\n                for v in subvalue:\n                    s += print_dict(v, tab+1, bullet=True)\n            else:\n                subvalue = str(subvalue)\n                if len(subvalue) &gt; max_len:\n                    subvalue = subvalue[:max_len] + '...'\n                s += subvalue\n    else:\n        s += str(value) + ' '\n    return s\n</code></pre>"},{"location":"references/#src.ImageDbSource.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def print_hbytes(nbytes):\n    exps = ['', 'K', 'M', 'G', 'T', 'P', 'E']\n    div = 1024\n    exp = 0\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    if exp &lt; len(exps):\n        e = exps[exp]\n    else:\n        e = f'e{exp * 3}'\n    return f'{nbytes:.1f}{e}B'\n</code></pre>"},{"location":"references/#src.ImageDbSource.split_well_name","title":"<code>split_well_name(well_name, remove_leading_zeros=True, col_as_int=False)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def split_well_name(well_name, remove_leading_zeros=True, col_as_int=False):\n    matches = re.findall(r'(\\D+)(\\d+)', well_name)\n    if len(matches) &gt; 0:\n        row, col = matches[0]\n        if col_as_int or remove_leading_zeros:\n            try:\n                col = int(col)\n            except ValueError:\n                pass\n        if not col_as_int:\n            col = str(col)\n        return row, col\n    else:\n        raise ValueError(f\"Invalid well name format: {well_name}. Expected format like 'A1', 'B2', etc.\")\n</code></pre>"},{"location":"references/#src.ImageDbSource.splitall","title":"<code>splitall(path)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def splitall(path):\n    allparts = []\n    while True:\n        parts = os.path.split(path)\n        if parts[0] == path:  # sentinel for absolute paths\n            allparts.insert(0, parts[0])\n            break\n        elif parts[1] == path: # sentinel for relative paths\n            allparts.insert(0, parts[1])\n            break\n        else:\n            path = parts[0]\n            allparts.insert(0, parts[1])\n    return allparts\n</code></pre>"},{"location":"references/#src.ImageDbSource.strip_leading_zeros","title":"<code>strip_leading_zeros(well_name)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def strip_leading_zeros(well_name):\n    row, col = split_well_name(well_name, remove_leading_zeros=True)\n    return f'{row}{col}'\n</code></pre>"},{"location":"references/#src.ImageDbSource.xml_content_to_dict","title":"<code>xml_content_to_dict(element)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def xml_content_to_dict(element):\n    key = element.tag\n    children = list(element)\n    if key == 'Array':\n        res = [xml_content_to_dict(child) for child in children]\n        return res\n    if len(children) &gt; 0:\n        if children[0].tag == 'Array':\n            value = []\n        else:\n            value = {}\n        for child in children:\n            child_value = xml_content_to_dict(child)\n            if isinstance(child_value, list):\n                value.extend(child_value)\n            else:\n                value |= child_value\n    else:\n        value = element.text\n        if value is not None:\n            if '\"' in value:\n                value = value.replace('\"', '')\n            else:\n                for t in (float, int, bool):\n                    try:\n                        if t == bool:\n                            if value.lower() == 'true':\n                                value = True\n                            if value.lower() == 'false':\n                                value = False\n                        else:\n                            value = t(value)\n                        break\n                    except (TypeError, ValueError):\n                        pass\n\n    if key == 'DataObject':\n        key = element.attrib['ObjectType']\n    if key == 'Attribute':\n        key = element.attrib['Name']\n    return {key: value}\n</code></pre>"},{"location":"references/#src.ImageSource","title":"<code>ImageSource</code>","text":""},{"location":"references/#src.ImageSource.ImageSource","title":"<code>ImageSource</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for image sources.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>class ImageSource(ABC):\n    \"\"\"\n    Abstract base class for image sources.\n    \"\"\"\n\n    def __init__(self, uri, metadata={}):\n        \"\"\"\n        Initialize ImageSource.\n\n        Args:\n            uri (str): Path to the image source.\n            metadata (dict): Optional metadata dictionary.\n        \"\"\"\n        self.uri = uri\n        self.metadata = metadata\n\n    def init_metadata(self):\n        \"\"\"\n        Initialize and load metadata.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'init_metadata' method must be implemented by subclasses.\")\n\n    def is_screen(self):\n        \"\"\"\n        Check if the source is a screen (multi-well).\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'is_screen' method must be implemented by subclasses.\")\n\n    def get_shape(self):\n        \"\"\"\n        Get the shape of the image data.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_shape' method must be implemented by subclasses.\")\n\n    def get_data(self, well_id=None, field_id=None):\n        \"\"\"\n        Get image data for a well and field.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_data' method must be implemented by subclasses.\")\n\n    def get_name(self):\n        \"\"\"\n        Get the name of the image source.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_name' method must be implemented by subclasses.\")\n\n    def get_dim_order(self):\n        \"\"\"\n        Get the dimension order string.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_dim_order' method must be implemented by subclasses.\")\n\n    def get_dtype(self):\n        \"\"\"\n        Get the numpy dtype of the image data.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_dtype' method must be implemented by subclasses.\")\n\n    def get_pixel_size_um(self):\n        \"\"\"\n        Get the pixel size in micrometers.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_pixel_size_um' method must be implemented by subclasses.\")\n\n    def get_position_um(self, well_id=None):\n        \"\"\"\n        Get the position in micrometers for a well.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_position_um' method must be implemented by subclasses.\")\n\n    def get_channels(self):\n        \"\"\"\n        Get channel metadata in NGFF format, color provided as RGBA list with values between 0 and 1\n        e.g. white = [1, 1, 1, 1]\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_channels' method must be implemented by subclasses.\")\n\n    def get_nchannels(self):\n        \"\"\"\n        Get the number of channels.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_nchannels' method must be implemented by subclasses.\")\n\n    def get_rows(self):\n        \"\"\"\n        Get the list of row identifiers.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_rows' method must be implemented by subclasses.\")\n\n    def get_columns(self):\n        \"\"\"\n        Get the list of column identifiers.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_columns' method must be implemented by subclasses.\")\n\n    def get_wells(self):\n        \"\"\"\n        Get the list of well identifiers.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_wells' method must be implemented by subclasses.\")\n\n    def get_time_points(self):\n        \"\"\"\n        Get the list of time points.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_time_points' method must be implemented by subclasses.\")\n\n    def get_fields(self):\n        \"\"\"\n        Get the list of field indices.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_fields' method must be implemented by subclasses.\")\n\n    def get_acquisitions(self):\n        \"\"\"\n        Get acquisition metadata.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_acquisitions' method must be implemented by subclasses.\")\n\n    def get_total_data_size(self):\n        \"\"\"\n        Get the estimated total data size.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_total_data_size' method must be implemented by subclasses.\")\n\n    def close(self):\n        \"\"\"\n        Close the image source.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.metadata","title":"<code>metadata = metadata</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageSource.ImageSource.uri","title":"<code>uri = uri</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageSource.ImageSource.__init__","title":"<code>__init__(uri, metadata={})</code>","text":"<p>Initialize ImageSource.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>Path to the image source.</p> required <code>metadata</code> <code>dict</code> <p>Optional metadata dictionary.</p> <code>{}</code> Source code in <code>src\\ImageSource.py</code> <pre><code>def __init__(self, uri, metadata={}):\n    \"\"\"\n    Initialize ImageSource.\n\n    Args:\n        uri (str): Path to the image source.\n        metadata (dict): Optional metadata dictionary.\n    \"\"\"\n    self.uri = uri\n    self.metadata = metadata\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.close","title":"<code>close()</code>","text":"<p>Close the image source.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def close(self):\n    \"\"\"\n    Close the image source.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_acquisitions","title":"<code>get_acquisitions()</code>","text":"<p>Get acquisition metadata.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def get_acquisitions(self):\n    \"\"\"\n    Get acquisition metadata.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_acquisitions' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_channels","title":"<code>get_channels()</code>","text":"<p>Get channel metadata in NGFF format, color provided as RGBA list with values between 0 and 1 e.g. white = [1, 1, 1, 1]</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def get_channels(self):\n    \"\"\"\n    Get channel metadata in NGFF format, color provided as RGBA list with values between 0 and 1\n    e.g. white = [1, 1, 1, 1]\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_channels' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_columns","title":"<code>get_columns()</code>","text":"<p>Get the list of column identifiers.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def get_columns(self):\n    \"\"\"\n    Get the list of column identifiers.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_columns' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_data","title":"<code>get_data(well_id=None, field_id=None)</code>","text":"<p>Get image data for a well and field.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def get_data(self, well_id=None, field_id=None):\n    \"\"\"\n    Get image data for a well and field.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_data' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"<p>Get the dimension order string.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def get_dim_order(self):\n    \"\"\"\n    Get the dimension order string.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_dim_order' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_dtype","title":"<code>get_dtype()</code>","text":"<p>Get the numpy dtype of the image data.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def get_dtype(self):\n    \"\"\"\n    Get the numpy dtype of the image data.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_dtype' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_fields","title":"<code>get_fields()</code>","text":"<p>Get the list of field indices.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def get_fields(self):\n    \"\"\"\n    Get the list of field indices.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_fields' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_name","title":"<code>get_name()</code>","text":"<p>Get the name of the image source.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def get_name(self):\n    \"\"\"\n    Get the name of the image source.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_name' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"<p>Get the number of channels.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def get_nchannels(self):\n    \"\"\"\n    Get the number of channels.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_nchannels' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"<p>Get the pixel size in micrometers.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def get_pixel_size_um(self):\n    \"\"\"\n    Get the pixel size in micrometers.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_pixel_size_um' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_position_um","title":"<code>get_position_um(well_id=None)</code>","text":"<p>Get the position in micrometers for a well.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def get_position_um(self, well_id=None):\n    \"\"\"\n    Get the position in micrometers for a well.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_position_um' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_rows","title":"<code>get_rows()</code>","text":"<p>Get the list of row identifiers.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def get_rows(self):\n    \"\"\"\n    Get the list of row identifiers.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_rows' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_shape","title":"<code>get_shape()</code>","text":"<p>Get the shape of the image data.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def get_shape(self):\n    \"\"\"\n    Get the shape of the image data.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_shape' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_time_points","title":"<code>get_time_points()</code>","text":"<p>Get the list of time points.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def get_time_points(self):\n    \"\"\"\n    Get the list of time points.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_time_points' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_total_data_size","title":"<code>get_total_data_size()</code>","text":"<p>Get the estimated total data size.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def get_total_data_size(self):\n    \"\"\"\n    Get the estimated total data size.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_total_data_size' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_wells","title":"<code>get_wells()</code>","text":"<p>Get the list of well identifiers.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def get_wells(self):\n    \"\"\"\n    Get the list of well identifiers.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_wells' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.init_metadata","title":"<code>init_metadata()</code>","text":"<p>Initialize and load metadata.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def init_metadata(self):\n    \"\"\"\n    Initialize and load metadata.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'init_metadata' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.is_screen","title":"<code>is_screen()</code>","text":"<p>Check if the source is a screen (multi-well).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src\\ImageSource.py</code> <pre><code>def is_screen(self):\n    \"\"\"\n    Check if the source is a screen (multi-well).\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'is_screen' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.OmeTiffWriter","title":"<code>OmeTiffWriter</code>","text":""},{"location":"references/#src.OmeTiffWriter.OmeTiffWriter","title":"<code>OmeTiffWriter</code>","text":"<p>               Bases: <code>OmeWriter</code></p> <p>Writes image data and metadata to OME-TIFF files.</p> Source code in <code>src\\OmeTiffWriter.py</code> <pre><code>class OmeTiffWriter(OmeWriter):\n    \"\"\"\n    Writes image data and metadata to OME-TIFF files.\n    \"\"\"\n    def __init__(self, verbose=False):\n        \"\"\"\n        Initialize OmeTiffWriter.\n\n        Args:\n            verbose (bool): If True, prints progress info.\n        \"\"\"\n        super().__init__()\n        self.verbose = verbose\n\n    def write(self, filepath, source, **kwargs):\n        \"\"\"\n        Writes image or screen data to OME-TIFF files.\n\n        Args:\n            filepath (str): Output file path.\n            source (ImageSource): Source object.\n            **kwargs: Additional options.\n\n        Returns:\n            str or list: Output file path(s).\n        \"\"\"\n        if source.is_screen():\n            filepath, total_size = self._write_screen(filepath, source, **kwargs)\n        else:\n            filepath, total_size = self._write_image(filepath, source, **kwargs)\n\n        if self.verbose:\n            print(f'Total data written: {print_hbytes(total_size)}')\n\n        return filepath\n\n    def _write_screen(self, filename, source, **kwargs):\n        \"\"\"\n        Writes multi-well screen data to separate TIFF files and companion metadata.\n\n        Args:\n            filename (str): Output file name.\n            source (ImageSource): Source object.\n            **kwargs: Additional options.\n\n        Returns:\n            tuple: (List of output paths, total data size)\n        \"\"\"\n        # writes separate tiff files for each field, and separate metadata companion file\n        output_paths = []\n        filepath, filename = os.path.split(filename)\n        filetitle = os.path.splitext(filename)[0].rstrip('.ome')\n\n        companion_filename = os.path.join(filepath, filetitle + '.companion.ome')\n        companion_uuid = create_uuid()\n\n        total_size = 0\n        image_uuids = []\n        image_filenames = []\n        for well_id in source.get_wells():\n            for field in source.get_fields():\n                resolution, resolution_unit = create_resolution_metadata(source)\n                data = source.get_data(well_id, field)\n\n                filename = f'{filetitle}'\n                filename += f'_{pad_leading_zero(well_id)}'\n                if field is not None:\n                    filename += f'_{pad_leading_zero(field)}'\n                filename = os.path.join(filepath, filename + '.ome.tiff')\n                xml_metadata, image_uuid = create_binaryonly_metadata(os.path.basename(companion_filename), companion_uuid)\n\n                size = self._write_tiff(filename, source, data,\n                                        resolution=resolution, resolution_unit=resolution_unit,\n                                        tile_size=kwargs.get('tile_size'), compression=kwargs.get('compression'),\n                                        xml_metadata=xml_metadata, pyramid_levels=4)\n\n                image_uuids.append(image_uuid)\n                image_filenames.append(os.path.basename(filename))\n                output_paths.append(filename)\n                total_size += size\n\n        xml_metadata = create_metadata(source, companion_uuid, image_uuids, image_filenames)\n        with open(companion_filename, 'wb') as file:\n            file.write(xml_metadata.encode())\n\n        output_paths = [companion_filename] + output_paths\n        return output_paths, total_size\n\n    def _write_image(self, filename, source, **kwargs):\n        \"\"\"\n        Writes single image data to a TIFF file.\n\n        Args:\n            filename (str): Output file name.\n            source (ImageSource): Source object.\n            **kwargs: Additional options.\n\n        Returns:\n            tuple: (Output path, data size)\n        \"\"\"\n        xml_metadata, _ = create_metadata(source)\n        resolution, resolution_unit = create_resolution_metadata(source)\n        data = source.get_data()\n\n        size = self._write_tiff(filename, source, data,\n                                resolution=resolution, resolution_unit=resolution_unit,\n                                tile_size=kwargs.get('tile_size'), compression=kwargs.get('compression'),\n                                xml_metadata=xml_metadata, pyramid_levels=4)\n\n        return filename, size\n\n    def _write_tiff(self, filename, source, data,\n                  resolution=None, resolution_unit=None, tile_size=None, compression=None,\n                  xml_metadata=None, pyramid_levels=0, pyramid_scale=2):\n        \"\"\"\n        Writes image data to a TIFF file with optional pyramids and metadata.\n\n        Args:\n            filename (str): Output file name.\n            source (ImageSource): Source object.\n            data (ndarray): Image data.\n            resolution (tuple, optional): Pixel resolution.\n            resolution_unit (str, optional): Resolution unit.\n            tile_size (int or tuple, optional): Tile size.\n            compression (str, optional): Compression type.\n            xml_metadata (str, optional): OME-XML metadata.\n            pyramid_levels (int): Number of pyramid levels.\n            pyramid_scale (int): Pyramid downscale factor.\n\n        Returns:\n            int: Data size in bytes.\n        \"\"\"\n        dim_order = source.get_dim_order()\n        shape = data.shape\n        x_index = dim_order.index('x')\n        y_index = dim_order.index('y')\n        size = shape[x_index], shape[y_index]\n        source_type = source.get_dtype()\n\n        if tile_size is not None and isinstance(tile_size, int):\n            tile_size = [tile_size] * 2\n\n        if resolution is not None:\n            # tifffile only supports x/y pyramid resolution\n            resolution = tuple(resolution[0:2])\n\n        if xml_metadata is not None:\n            # set ome=False to provide custom OME xml in description\n            xml_metadata_bytes = xml_metadata.encode()\n            is_ome = False\n        else:\n            xml_metadata_bytes = None\n            is_ome = True\n\n        # maximum size (w/o compression)\n        max_size = data.size * data.itemsize\n        base_size = np.divide(max_size, np.prod(size))\n        scale = 1\n        for level in range(pyramid_levels):\n            max_size += np.prod(size) * scale * base_size\n            scale /= pyramid_scale\n        bigtiff = (max_size &gt; 2 ** 32)\n\n        size = data.size * data.itemsize\n        with TiffWriter(filename, bigtiff=bigtiff, ome=is_ome) as writer:\n            for level in range(pyramid_levels + 1):\n                if level == 0:\n                    scale = 1\n                    subifds = pyramid_levels\n                    subfiletype = None\n                else:\n                    scale /= pyramid_scale\n                    new_shape = list(shape)\n                    new_shape[x_index] = int(shape[x_index] * scale)\n                    new_shape[y_index] = int(shape[y_index] * scale)\n                    data = resize(data, new_shape, preserve_range=True)\n                    subifds = None\n                    subfiletype = 1\n                    xml_metadata_bytes = None\n                writer.write(data.astype(source_type), subifds=subifds, subfiletype=subfiletype,\n                             resolution=resolution, resolutionunit=resolution_unit, tile=tile_size,\n                             compression=compression, description=xml_metadata_bytes)\n        return size\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.OmeTiffWriter.verbose","title":"<code>verbose = verbose</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.OmeTiffWriter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>Initialize OmeTiffWriter.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, prints progress info.</p> <code>False</code> Source code in <code>src\\OmeTiffWriter.py</code> <pre><code>def __init__(self, verbose=False):\n    \"\"\"\n    Initialize OmeTiffWriter.\n\n    Args:\n        verbose (bool): If True, prints progress info.\n    \"\"\"\n    super().__init__()\n    self.verbose = verbose\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.OmeTiffWriter.write","title":"<code>write(filepath, source, **kwargs)</code>","text":"<p>Writes image or screen data to OME-TIFF files.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Output file path.</p> required <code>source</code> <code>ImageSource</code> <p>Source object.</p> required <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> <p>Returns:</p> Type Description <p>str or list: Output file path(s).</p> Source code in <code>src\\OmeTiffWriter.py</code> <pre><code>def write(self, filepath, source, **kwargs):\n    \"\"\"\n    Writes image or screen data to OME-TIFF files.\n\n    Args:\n        filepath (str): Output file path.\n        source (ImageSource): Source object.\n        **kwargs: Additional options.\n\n    Returns:\n        str or list: Output file path(s).\n    \"\"\"\n    if source.is_screen():\n        filepath, total_size = self._write_screen(filepath, source, **kwargs)\n    else:\n        filepath, total_size = self._write_image(filepath, source, **kwargs)\n\n    if self.verbose:\n        print(f'Total data written: {print_hbytes(total_size)}')\n\n    return filepath\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.convert_dotnet_ticks_to_datetime","title":"<code>convert_dotnet_ticks_to_datetime(net_ticks)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def convert_dotnet_ticks_to_datetime(net_ticks):\n    return datetime(1, 1, 1) + timedelta(microseconds=net_ticks // 10)\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.convert_to_um","title":"<code>convert_to_um(value, unit)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def convert_to_um(value, unit):\n    conversions = {\n        'nm': 1e-3,\n        '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'micron': 1,\n        'mm': 1e3, 'millimeter': 1e3,\n        'cm': 1e4, 'centimeter': 1e4,\n        'm': 1e6, 'meter': 1e6\n    }\n    return value * conversions.get(unit, 1)\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.ensure_list","title":"<code>ensure_list(item)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def ensure_list(item):\n    if not isinstance(item, (list, tuple)):\n        item = [item]\n    return item\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def get_filetitle(filename):\n    return os.path.basename(os.path.splitext(filename)[0])\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.pad_leading_zero","title":"<code>pad_leading_zero(input_string, num_digits=2)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def pad_leading_zero(input_string, num_digits=2):\n    output = str(input_string)\n    is_well = not output[0].isdigit()\n    if is_well:\n        row, col = split_well_name(output, remove_leading_zeros=True)\n        output = str(col)\n    while len(output) &lt; num_digits:\n        output = '0' + output\n    if is_well:\n        output = row + output\n    return output\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.print_dict","title":"<code>print_dict(value, tab=0, max_len=250, bullet=False)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def print_dict(value, tab=0, max_len=250, bullet=False):\n    s = ''\n    if isinstance(value, dict):\n        for key, subvalue in value.items():\n            s += '\\n'\n            if bullet:\n                s += '-'\n                bullet = False\n            s += '\\t' * tab + str(key) + ': '\n            if isinstance(subvalue, dict):\n                s += print_dict(subvalue, tab+1)\n            elif isinstance(subvalue, list):\n                for v in subvalue:\n                    s += print_dict(v, tab+1, bullet=True)\n            else:\n                subvalue = str(subvalue)\n                if len(subvalue) &gt; max_len:\n                    subvalue = subvalue[:max_len] + '...'\n                s += subvalue\n    else:\n        s += str(value) + ' '\n    return s\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def print_hbytes(nbytes):\n    exps = ['', 'K', 'M', 'G', 'T', 'P', 'E']\n    div = 1024\n    exp = 0\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    if exp &lt; len(exps):\n        e = exps[exp]\n    else:\n        e = f'e{exp * 3}'\n    return f'{nbytes:.1f}{e}B'\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.split_well_name","title":"<code>split_well_name(well_name, remove_leading_zeros=True, col_as_int=False)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def split_well_name(well_name, remove_leading_zeros=True, col_as_int=False):\n    matches = re.findall(r'(\\D+)(\\d+)', well_name)\n    if len(matches) &gt; 0:\n        row, col = matches[0]\n        if col_as_int or remove_leading_zeros:\n            try:\n                col = int(col)\n            except ValueError:\n                pass\n        if not col_as_int:\n            col = str(col)\n        return row, col\n    else:\n        raise ValueError(f\"Invalid well name format: {well_name}. Expected format like 'A1', 'B2', etc.\")\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.splitall","title":"<code>splitall(path)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def splitall(path):\n    allparts = []\n    while True:\n        parts = os.path.split(path)\n        if parts[0] == path:  # sentinel for absolute paths\n            allparts.insert(0, parts[0])\n            break\n        elif parts[1] == path: # sentinel for relative paths\n            allparts.insert(0, parts[1])\n            break\n        else:\n            path = parts[0]\n            allparts.insert(0, parts[1])\n    return allparts\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.strip_leading_zeros","title":"<code>strip_leading_zeros(well_name)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def strip_leading_zeros(well_name):\n    row, col = split_well_name(well_name, remove_leading_zeros=True)\n    return f'{row}{col}'\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.xml_content_to_dict","title":"<code>xml_content_to_dict(element)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def xml_content_to_dict(element):\n    key = element.tag\n    children = list(element)\n    if key == 'Array':\n        res = [xml_content_to_dict(child) for child in children]\n        return res\n    if len(children) &gt; 0:\n        if children[0].tag == 'Array':\n            value = []\n        else:\n            value = {}\n        for child in children:\n            child_value = xml_content_to_dict(child)\n            if isinstance(child_value, list):\n                value.extend(child_value)\n            else:\n                value |= child_value\n    else:\n        value = element.text\n        if value is not None:\n            if '\"' in value:\n                value = value.replace('\"', '')\n            else:\n                for t in (float, int, bool):\n                    try:\n                        if t == bool:\n                            if value.lower() == 'true':\n                                value = True\n                            if value.lower() == 'false':\n                                value = False\n                        else:\n                            value = t(value)\n                        break\n                    except (TypeError, ValueError):\n                        pass\n\n    if key == 'DataObject':\n        key = element.attrib['ObjectType']\n    if key == 'Attribute':\n        key = element.attrib['Name']\n    return {key: value}\n</code></pre>"},{"location":"references/#src.OmeWriter","title":"<code>OmeWriter</code>","text":""},{"location":"references/#src.OmeWriter.OmeWriter","title":"<code>OmeWriter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for OME writers.</p> Source code in <code>src\\OmeWriter.py</code> <pre><code>class OmeWriter(ABC):\n    \"\"\"\n    Abstract base class for OME writers.\n    \"\"\"\n\n    def write(self, filepath, source, verbose=False, **kwargs) -&gt; str:\n        \"\"\"\n        Write image data and metadata to output.\n\n        Args:\n            filepath (str): Output file path.\n            source (ImageSource): Source object.\n            verbose (bool): If True, prints progress info.\n            **kwargs: Additional options.\n\n        Returns:\n            str: Output file path(s).\n        \"\"\"\n        # Expect to return output path (or filepath)\n        raise NotImplementedError(\"This method should be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.OmeWriter.OmeWriter.write","title":"<code>write(filepath, source, verbose=False, **kwargs)</code>","text":"<p>Write image data and metadata to output.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Output file path.</p> required <code>source</code> <code>ImageSource</code> <p>Source object.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints progress info.</p> <code>False</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Output file path(s).</p> Source code in <code>src\\OmeWriter.py</code> <pre><code>def write(self, filepath, source, verbose=False, **kwargs) -&gt; str:\n    \"\"\"\n    Write image data and metadata to output.\n\n    Args:\n        filepath (str): Output file path.\n        source (ImageSource): Source object.\n        verbose (bool): If True, prints progress info.\n        **kwargs: Additional options.\n\n    Returns:\n        str: Output file path(s).\n    \"\"\"\n    # Expect to return output path (or filepath)\n    raise NotImplementedError(\"This method should be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.OmeZarrWriter","title":"<code>OmeZarrWriter</code>","text":""},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter","title":"<code>OmeZarrWriter</code>","text":"<p>               Bases: <code>OmeWriter</code></p> Source code in <code>src\\OmeZarrWriter.py</code> <pre><code>class OmeZarrWriter(OmeWriter):\n    def __init__(self, zarr_version=2, ome_version='0.4', verbose=False):\n        super().__init__()\n        self.zarr_version = zarr_version\n        self.ome_version = ome_version\n        if ome_version == '0.4':\n            from ome_zarr.format import FormatV04\n            self.ome_format = FormatV04()\n        elif ome_version == '0.5':\n            from ome_zarr.format import FormatV05\n            self.ome_format = FormatV05()\n        else:\n            self.ome_format = None\n        self.verbose = verbose\n\n    def write(self, filepath, source, **kwargs):\n        if source.is_screen():\n            zarr_root, total_size = self._write_screen(filepath, source, **kwargs)\n        else:\n            zarr_root, total_size = self._write_image(filepath, source)\n\n        zarr_root.attrs['_creator'] = {'name': 'nl.biomero.OmeZarrWriter', 'version': VERSION}\n\n        if self.verbose:\n            print(f'Total data written: {print_hbytes(total_size)}')\n\n        return filepath\n\n    def _write_screen(self, filepath, source, **kwargs):\n        #zarr_location = parse_url(filename, mode='w', fmt=self.ome_format)\n        zarr_location = filepath\n        zarr_root = zarr.open_group(zarr_location, mode='w', zarr_version=self.zarr_version)\n\n        row_names = source.get_rows()\n        col_names = source.get_columns()\n        wells = source.get_wells()\n        well_paths = ['/'.join(split_well_name(well)) for well in wells]\n        fields = list(map(str, source.get_fields()))\n\n        acquisitions = source.get_acquisitions()\n        name = source.get_name()\n        write_plate_metadata(zarr_root, row_names, col_names, well_paths,\n                             name=name, field_count=len(fields), acquisitions=acquisitions,\n                             fmt=self.ome_format)\n        total_size = 0\n        for well_id in wells:\n            row, col = split_well_name(well_id)\n            row_group = zarr_root.require_group(str(row))\n            well_group = row_group.require_group(str(col))\n            write_well_metadata(well_group, fields, fmt=self.ome_format)\n            position = source.get_position_um(well_id)\n            for field in fields:\n                image_group = well_group.require_group(field)\n                data = source.get_data(well_id, field)\n                size = self._write_data(image_group, data, source, position)\n                total_size += size\n\n        return zarr_root, total_size\n\n    def _write_image(self, filepath, source):\n        #zarr_location = parse_url(filename, mode='w', fmt=self.ome_format)\n        zarr_location = filepath\n        zarr_root = zarr.open_group(zarr_location, mode='w', zarr_version=self.zarr_version)\n\n        data = source.get_data()\n        size = self._write_data(zarr_root, data, source)\n        return zarr_root, size\n\n    def _write_data(self, group, data, source, position=None):\n        dim_order = source.get_dim_order()\n        if dim_order[-1] == 'c':\n            dim_order = 'c' + dim_order[:-1]\n            data = np.moveaxis(data, -1, 0)\n        axes = create_axes_metadata(dim_order)\n        pixel_size_scales, scaler = self._create_scale_metadata(source, dim_order, position)\n\n        if self.zarr_version &gt;= 3:\n            shards = []\n            chunks = []\n            # TODO: don't redefine chunks for dask/+ arrays\n            for dim, n in zip(dim_order, data.shape):\n                if dim in 'xy':\n                    shards += [10240]\n                    chunks += [1024]\n                else:\n                    shards += [1]\n                    chunks += [1]\n            storage_options = {'chunks': chunks, 'shards': shards}\n        else:\n            storage_options = None\n\n        size = data.size * data.itemsize\n        write_image(image=data, group=group, axes=axes, coordinate_transformations=pixel_size_scales,\n                    scaler=scaler, fmt=self.ome_format, storage_options=storage_options)\n\n        dtype = source.get_dtype()\n        channels = source.get_channels()\n        nchannels = source.get_nchannels()\n        window_scanner = WindowScanner()\n        window_scanner.process(data, dim_order)\n        window = window_scanner.get_window()\n        group.attrs['omero'] = create_channel_metadata(dtype, channels, nchannels, window, self.ome_version)\n        return size\n\n    def _create_scale_metadata(self, source, dim_order, translation, scaler=None):\n        if scaler is None:\n            scaler = Scaler()\n        pixel_size_scales = []\n        scale = 1\n        for i in range(scaler.max_layer + 1):\n            pixel_size_scales.append(\n                create_transformation_metadata(dim_order, source.get_pixel_size_um(),\n                                               scale, translation))\n            scale /= scaler.downscale\n        return pixel_size_scales, scaler\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.ome_format","title":"<code>ome_format = FormatV04()</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.ome_version","title":"<code>ome_version = ome_version</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.verbose","title":"<code>verbose = verbose</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.zarr_version","title":"<code>zarr_version = zarr_version</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.__init__","title":"<code>__init__(zarr_version=2, ome_version='0.4', verbose=False)</code>","text":"Source code in <code>src\\OmeZarrWriter.py</code> <pre><code>def __init__(self, zarr_version=2, ome_version='0.4', verbose=False):\n    super().__init__()\n    self.zarr_version = zarr_version\n    self.ome_version = ome_version\n    if ome_version == '0.4':\n        from ome_zarr.format import FormatV04\n        self.ome_format = FormatV04()\n    elif ome_version == '0.5':\n        from ome_zarr.format import FormatV05\n        self.ome_format = FormatV05()\n    else:\n        self.ome_format = None\n    self.verbose = verbose\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.write","title":"<code>write(filepath, source, **kwargs)</code>","text":"Source code in <code>src\\OmeZarrWriter.py</code> <pre><code>def write(self, filepath, source, **kwargs):\n    if source.is_screen():\n        zarr_root, total_size = self._write_screen(filepath, source, **kwargs)\n    else:\n        zarr_root, total_size = self._write_image(filepath, source)\n\n    zarr_root.attrs['_creator'] = {'name': 'nl.biomero.OmeZarrWriter', 'version': VERSION}\n\n    if self.verbose:\n        print(f'Total data written: {print_hbytes(total_size)}')\n\n    return filepath\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.create_axes_metadata","title":"<code>create_axes_metadata(dimension_order)</code>","text":"<p>Create axes metadata for OME-Zarr from dimension order.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of axis metadata dictionaries.</p> Source code in <code>src\\ome_zarr_util.py</code> <pre><code>def create_axes_metadata(dimension_order):\n    \"\"\"\n    Create axes metadata for OME-Zarr from dimension order.\n\n    Args:\n        dimension_order (str): String of dimension characters.\n\n    Returns:\n        list: List of axis metadata dictionaries.\n    \"\"\"\n    axes = []\n    for dimension in dimension_order:\n        unit1 = None\n        if dimension == 't':\n            type1 = 'time'\n            unit1 = 'millisecond'\n        elif dimension == 'c':\n            type1 = 'channel'\n        else:\n            type1 = 'space'\n            unit1 = 'micrometer'\n        axis = {'name': dimension, 'type': type1}\n        if unit1 is not None and unit1 != '':\n            axis['unit'] = unit1\n        axes.append(axis)\n    return axes\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.create_channel_metadata","title":"<code>create_channel_metadata(dtype, channels, nchannels, window, ome_version)</code>","text":"<p>Create channel metadata for OME-Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <p>Numpy dtype of image data.</p> required <code>channels</code> <code>list</code> <p>List of channel dicts.</p> required <code>nchannels</code> <code>int</code> <p>Number of channels.</p> required <code>window</code> <code>tuple</code> <p>Min/max window values.</p> required <code>ome_version</code> <code>str</code> <p>OME-Zarr version.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Channel metadata dictionary.</p> Source code in <code>src\\ome_zarr_util.py</code> <pre><code>def create_channel_metadata(dtype, channels, nchannels, window, ome_version):\n    \"\"\"\n    Create channel metadata for OME-Zarr.\n\n    Args:\n        dtype: Numpy dtype of image data.\n        channels (list): List of channel dicts.\n        nchannels (int): Number of channels.\n        window (tuple): Min/max window values.\n        ome_version (str): OME-Zarr version.\n\n    Returns:\n        dict: Channel metadata dictionary.\n    \"\"\"\n    if len(channels) &lt; nchannels:\n        labels = []\n        colors = []\n        if nchannels in (3, 4):\n            labels = ['Red', 'Green', 'Blue']\n            colors = [\"FF0000\", \"00FF00\", \"0000FF\"]\n        if nchannels == 4:\n            labels += ['Alpha']\n            colors += [\"FFFFFF\"]\n        channels = [{'label': label, 'color': color} for label, color in zip(labels, colors)]\n\n    omezarr_channels = []\n    start, end = window\n    for channeli, channel in enumerate(channels):\n        omezarr_channel = {'label': channel.get('label', channel.get('Name', f'{channeli}')), 'active': True}\n        color = channel.get('color', channel.get('Color'))\n        if color is not None:\n            omezarr_channel['color'] = rgba_to_hexrgb(color)\n        if dtype.kind == 'f':\n            min, max = 0, 1\n        else:\n            info = np.iinfo(dtype)\n            min, max = info.min, info.max\n        omezarr_channel['window'] = {'min': min, 'max': max, 'start': start[channeli], 'end': end[channeli]}\n        omezarr_channels.append(omezarr_channel)\n\n    metadata = {\n        'version': ome_version,\n        'channels': omezarr_channels,\n    }\n    return metadata\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.create_transformation_metadata","title":"<code>create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um={})</code>","text":"<p>Create transformation metadata (scale and translation) for OME-Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <code>pixel_size_um</code> <code>dict</code> <p>Pixel size in micrometers per dimension.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <code>translation_um</code> <code>dict</code> <p>Translation in micrometers per dimension.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>list</code> <p>List of transformation metadata dictionaries.</p> Source code in <code>src\\ome_zarr_util.py</code> <pre><code>def create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um={}):\n    \"\"\"\n    Create transformation metadata (scale and translation) for OME-Zarr.\n\n    Args:\n        dimension_order (str): String of dimension characters.\n        pixel_size_um (dict): Pixel size in micrometers per dimension.\n        scale (float): Scaling factor.\n        translation_um (dict, optional): Translation in micrometers per dimension.\n\n    Returns:\n        list: List of transformation metadata dictionaries.\n    \"\"\"\n    metadata = []\n    pixel_size_scale = []\n    translation_scale = []\n    for dimension in dimension_order:\n        pixel_size_scale1 = pixel_size_um.get(dimension, 1)\n        if pixel_size_scale1 == 0:\n            pixel_size_scale1 = 1\n        if dimension in ['x', 'y']:\n            pixel_size_scale1 /= scale\n        pixel_size_scale.append(pixel_size_scale1)\n\n        translation1 = translation_um.get(dimension, 0)\n        if dimension in ['x', 'y']:\n            translation1 *= scale\n        translation_scale.append(translation1)\n\n    metadata.append({'type': 'scale', 'scale': pixel_size_scale})\n    if not all(v == 0 for v in translation_scale):\n        metadata.append({'type': 'translation', 'translation': translation_scale})\n    return metadata\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.rgba_to_hexrgb","title":"<code>rgba_to_hexrgb(rgba)</code>","text":"Source code in <code>src\\color_conversion.py</code> <pre><code>def rgba_to_hexrgb(rgba: list) -&gt; str:\n    hexrgb = ''.join([hex(int(x * 255))[2:].upper().zfill(2) for x in rgba[:3]])\n    return hexrgb\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.scale_dimensions_dict","title":"<code>scale_dimensions_dict(shape0, scale)</code>","text":"<p>Scale x and y dimensions in a shape dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>shape0</code> <code>dict</code> <p>Original shape dictionary.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Scaled shape dictionary.</p> Source code in <code>src\\ome_zarr_util.py</code> <pre><code>def scale_dimensions_dict(shape0, scale):\n    \"\"\"\n    Scale x and y dimensions in a shape dictionary.\n\n    Args:\n        shape0 (dict): Original shape dictionary.\n        scale (float): Scaling factor.\n\n    Returns:\n        dict: Scaled shape dictionary.\n    \"\"\"\n    shape = {}\n    if scale == 1:\n        return shape0\n    for dimension, shape1 in shape0.items():\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape[dimension] = shape1\n    return shape\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.scale_dimensions_xy","title":"<code>scale_dimensions_xy(shape0, dimension_order, scale)</code>","text":"<p>Scale x and y dimensions in a shape tuple.</p> <p>Parameters:</p> Name Type Description Default <code>shape0</code> <code>tuple</code> <p>Original shape.</p> required <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Scaled shape.</p> Source code in <code>src\\ome_zarr_util.py</code> <pre><code>def scale_dimensions_xy(shape0, dimension_order, scale):\n    \"\"\"\n    Scale x and y dimensions in a shape tuple.\n\n    Args:\n        shape0 (tuple): Original shape.\n        dimension_order (str): String of dimension characters.\n        scale (float): Scaling factor.\n\n    Returns:\n        list: Scaled shape.\n    \"\"\"\n    shape = []\n    if scale == 1:\n        return shape0\n    for shape1, dimension in zip(shape0, dimension_order):\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape.append(shape1)\n    return shape\n</code></pre>"},{"location":"references/#src.TiffSource","title":"<code>TiffSource</code>","text":""},{"location":"references/#src.TiffSource.TiffSource","title":"<code>TiffSource</code>","text":"<p>               Bases: <code>ImageSource</code></p> <p>Loads image and metadata from TIFF or OME-TIFF files.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>class TiffSource(ImageSource):\n    \"\"\"\n    Loads image and metadata from TIFF or OME-TIFF files.\n    \"\"\"\n    def __init__(self, uri, metadata={}):\n        \"\"\"\n        Initialize TiffSource.\n\n        Args:\n            uri (str): Path to the TIFF file.\n            metadata (dict): Optional metadata dictionary.\n        \"\"\"\n        super().__init__(uri, metadata)\n        image_filename = None\n        ext = os.path.splitext(uri)[1].lower()\n        if 'tif' in ext:\n            image_filename = uri\n        elif 'ome' in ext:\n            # read metadata\n            with open(uri, 'rb') as file:\n                self.metadata = metadata_to_dict(file.read().decode())\n            # try to open first ome-tiff file\n            filename = ensure_list(self.metadata.get('Image', {}))[0].get('Pixels', {}).get('TiffData', {}).get('UUID', {}).get('FileName')\n            if filename:\n                image_filename = os.path.join(os.path.dirname(uri), filename)\n        else:\n            raise RuntimeError(f'Unsupported tiff extension: {ext}')\n\n        self.tiff = TiffFile(image_filename)\n\n    def init_metadata(self):\n        \"\"\"\n        Initializes and loads metadata from the (OME) TIFF file.\n\n        Returns:\n            dict: Metadata dictionary.\n        \"\"\"\n        self.is_ome = self.tiff.is_ome\n        self.is_imagej = self.tiff.is_imagej\n        pixel_size = {'x': 1, 'y': 1}\n        position = {}\n        channels = []\n        if self.is_ome:\n            metadata = metadata_to_dict(self.tiff.ome_metadata)\n            if metadata and not 'BinaryOnly' in metadata:\n                self.metadata = metadata\n            self.is_plate = 'Plate' in self.metadata\n            if self.is_plate:\n                plate = self.metadata['Plate']\n                self.name = plate.get('Name')\n                rows = set()\n                columns = set()\n                wells = {}\n                for well in plate['Well']:\n                    row = create_col_row_label(well['Row'], plate['RowNamingConvention'])\n                    column = create_col_row_label(well['Column'], plate['ColumnNamingConvention'])\n                    rows.add(row)\n                    columns.add(column)\n                    label = f'{row}{column}'\n                    wells[label] = well['ID']\n                self.rows = sorted(rows)\n                self.columns = list(columns)\n                self.wells = list(wells.keys())\n            else:\n                self.name = self.metadata['Image'].get('Name')\n            pixels = ensure_list(self.metadata.get('Image', []))[0].get('Pixels', {})\n            self.shape = pixels.get('SizeT'), pixels.get('SizeC'), pixels.get('SizeZ'), pixels.get('SizeY'), pixels.get('SizeX')\n            self.dim_order = ''.join(reversed(pixels['DimensionOrder'].lower()))\n            self.dtype = np.dtype(pixels['Type'])\n            if 'PhysicalSizeX' in pixels:\n                pixel_size['x'] = convert_to_um(float(pixels.get('PhysicalSizeX')), pixels.get('PhysicalSizeXUnit'))\n            if 'PhysicalSizeY' in pixels:\n                pixel_size['y'] = convert_to_um(float(pixels.get('PhysicalSizeY')), pixels.get('PhysicalSizeYUnit'))\n            if 'PhysicalSizeZ' in pixels:\n                pixel_size['z'] = convert_to_um(float(pixels.get('PhysicalSizeZ')), pixels.get('PhysicalSizeZUnit'))\n            plane = pixels.get('Plane')\n            if plane:\n                if 'PositionX' in plane:\n                    position['x'] = convert_to_um(float(plane.get('PositionX')), plane.get('PositionXUnit'))\n                if 'PositionY' in plane:\n                    position['y'] = convert_to_um(float(plane.get('PositionY')), plane.get('PositionYUnit'))\n                if 'PositionZ' in plane:\n                    position['z'] = convert_to_um(float(plane.get('PositionZ')), plane.get('PositionZUnit'))\n            for channel0 in ensure_list(pixels.get('Channel')):\n                channel = {}\n                if 'Name' in channel0:\n                    channel['label'] = channel0['Name']\n                if 'Color' in channel0:\n                    channel['color'] = int_to_rgba(channel0['Color'])\n                channels.append(channel)\n        else:\n            self.is_plate = False\n            if self.is_imagej:\n                self.imagej_metadata = self.tiff.imagej_metadata\n                pixel_size_unit = self.imagej_metadata.get('unit', '').encode().decode('unicode_escape')\n                if 'scales' in self.imagej_metadata:\n                    for dim, scale in zip(['x', 'y'], self.imagej_metadata['scales'].split(',')):\n                        scale = scale.strip()\n                        if scale != '':\n                            pixel_size[dim] = convert_to_um(float(scale), pixel_size_unit)\n                if 'spacing' in self.imagej_metadata:\n                    pixel_size['z'] = convert_to_um(self.imagej_metadata['spacing'], pixel_size_unit)\n            self.metadata = tags_to_dict(self.tiff.pages.first.tags)\n            self.name = os.path.splitext(self.tiff.filename)[0]\n            if self.tiff.series:\n                page = self.tiff.series[0]\n            else:\n                page = self.tiff.pages.first\n            self.shape = page.shape\n            while len(self.shape) &lt; 5:\n                self.shape = tuple([1] + list(self.shape))\n            self.dim_order = page.axes.lower().replace('s', 'c').replace('r', '')\n            self.dtype = page.dtype\n            res_unit = self.metadata.get('ResolutionUnit', '')\n            if isinstance(res_unit, Enum):\n                res_unit = res_unit.name\n            res_unit = res_unit.lower()\n            if res_unit == 'none':\n                res_unit = ''\n            if 'x' not in pixel_size:\n                res0 = convert_rational_value(self.metadata.get('XResolution'))\n                if res0 is not None and res0 != 0:\n                    pixel_size['x'] = convert_to_um(1 / res0, res_unit)\n            if 'y' not in pixel_size:\n                res0 = convert_rational_value(self.metadata.get('YResolution'))\n                if res0 is not None and res0 != 0:\n                    pixel_size['y'] = convert_to_um(1 / res0, res_unit)\n        self.pixel_size = pixel_size\n        self.position = position\n        self.channels = channels\n        return self.metadata\n\n    def is_screen(self):\n        \"\"\"\n        Checks if the source is a plate/screen.\n\n        Returns:\n            bool: True if plate/screen.\n        \"\"\"\n        return self.is_plate\n\n    def get_shape(self):\n        \"\"\"\n        Returns the shape of the image data.\n\n        Returns:\n            tuple: Shape of the image data.\n        \"\"\"\n        return self.shape\n\n    def get_data(self, well_id=None, field_id=None):\n        \"\"\"\n        Gets image data from the TIFF file.\n\n        Returns:\n            ndarray: Image data.\n        \"\"\"\n        data = self.tiff.asarray()\n        while data.ndim &lt; len(self.dim_order):\n            data = np.expand_dims(data, 0)\n        return data\n\n    def get_name(self):\n        \"\"\"\n        Gets the image or plate name.\n\n        Returns:\n            str: Name.\n        \"\"\"\n        return self.name\n\n    def get_dim_order(self):\n        \"\"\"\n        Returns the dimension order string.\n\n        Returns:\n            str: Dimension order.\n        \"\"\"\n        return self.dim_order\n\n    def get_dtype(self):\n        \"\"\"\n        Returns the numpy dtype of the image data.\n\n        Returns:\n            dtype: Numpy dtype.\n        \"\"\"\n        return self.dtype\n\n    def get_pixel_size_um(self):\n        \"\"\"\n        Returns the pixel size in micrometers.\n\n        Returns:\n            dict: Pixel size for x, y, (and z).\n        \"\"\"\n        return self.pixel_size\n\n    def get_position_um(self, well_id=None):\n        \"\"\"\n        Returns the position in micrometers.\n\n        Returns:\n            dict: Position in micrometers.\n        \"\"\"\n        return self.position\n\n    def get_channels(self):\n        \"\"\"\n        Returns channel metadata.\n\n        Returns:\n            list: List of channel dicts.\n        \"\"\"\n        return self.channels\n\n    def get_nchannels(self):\n        \"\"\"\n        Returns the number of channels.\n\n        Returns:\n            int: Number of channels.\n        \"\"\"\n        nchannels = 1\n        if 'c' in self.dim_order:\n            c_index = self.dim_order.index('c')\n            nchannels = self.tiff.pages.first.shape[c_index]\n        return nchannels\n\n    def get_rows(self):\n        \"\"\"\n        Returns the list of row identifiers.\n\n        Returns:\n            list: Row identifiers.\n        \"\"\"\n        return self.rows\n\n    def get_columns(self):\n        \"\"\"\n        Returns the list of column identifiers.\n\n        Returns:\n            list: Column identifiers.\n        \"\"\"\n        return self.columns\n\n    def get_wells(self):\n        \"\"\"\n        Returns the list of well identifiers.\n\n        Returns:\n            list: Well identifiers.\n        \"\"\"\n        return self.wells\n\n    def get_time_points(self):\n        \"\"\"\n        Returns the list of time points.\n\n        Returns:\n            list: Time point IDs.\n        \"\"\"\n        nt = 1\n        if 't' in self.dim_order:\n            t_index = self.dim_order.index('t')\n            nt = self.tiff.pages.first.shape[t_index]\n        return list(range(nt))\n\n    def get_fields(self):\n        \"\"\"\n        Returns the list of field indices.\n\n        Returns:\n            list: Field indices.\n        \"\"\"\n        return self.fields\n\n    def get_acquisitions(self):\n        \"\"\"\n        Returns acquisition metadata (empty for TIFF).\n\n        Returns:\n            list: Empty list.\n        \"\"\"\n        return []\n\n    def get_total_data_size(self):\n        \"\"\"\n        Returns the estimated total data size.\n\n        Returns:\n            int: Total data size in bytes.\n        \"\"\"\n        total_size = np.prod(self.shape)\n        if self.is_plate:\n            total_size *= len(self.get_wells()) * len(self.get_fields())\n        return total_size\n\n    def close(self):\n        \"\"\"\n        Closes the TIFF file.\n        \"\"\"\n        self.tiff.close()\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.metadata","title":"<code>metadata = metadata_to_dict(file.read().decode())</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.TiffSource.TiffSource.tiff","title":"<code>tiff = TiffFile(image_filename)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.TiffSource.TiffSource.__init__","title":"<code>__init__(uri, metadata={})</code>","text":"<p>Initialize TiffSource.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>Path to the TIFF file.</p> required <code>metadata</code> <code>dict</code> <p>Optional metadata dictionary.</p> <code>{}</code> Source code in <code>src\\TiffSource.py</code> <pre><code>def __init__(self, uri, metadata={}):\n    \"\"\"\n    Initialize TiffSource.\n\n    Args:\n        uri (str): Path to the TIFF file.\n        metadata (dict): Optional metadata dictionary.\n    \"\"\"\n    super().__init__(uri, metadata)\n    image_filename = None\n    ext = os.path.splitext(uri)[1].lower()\n    if 'tif' in ext:\n        image_filename = uri\n    elif 'ome' in ext:\n        # read metadata\n        with open(uri, 'rb') as file:\n            self.metadata = metadata_to_dict(file.read().decode())\n        # try to open first ome-tiff file\n        filename = ensure_list(self.metadata.get('Image', {}))[0].get('Pixels', {}).get('TiffData', {}).get('UUID', {}).get('FileName')\n        if filename:\n            image_filename = os.path.join(os.path.dirname(uri), filename)\n    else:\n        raise RuntimeError(f'Unsupported tiff extension: {ext}')\n\n    self.tiff = TiffFile(image_filename)\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.close","title":"<code>close()</code>","text":"<p>Closes the TIFF file.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def close(self):\n    \"\"\"\n    Closes the TIFF file.\n    \"\"\"\n    self.tiff.close()\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_acquisitions","title":"<code>get_acquisitions()</code>","text":"<p>Returns acquisition metadata (empty for TIFF).</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def get_acquisitions(self):\n    \"\"\"\n    Returns acquisition metadata (empty for TIFF).\n\n    Returns:\n        list: Empty list.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_channels","title":"<code>get_channels()</code>","text":"<p>Returns channel metadata.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of channel dicts.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def get_channels(self):\n    \"\"\"\n    Returns channel metadata.\n\n    Returns:\n        list: List of channel dicts.\n    \"\"\"\n    return self.channels\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_columns","title":"<code>get_columns()</code>","text":"<p>Returns the list of column identifiers.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Column identifiers.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def get_columns(self):\n    \"\"\"\n    Returns the list of column identifiers.\n\n    Returns:\n        list: Column identifiers.\n    \"\"\"\n    return self.columns\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_data","title":"<code>get_data(well_id=None, field_id=None)</code>","text":"<p>Gets image data from the TIFF file.</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <p>Image data.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def get_data(self, well_id=None, field_id=None):\n    \"\"\"\n    Gets image data from the TIFF file.\n\n    Returns:\n        ndarray: Image data.\n    \"\"\"\n    data = self.tiff.asarray()\n    while data.ndim &lt; len(self.dim_order):\n        data = np.expand_dims(data, 0)\n    return data\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"<p>Returns the dimension order string.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Dimension order.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def get_dim_order(self):\n    \"\"\"\n    Returns the dimension order string.\n\n    Returns:\n        str: Dimension order.\n    \"\"\"\n    return self.dim_order\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_dtype","title":"<code>get_dtype()</code>","text":"<p>Returns the numpy dtype of the image data.</p> <p>Returns:</p> Name Type Description <code>dtype</code> <p>Numpy dtype.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def get_dtype(self):\n    \"\"\"\n    Returns the numpy dtype of the image data.\n\n    Returns:\n        dtype: Numpy dtype.\n    \"\"\"\n    return self.dtype\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_fields","title":"<code>get_fields()</code>","text":"<p>Returns the list of field indices.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Field indices.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def get_fields(self):\n    \"\"\"\n    Returns the list of field indices.\n\n    Returns:\n        list: Field indices.\n    \"\"\"\n    return self.fields\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_name","title":"<code>get_name()</code>","text":"<p>Gets the image or plate name.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Name.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def get_name(self):\n    \"\"\"\n    Gets the image or plate name.\n\n    Returns:\n        str: Name.\n    \"\"\"\n    return self.name\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"<p>Returns the number of channels.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of channels.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def get_nchannels(self):\n    \"\"\"\n    Returns the number of channels.\n\n    Returns:\n        int: Number of channels.\n    \"\"\"\n    nchannels = 1\n    if 'c' in self.dim_order:\n        c_index = self.dim_order.index('c')\n        nchannels = self.tiff.pages.first.shape[c_index]\n    return nchannels\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"<p>Returns the pixel size in micrometers.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Pixel size for x, y, (and z).</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def get_pixel_size_um(self):\n    \"\"\"\n    Returns the pixel size in micrometers.\n\n    Returns:\n        dict: Pixel size for x, y, (and z).\n    \"\"\"\n    return self.pixel_size\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_position_um","title":"<code>get_position_um(well_id=None)</code>","text":"<p>Returns the position in micrometers.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Position in micrometers.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def get_position_um(self, well_id=None):\n    \"\"\"\n    Returns the position in micrometers.\n\n    Returns:\n        dict: Position in micrometers.\n    \"\"\"\n    return self.position\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_rows","title":"<code>get_rows()</code>","text":"<p>Returns the list of row identifiers.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Row identifiers.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def get_rows(self):\n    \"\"\"\n    Returns the list of row identifiers.\n\n    Returns:\n        list: Row identifiers.\n    \"\"\"\n    return self.rows\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_shape","title":"<code>get_shape()</code>","text":"<p>Returns the shape of the image data.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Shape of the image data.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def get_shape(self):\n    \"\"\"\n    Returns the shape of the image data.\n\n    Returns:\n        tuple: Shape of the image data.\n    \"\"\"\n    return self.shape\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_time_points","title":"<code>get_time_points()</code>","text":"<p>Returns the list of time points.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Time point IDs.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def get_time_points(self):\n    \"\"\"\n    Returns the list of time points.\n\n    Returns:\n        list: Time point IDs.\n    \"\"\"\n    nt = 1\n    if 't' in self.dim_order:\n        t_index = self.dim_order.index('t')\n        nt = self.tiff.pages.first.shape[t_index]\n    return list(range(nt))\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_total_data_size","title":"<code>get_total_data_size()</code>","text":"<p>Returns the estimated total data size.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Total data size in bytes.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def get_total_data_size(self):\n    \"\"\"\n    Returns the estimated total data size.\n\n    Returns:\n        int: Total data size in bytes.\n    \"\"\"\n    total_size = np.prod(self.shape)\n    if self.is_plate:\n        total_size *= len(self.get_wells()) * len(self.get_fields())\n    return total_size\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_wells","title":"<code>get_wells()</code>","text":"<p>Returns the list of well identifiers.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Well identifiers.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def get_wells(self):\n    \"\"\"\n    Returns the list of well identifiers.\n\n    Returns:\n        list: Well identifiers.\n    \"\"\"\n    return self.wells\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.init_metadata","title":"<code>init_metadata()</code>","text":"<p>Initializes and loads metadata from the (OME) TIFF file.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Metadata dictionary.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def init_metadata(self):\n    \"\"\"\n    Initializes and loads metadata from the (OME) TIFF file.\n\n    Returns:\n        dict: Metadata dictionary.\n    \"\"\"\n    self.is_ome = self.tiff.is_ome\n    self.is_imagej = self.tiff.is_imagej\n    pixel_size = {'x': 1, 'y': 1}\n    position = {}\n    channels = []\n    if self.is_ome:\n        metadata = metadata_to_dict(self.tiff.ome_metadata)\n        if metadata and not 'BinaryOnly' in metadata:\n            self.metadata = metadata\n        self.is_plate = 'Plate' in self.metadata\n        if self.is_plate:\n            plate = self.metadata['Plate']\n            self.name = plate.get('Name')\n            rows = set()\n            columns = set()\n            wells = {}\n            for well in plate['Well']:\n                row = create_col_row_label(well['Row'], plate['RowNamingConvention'])\n                column = create_col_row_label(well['Column'], plate['ColumnNamingConvention'])\n                rows.add(row)\n                columns.add(column)\n                label = f'{row}{column}'\n                wells[label] = well['ID']\n            self.rows = sorted(rows)\n            self.columns = list(columns)\n            self.wells = list(wells.keys())\n        else:\n            self.name = self.metadata['Image'].get('Name')\n        pixels = ensure_list(self.metadata.get('Image', []))[0].get('Pixels', {})\n        self.shape = pixels.get('SizeT'), pixels.get('SizeC'), pixels.get('SizeZ'), pixels.get('SizeY'), pixels.get('SizeX')\n        self.dim_order = ''.join(reversed(pixels['DimensionOrder'].lower()))\n        self.dtype = np.dtype(pixels['Type'])\n        if 'PhysicalSizeX' in pixels:\n            pixel_size['x'] = convert_to_um(float(pixels.get('PhysicalSizeX')), pixels.get('PhysicalSizeXUnit'))\n        if 'PhysicalSizeY' in pixels:\n            pixel_size['y'] = convert_to_um(float(pixels.get('PhysicalSizeY')), pixels.get('PhysicalSizeYUnit'))\n        if 'PhysicalSizeZ' in pixels:\n            pixel_size['z'] = convert_to_um(float(pixels.get('PhysicalSizeZ')), pixels.get('PhysicalSizeZUnit'))\n        plane = pixels.get('Plane')\n        if plane:\n            if 'PositionX' in plane:\n                position['x'] = convert_to_um(float(plane.get('PositionX')), plane.get('PositionXUnit'))\n            if 'PositionY' in plane:\n                position['y'] = convert_to_um(float(plane.get('PositionY')), plane.get('PositionYUnit'))\n            if 'PositionZ' in plane:\n                position['z'] = convert_to_um(float(plane.get('PositionZ')), plane.get('PositionZUnit'))\n        for channel0 in ensure_list(pixels.get('Channel')):\n            channel = {}\n            if 'Name' in channel0:\n                channel['label'] = channel0['Name']\n            if 'Color' in channel0:\n                channel['color'] = int_to_rgba(channel0['Color'])\n            channels.append(channel)\n    else:\n        self.is_plate = False\n        if self.is_imagej:\n            self.imagej_metadata = self.tiff.imagej_metadata\n            pixel_size_unit = self.imagej_metadata.get('unit', '').encode().decode('unicode_escape')\n            if 'scales' in self.imagej_metadata:\n                for dim, scale in zip(['x', 'y'], self.imagej_metadata['scales'].split(',')):\n                    scale = scale.strip()\n                    if scale != '':\n                        pixel_size[dim] = convert_to_um(float(scale), pixel_size_unit)\n            if 'spacing' in self.imagej_metadata:\n                pixel_size['z'] = convert_to_um(self.imagej_metadata['spacing'], pixel_size_unit)\n        self.metadata = tags_to_dict(self.tiff.pages.first.tags)\n        self.name = os.path.splitext(self.tiff.filename)[0]\n        if self.tiff.series:\n            page = self.tiff.series[0]\n        else:\n            page = self.tiff.pages.first\n        self.shape = page.shape\n        while len(self.shape) &lt; 5:\n            self.shape = tuple([1] + list(self.shape))\n        self.dim_order = page.axes.lower().replace('s', 'c').replace('r', '')\n        self.dtype = page.dtype\n        res_unit = self.metadata.get('ResolutionUnit', '')\n        if isinstance(res_unit, Enum):\n            res_unit = res_unit.name\n        res_unit = res_unit.lower()\n        if res_unit == 'none':\n            res_unit = ''\n        if 'x' not in pixel_size:\n            res0 = convert_rational_value(self.metadata.get('XResolution'))\n            if res0 is not None and res0 != 0:\n                pixel_size['x'] = convert_to_um(1 / res0, res_unit)\n        if 'y' not in pixel_size:\n            res0 = convert_rational_value(self.metadata.get('YResolution'))\n            if res0 is not None and res0 != 0:\n                pixel_size['y'] = convert_to_um(1 / res0, res_unit)\n    self.pixel_size = pixel_size\n    self.position = position\n    self.channels = channels\n    return self.metadata\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.is_screen","title":"<code>is_screen()</code>","text":"<p>Checks if the source is a plate/screen.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if plate/screen.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def is_screen(self):\n    \"\"\"\n    Checks if the source is a plate/screen.\n\n    Returns:\n        bool: True if plate/screen.\n    \"\"\"\n    return self.is_plate\n</code></pre>"},{"location":"references/#src.TiffSource.convert_rational_value","title":"<code>convert_rational_value(value)</code>","text":"<p>Converts a rational value tuple to a float.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple or None</code> <p>Rational value.</p> required <p>Returns:</p> Type Description <p>float or None: Converted value.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def convert_rational_value(value):\n    \"\"\"\n    Converts a rational value tuple to a float.\n\n    Args:\n        value (tuple or None): Rational value.\n\n    Returns:\n        float or None: Converted value.\n    \"\"\"\n    if value is not None and isinstance(value, tuple):\n        if value[0] == value[1]:\n            value = value[0]\n        else:\n            value = value[0] / value[1]\n    return value\n</code></pre>"},{"location":"references/#src.TiffSource.tags_to_dict","title":"<code>tags_to_dict(tags)</code>","text":"<p>Converts TIFF tags to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>tags</code> <p>TIFF tags object.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Tag name-value mapping.</p> Source code in <code>src\\TiffSource.py</code> <pre><code>def tags_to_dict(tags):\n    \"\"\"\n    Converts TIFF tags to a dictionary.\n\n    Args:\n        tags: TIFF tags object.\n\n    Returns:\n        dict: Tag name-value mapping.\n    \"\"\"\n    tag_dict = {}\n    for tag in tags.values():\n        tag_dict[tag.name] = tag.value\n    return tag_dict\n</code></pre>"},{"location":"references/#src.Timer","title":"<code>Timer</code>","text":""},{"location":"references/#src.Timer.Timer","title":"<code>Timer</code>","text":"<p>               Bases: <code>object</code></p> <p>Context manager for timing code execution and logging the elapsed time.</p> Source code in <code>src\\Timer.py</code> <pre><code>class Timer(object):\n    \"\"\"\n    Context manager for timing code execution and logging the elapsed time.\n    \"\"\"\n\n    def __init__(self, title, auto_unit=True, verbose=True):\n        \"\"\"\n        Initialize the Timer.\n\n        Args:\n            title (str): Description for the timed block.\n            auto_unit (bool): Automatically select time unit (seconds/minutes/hours).\n            verbose (bool): If True, log the elapsed time.\n        \"\"\"\n        self.title = title\n        self.auto_unit = auto_unit\n        self.verbose = verbose\n\n    def __enter__(self):\n        \"\"\"\n        Start timing.\n        \"\"\"\n        self.ptime_start = time.process_time()\n        self.time_start = time.time()\n\n    def __exit__(self, type, value, traceback):\n        \"\"\"\n        Stop timing and log the elapsed time.\n\n        Args:\n            type: Exception type, if any.\n            value: Exception value, if any.\n            traceback: Exception traceback, if any.\n        \"\"\"\n        if self.verbose:\n            ptime_end = time.process_time()\n            time_end = time.time()\n            pelapsed = ptime_end - self.ptime_start\n            elapsed = time_end - self.time_start\n            unit = 'seconds'\n            if self.auto_unit and elapsed &gt;= 60:\n                pelapsed /= 60\n                elapsed /= 60\n                unit = 'minutes'\n                if elapsed &gt;= 60:\n                    pelapsed /= 60\n                    elapsed /= 60\n                    unit = 'hours'\n            logging.info(f'Time {self.title}: {elapsed:.1f} ({pelapsed:.1f}) {unit}')\n</code></pre>"},{"location":"references/#src.Timer.Timer.auto_unit","title":"<code>auto_unit = auto_unit</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.Timer.Timer.title","title":"<code>title = title</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.Timer.Timer.verbose","title":"<code>verbose = verbose</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.Timer.Timer.__enter__","title":"<code>__enter__()</code>","text":"<p>Start timing.</p> Source code in <code>src\\Timer.py</code> <pre><code>def __enter__(self):\n    \"\"\"\n    Start timing.\n    \"\"\"\n    self.ptime_start = time.process_time()\n    self.time_start = time.time()\n</code></pre>"},{"location":"references/#src.Timer.Timer.__exit__","title":"<code>__exit__(type, value, traceback)</code>","text":"<p>Stop timing and log the elapsed time.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <p>Exception type, if any.</p> required <code>value</code> <p>Exception value, if any.</p> required <code>traceback</code> <p>Exception traceback, if any.</p> required Source code in <code>src\\Timer.py</code> <pre><code>def __exit__(self, type, value, traceback):\n    \"\"\"\n    Stop timing and log the elapsed time.\n\n    Args:\n        type: Exception type, if any.\n        value: Exception value, if any.\n        traceback: Exception traceback, if any.\n    \"\"\"\n    if self.verbose:\n        ptime_end = time.process_time()\n        time_end = time.time()\n        pelapsed = ptime_end - self.ptime_start\n        elapsed = time_end - self.time_start\n        unit = 'seconds'\n        if self.auto_unit and elapsed &gt;= 60:\n            pelapsed /= 60\n            elapsed /= 60\n            unit = 'minutes'\n            if elapsed &gt;= 60:\n                pelapsed /= 60\n                elapsed /= 60\n                unit = 'hours'\n        logging.info(f'Time {self.title}: {elapsed:.1f} ({pelapsed:.1f}) {unit}')\n</code></pre>"},{"location":"references/#src.Timer.Timer.__init__","title":"<code>__init__(title, auto_unit=True, verbose=True)</code>","text":"<p>Initialize the Timer.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Description for the timed block.</p> required <code>auto_unit</code> <code>bool</code> <p>Automatically select time unit (seconds/minutes/hours).</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>If True, log the elapsed time.</p> <code>True</code> Source code in <code>src\\Timer.py</code> <pre><code>def __init__(self, title, auto_unit=True, verbose=True):\n    \"\"\"\n    Initialize the Timer.\n\n    Args:\n        title (str): Description for the timed block.\n        auto_unit (bool): Automatically select time unit (seconds/minutes/hours).\n        verbose (bool): If True, log the elapsed time.\n    \"\"\"\n    self.title = title\n    self.auto_unit = auto_unit\n    self.verbose = verbose\n</code></pre>"},{"location":"references/#src.WindowScanner","title":"<code>WindowScanner</code>","text":""},{"location":"references/#src.WindowScanner.WindowScanner","title":"<code>WindowScanner</code>","text":"<p>Computes quantile-based min/max window for image channels.</p> Source code in <code>src\\WindowScanner.py</code> <pre><code>class WindowScanner:\n    \"\"\"\n    Computes quantile-based min/max window for image channels.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize WindowScanner.\n        \"\"\"\n        self.min = {}\n        self.max = {}\n\n    def process(self, data, dim_order, min_quantile=0.01, max_quantile=0.99):\n        \"\"\"\n        Processes image data to compute min/max quantiles for each channel.\n\n        Args:\n            data (ndarray): Image data.\n            dim_order (str): Dimension order string.\n            min_quantile (float): Lower quantile.\n            max_quantile (float): Upper quantile.\n        \"\"\"\n        if 'c' in dim_order:\n            nc = data.shape[dim_order.index('c')]\n        else:\n            nc = 1\n        for channeli in range(nc):\n            if 'c' in dim_order:\n                channel_data = data.take(channeli, axis=dim_order.index('c'))\n            else:\n                channel_data = data\n            min1, max1 = np.quantile(channel_data, q=[min_quantile, max_quantile])\n            if data.dtype.kind in ['u', 'i']:\n                min1, max1 = int(min1), int(max1)\n            if channeli not in self.min:\n                self.min[channeli] = min1\n            else:\n                self.min[channeli] = min(min1, self.min[channeli])\n            if channeli not in self.max:\n                self.max[channeli] = max1\n            else:\n                self.max[channeli] = max(max1, self.max[channeli])\n\n    def get_window(self):\n        \"\"\"\n        Returns the computed min/max window for channels.\n\n        Returns:\n            tuple: (min dict, max dict)\n        \"\"\"\n        return self.min, self.max\n</code></pre>"},{"location":"references/#src.WindowScanner.WindowScanner.max","title":"<code>max = {}</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.WindowScanner.WindowScanner.min","title":"<code>min = {}</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.WindowScanner.WindowScanner.__init__","title":"<code>__init__()</code>","text":"<p>Initialize WindowScanner.</p> Source code in <code>src\\WindowScanner.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize WindowScanner.\n    \"\"\"\n    self.min = {}\n    self.max = {}\n</code></pre>"},{"location":"references/#src.WindowScanner.WindowScanner.get_window","title":"<code>get_window()</code>","text":"<p>Returns the computed min/max window for channels.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(min dict, max dict)</p> Source code in <code>src\\WindowScanner.py</code> <pre><code>def get_window(self):\n    \"\"\"\n    Returns the computed min/max window for channels.\n\n    Returns:\n        tuple: (min dict, max dict)\n    \"\"\"\n    return self.min, self.max\n</code></pre>"},{"location":"references/#src.WindowScanner.WindowScanner.process","title":"<code>process(data, dim_order, min_quantile=0.01, max_quantile=0.99)</code>","text":"<p>Processes image data to compute min/max quantiles for each channel.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Image data.</p> required <code>dim_order</code> <code>str</code> <p>Dimension order string.</p> required <code>min_quantile</code> <code>float</code> <p>Lower quantile.</p> <code>0.01</code> <code>max_quantile</code> <code>float</code> <p>Upper quantile.</p> <code>0.99</code> Source code in <code>src\\WindowScanner.py</code> <pre><code>def process(self, data, dim_order, min_quantile=0.01, max_quantile=0.99):\n    \"\"\"\n    Processes image data to compute min/max quantiles for each channel.\n\n    Args:\n        data (ndarray): Image data.\n        dim_order (str): Dimension order string.\n        min_quantile (float): Lower quantile.\n        max_quantile (float): Upper quantile.\n    \"\"\"\n    if 'c' in dim_order:\n        nc = data.shape[dim_order.index('c')]\n    else:\n        nc = 1\n    for channeli in range(nc):\n        if 'c' in dim_order:\n            channel_data = data.take(channeli, axis=dim_order.index('c'))\n        else:\n            channel_data = data\n        min1, max1 = np.quantile(channel_data, q=[min_quantile, max_quantile])\n        if data.dtype.kind in ['u', 'i']:\n            min1, max1 = int(min1), int(max1)\n        if channeli not in self.min:\n            self.min[channeli] = min1\n        else:\n            self.min[channeli] = min(min1, self.min[channeli])\n        if channeli not in self.max:\n            self.max[channeli] = max1\n        else:\n            self.max[channeli] = max(max1, self.max[channeli])\n</code></pre>"},{"location":"references/#src.color_conversion","title":"<code>color_conversion</code>","text":""},{"location":"references/#src.color_conversion.hexrgb_to_rgba","title":"<code>hexrgb_to_rgba(hexrgb)</code>","text":"Source code in <code>src\\color_conversion.py</code> <pre><code>def hexrgb_to_rgba(hexrgb: str) -&gt; list:\n    hexrgb = hexrgb.lstrip('#')\n    if len(hexrgb) == 6:\n        hexrgb += 'FF'  # add alpha\n    rgba = int_to_rgba(eval('0x' + hexrgb))\n    return rgba\n</code></pre>"},{"location":"references/#src.color_conversion.int_to_rgba","title":"<code>int_to_rgba(intrgba)</code>","text":"Source code in <code>src\\color_conversion.py</code> <pre><code>def int_to_rgba(intrgba: int) -&gt; list:\n    signed = (intrgba &lt; 0)\n    rgba = [x / 255 for x in intrgba.to_bytes(4, signed=signed, byteorder=\"big\")]\n    if rgba[-1] == 0:\n        rgba[-1] = 1\n    return rgba\n</code></pre>"},{"location":"references/#src.color_conversion.rgba_to_hexrgb","title":"<code>rgba_to_hexrgb(rgba)</code>","text":"Source code in <code>src\\color_conversion.py</code> <pre><code>def rgba_to_hexrgb(rgba: list) -&gt; str:\n    hexrgb = ''.join([hex(int(x * 255))[2:].upper().zfill(2) for x in rgba[:3]])\n    return hexrgb\n</code></pre>"},{"location":"references/#src.color_conversion.rgba_to_int","title":"<code>rgba_to_int(rgba)</code>","text":"Source code in <code>src\\color_conversion.py</code> <pre><code>def rgba_to_int(rgba: list) -&gt; int:\n    intrgba = int.from_bytes([int(x * 255) for x in rgba], signed=True, byteorder=\"big\")\n    return intrgba\n</code></pre>"},{"location":"references/#src.helper","title":"<code>helper</code>","text":""},{"location":"references/#src.helper.create_source","title":"<code>create_source(filename)</code>","text":"<p>Create an image source object based on the input file extension.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the input file.</p> required <p>Returns:</p> Name Type Description <code>ImageSource</code> <p>Source object for the input file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file format is unsupported.</p> Source code in <code>src\\helper.py</code> <pre><code>def create_source(filename):\n    \"\"\"\n    Create an image source object based on the input file extension.\n\n    Args:\n        filename (str): Path to the input file.\n\n    Returns:\n        ImageSource: Source object for the input file.\n\n    Raises:\n        ValueError: If the file format is unsupported.\n    \"\"\"\n    input_ext = os.path.splitext(filename)[1].lower()\n\n    if input_ext == '.db':\n        from src.ImageDbSource import ImageDbSource\n        source = ImageDbSource(filename)\n    elif input_ext == '.isyntax':\n        from src.ISyntaxSource import ISyntaxSource\n        source = ISyntaxSource(filename)\n    elif 'tif' in input_ext:\n        from src.TiffSource import TiffSource\n        source = TiffSource(filename)\n    else:\n        raise ValueError(f'Unsupported input file format: {input_ext}')\n    return source\n</code></pre>"},{"location":"references/#src.helper.create_writer","title":"<code>create_writer(output_format, verbose=False)</code>","text":"<p>Create a writer object and output extension based on the output format.</p> <p>Parameters:</p> Name Type Description Default <code>output_format</code> <code>str</code> <p>Output format string.</p> required <code>verbose</code> <code>bool</code> <p>If True, enables verbose output.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(writer object, output file extension)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the output format is unsupported.</p> Source code in <code>src\\helper.py</code> <pre><code>def create_writer(output_format, verbose=False):\n    \"\"\"\n    Create a writer object and output extension based on the output format.\n\n    Args:\n        output_format (str): Output format string.\n        verbose (bool): If True, enables verbose output.\n\n    Returns:\n        tuple: (writer object, output file extension)\n\n    Raises:\n        ValueError: If the output format is unsupported.\n    \"\"\"\n    if 'zar' in output_format:\n        if '3' in output_format:\n            zarr_version = 3\n            ome_version = '0.5'\n        else:\n            zarr_version = 2\n            ome_version = '0.4'\n        from src.OmeZarrWriter import OmeZarrWriter\n        writer = OmeZarrWriter(zarr_version=zarr_version, ome_version=ome_version, verbose=verbose)\n        ext = '.ome.zarr'\n    elif 'tif' in output_format:\n        from src.OmeTiffWriter import OmeTiffWriter\n        writer = OmeTiffWriter(verbose=verbose)\n        ext = '.ome.tiff'\n    else:\n        raise ValueError(f'Unsupported output format: {output_format}')\n    return writer, ext\n</code></pre>"},{"location":"references/#src.ome_tiff_util","title":"<code>ome_tiff_util</code>","text":""},{"location":"references/#src.ome_tiff_util.create_binaryonly_metadata","title":"<code>create_binaryonly_metadata(metadata_filename, companion_uuid)</code>","text":"Source code in <code>src\\ome_tiff_util.py</code> <pre><code>def create_binaryonly_metadata(metadata_filename, companion_uuid):\n    ome = OME()\n    ome.uuid = create_uuid()\n    ome.creator = f'nl.biomero.OmeTiffWriter {VERSION}'\n    ome.binary_only = OME.BinaryOnly(metadata_file=metadata_filename, uuid=companion_uuid)\n    return to_xml(ome), ome.uuid\n</code></pre>"},{"location":"references/#src.ome_tiff_util.create_col_row_label","title":"<code>create_col_row_label(index, naming_convention)</code>","text":"Source code in <code>src\\ome_tiff_util.py</code> <pre><code>def create_col_row_label(index, naming_convention):\n    label = index + 1\n    if naming_convention.lower() == NamingConvention.LETTER.name.lower():\n        label = chr(ord('A') + index)\n    return str(label)\n</code></pre>"},{"location":"references/#src.ome_tiff_util.create_image_metadata","title":"<code>create_image_metadata(source, image_uuid=None, image_filename=None)</code>","text":"Source code in <code>src\\ome_tiff_util.py</code> <pre><code>def create_image_metadata(source, image_uuid=None, image_filename=None):\n    t, c, z, y, x = source.get_shape()\n    pixel_size = source.get_pixel_size_um()\n    ome_channels = []\n    for channeli, channel in enumerate(source.get_channels()):\n        ome_channel = Channel()\n        ome_channel.name = channel.get('label', channel.get('Name', f'{channeli}'))\n        ome_channel.samples_per_pixel = 1\n        color = channel.get('color', channel.get('Color'))\n        if color is not None:\n            ome_channel.color = Color(rgba_to_int(color))\n        ome_channels.append(ome_channel)\n\n    tiff_data = TiffData()\n    tiff_data.uuid = TiffData.UUID(value=image_uuid, file_name=image_filename)\n\n    pixels = Pixels(\n        dimension_order=source.get_dim_order()[::-1].upper(),\n        type=PixelType(str(source.get_dtype())),\n        channels=ome_channels,\n        size_t=t, size_c=c, size_z=z, size_y=y, size_x=x,\n        tiff_data_blocks=[tiff_data]\n    )\n    if 'x' in pixel_size:\n        pixels.physical_size_x = pixel_size['x']\n        pixels.physical_size_x_unit = UnitsLength.MICROMETER\n    if 'y' in pixel_size:\n        pixels.physical_size_y = pixel_size['y']\n        pixels.physical_size_y_unit = UnitsLength.MICROMETER\n    if 'z' in pixel_size:\n        pixels.physical_size_z = pixel_size['z']\n        pixels.physical_size_z_unit = UnitsLength.MICROMETER\n\n    image = Image(pixels=pixels)\n    index = pixels.id.split(':')[1]\n    for channeli, channel in enumerate(pixels.channels):\n        channel.id = f'Channel:{index}:{channeli}'\n    return image\n</code></pre>"},{"location":"references/#src.ome_tiff_util.create_metadata","title":"<code>create_metadata(source, companion_uuid=None, image_uuids=None, image_filenames=None)</code>","text":"Source code in <code>src\\ome_tiff_util.py</code> <pre><code>def create_metadata(source, companion_uuid=None, image_uuids=None, image_filenames=None):\n    ome = OME()\n    ome.uuid = companion_uuid\n    ome.creator = f'nl.biomero.OmeTiffWriter {VERSION}'\n\n    if source.is_screen:\n        columns = source.get_columns()\n        rows = source.get_rows()\n\n        plate = Plate()\n        plate.columns = len(columns)\n        plate.rows = len(rows)\n        plate.row_naming_convention = get_col_row_type(rows)\n        plate.column_naming_convention = get_col_row_type(columns)\n\n        image_index = 0\n        for well_id in source.get_wells():\n            row, col = split_well_name(well_id)\n            col_index = columns.index(col)\n            row_index = rows.index(row)\n            well = Well(column=col_index, row=row_index)\n            well.id = f'Well:{well_id}'\n            for field in source.get_fields():\n                sample = WellSample(index=image_index)\n                sample.id = f'WellSample:{well_id}:{field}'\n                position = source.get_position_um(well_id)\n                if 'x' in position:\n                    sample.position_x = position['x']\n                    sample.position_x_unit = UnitsLength.MICROMETER\n                if 'y' in position:\n                    sample.position_y = position['y']\n                    sample.position_y_unit = UnitsLength.MICROMETER\n\n                image = create_image_metadata(source,\n                                              image_uuids[image_index],\n                                              image_filenames[image_index])\n                ome.images.append(image)\n\n                image_ref = ImageRef(id=image.id)   # assign id at instantiation to avoid auto sequence increment\n                sample.image_ref = image_ref\n                well.well_samples.append(sample)\n\n                image_index += 1\n\n            plate.wells.append(well)\n\n        ome.plates = [plate]\n    else:\n        ome.images = [create_image_metadata(source, ome.uuid, source.get_name())]\n\n    return to_xml(ome)\n</code></pre>"},{"location":"references/#src.ome_tiff_util.create_resolution_metadata","title":"<code>create_resolution_metadata(source)</code>","text":"Source code in <code>src\\ome_tiff_util.py</code> <pre><code>def create_resolution_metadata(source):\n    pixel_size_um = source.get_pixel_size_um()\n    resolution_unit = 'CENTIMETER'\n    resolution = [1e4 / pixel_size_um[dim] for dim in 'xy']\n    return resolution, resolution_unit\n</code></pre>"},{"location":"references/#src.ome_tiff_util.create_uuid","title":"<code>create_uuid()</code>","text":"Source code in <code>src\\ome_tiff_util.py</code> <pre><code>def create_uuid():\n    return f'urn:uuid:{uuid.uuid4()}'\n</code></pre>"},{"location":"references/#src.ome_tiff_util.get_col_row_type","title":"<code>get_col_row_type(labels)</code>","text":"Source code in <code>src\\ome_tiff_util.py</code> <pre><code>def get_col_row_type(labels):\n    is_digits = [label.isdigit() for label in labels]\n    if np.all(is_digits):\n        naming_convention = NamingConvention.NUMBER\n    else:\n        naming_convention = NamingConvention.LETTER\n    return naming_convention\n</code></pre>"},{"location":"references/#src.ome_tiff_util.metadata_to_dict","title":"<code>metadata_to_dict(xml_metadata)</code>","text":"Source code in <code>src\\ome_tiff_util.py</code> <pre><code>def metadata_to_dict(xml_metadata):\n    metadata = xml2dict(xml_metadata)\n    if 'OME' in metadata:\n        metadata = metadata['OME']\n    return metadata\n</code></pre>"},{"location":"references/#src.ome_zarr_util","title":"<code>ome_zarr_util</code>","text":""},{"location":"references/#src.ome_zarr_util.create_axes_metadata","title":"<code>create_axes_metadata(dimension_order)</code>","text":"<p>Create axes metadata for OME-Zarr from dimension order.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of axis metadata dictionaries.</p> Source code in <code>src\\ome_zarr_util.py</code> <pre><code>def create_axes_metadata(dimension_order):\n    \"\"\"\n    Create axes metadata for OME-Zarr from dimension order.\n\n    Args:\n        dimension_order (str): String of dimension characters.\n\n    Returns:\n        list: List of axis metadata dictionaries.\n    \"\"\"\n    axes = []\n    for dimension in dimension_order:\n        unit1 = None\n        if dimension == 't':\n            type1 = 'time'\n            unit1 = 'millisecond'\n        elif dimension == 'c':\n            type1 = 'channel'\n        else:\n            type1 = 'space'\n            unit1 = 'micrometer'\n        axis = {'name': dimension, 'type': type1}\n        if unit1 is not None and unit1 != '':\n            axis['unit'] = unit1\n        axes.append(axis)\n    return axes\n</code></pre>"},{"location":"references/#src.ome_zarr_util.create_channel_metadata","title":"<code>create_channel_metadata(dtype, channels, nchannels, window, ome_version)</code>","text":"<p>Create channel metadata for OME-Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <p>Numpy dtype of image data.</p> required <code>channels</code> <code>list</code> <p>List of channel dicts.</p> required <code>nchannels</code> <code>int</code> <p>Number of channels.</p> required <code>window</code> <code>tuple</code> <p>Min/max window values.</p> required <code>ome_version</code> <code>str</code> <p>OME-Zarr version.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Channel metadata dictionary.</p> Source code in <code>src\\ome_zarr_util.py</code> <pre><code>def create_channel_metadata(dtype, channels, nchannels, window, ome_version):\n    \"\"\"\n    Create channel metadata for OME-Zarr.\n\n    Args:\n        dtype: Numpy dtype of image data.\n        channels (list): List of channel dicts.\n        nchannels (int): Number of channels.\n        window (tuple): Min/max window values.\n        ome_version (str): OME-Zarr version.\n\n    Returns:\n        dict: Channel metadata dictionary.\n    \"\"\"\n    if len(channels) &lt; nchannels:\n        labels = []\n        colors = []\n        if nchannels in (3, 4):\n            labels = ['Red', 'Green', 'Blue']\n            colors = [\"FF0000\", \"00FF00\", \"0000FF\"]\n        if nchannels == 4:\n            labels += ['Alpha']\n            colors += [\"FFFFFF\"]\n        channels = [{'label': label, 'color': color} for label, color in zip(labels, colors)]\n\n    omezarr_channels = []\n    start, end = window\n    for channeli, channel in enumerate(channels):\n        omezarr_channel = {'label': channel.get('label', channel.get('Name', f'{channeli}')), 'active': True}\n        color = channel.get('color', channel.get('Color'))\n        if color is not None:\n            omezarr_channel['color'] = rgba_to_hexrgb(color)\n        if dtype.kind == 'f':\n            min, max = 0, 1\n        else:\n            info = np.iinfo(dtype)\n            min, max = info.min, info.max\n        omezarr_channel['window'] = {'min': min, 'max': max, 'start': start[channeli], 'end': end[channeli]}\n        omezarr_channels.append(omezarr_channel)\n\n    metadata = {\n        'version': ome_version,\n        'channels': omezarr_channels,\n    }\n    return metadata\n</code></pre>"},{"location":"references/#src.ome_zarr_util.create_transformation_metadata","title":"<code>create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um={})</code>","text":"<p>Create transformation metadata (scale and translation) for OME-Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <code>pixel_size_um</code> <code>dict</code> <p>Pixel size in micrometers per dimension.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <code>translation_um</code> <code>dict</code> <p>Translation in micrometers per dimension.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>list</code> <p>List of transformation metadata dictionaries.</p> Source code in <code>src\\ome_zarr_util.py</code> <pre><code>def create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um={}):\n    \"\"\"\n    Create transformation metadata (scale and translation) for OME-Zarr.\n\n    Args:\n        dimension_order (str): String of dimension characters.\n        pixel_size_um (dict): Pixel size in micrometers per dimension.\n        scale (float): Scaling factor.\n        translation_um (dict, optional): Translation in micrometers per dimension.\n\n    Returns:\n        list: List of transformation metadata dictionaries.\n    \"\"\"\n    metadata = []\n    pixel_size_scale = []\n    translation_scale = []\n    for dimension in dimension_order:\n        pixel_size_scale1 = pixel_size_um.get(dimension, 1)\n        if pixel_size_scale1 == 0:\n            pixel_size_scale1 = 1\n        if dimension in ['x', 'y']:\n            pixel_size_scale1 /= scale\n        pixel_size_scale.append(pixel_size_scale1)\n\n        translation1 = translation_um.get(dimension, 0)\n        if dimension in ['x', 'y']:\n            translation1 *= scale\n        translation_scale.append(translation1)\n\n    metadata.append({'type': 'scale', 'scale': pixel_size_scale})\n    if not all(v == 0 for v in translation_scale):\n        metadata.append({'type': 'translation', 'translation': translation_scale})\n    return metadata\n</code></pre>"},{"location":"references/#src.ome_zarr_util.scale_dimensions_dict","title":"<code>scale_dimensions_dict(shape0, scale)</code>","text":"<p>Scale x and y dimensions in a shape dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>shape0</code> <code>dict</code> <p>Original shape dictionary.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Scaled shape dictionary.</p> Source code in <code>src\\ome_zarr_util.py</code> <pre><code>def scale_dimensions_dict(shape0, scale):\n    \"\"\"\n    Scale x and y dimensions in a shape dictionary.\n\n    Args:\n        shape0 (dict): Original shape dictionary.\n        scale (float): Scaling factor.\n\n    Returns:\n        dict: Scaled shape dictionary.\n    \"\"\"\n    shape = {}\n    if scale == 1:\n        return shape0\n    for dimension, shape1 in shape0.items():\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape[dimension] = shape1\n    return shape\n</code></pre>"},{"location":"references/#src.ome_zarr_util.scale_dimensions_xy","title":"<code>scale_dimensions_xy(shape0, dimension_order, scale)</code>","text":"<p>Scale x and y dimensions in a shape tuple.</p> <p>Parameters:</p> Name Type Description Default <code>shape0</code> <code>tuple</code> <p>Original shape.</p> required <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Scaled shape.</p> Source code in <code>src\\ome_zarr_util.py</code> <pre><code>def scale_dimensions_xy(shape0, dimension_order, scale):\n    \"\"\"\n    Scale x and y dimensions in a shape tuple.\n\n    Args:\n        shape0 (tuple): Original shape.\n        dimension_order (str): String of dimension characters.\n        scale (float): Scaling factor.\n\n    Returns:\n        list: Scaled shape.\n    \"\"\"\n    shape = []\n    if scale == 1:\n        return shape0\n    for shape1, dimension in zip(shape0, dimension_order):\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape.append(shape1)\n    return shape\n</code></pre>"},{"location":"references/#src.parameters","title":"<code>parameters</code>","text":""},{"location":"references/#src.parameters.VERSION","title":"<code>VERSION = '0.0.15'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.util","title":"<code>util</code>","text":""},{"location":"references/#src.util.convert_dotnet_ticks_to_datetime","title":"<code>convert_dotnet_ticks_to_datetime(net_ticks)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def convert_dotnet_ticks_to_datetime(net_ticks):\n    return datetime(1, 1, 1) + timedelta(microseconds=net_ticks // 10)\n</code></pre>"},{"location":"references/#src.util.convert_to_um","title":"<code>convert_to_um(value, unit)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def convert_to_um(value, unit):\n    conversions = {\n        'nm': 1e-3,\n        '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'micron': 1,\n        'mm': 1e3, 'millimeter': 1e3,\n        'cm': 1e4, 'centimeter': 1e4,\n        'm': 1e6, 'meter': 1e6\n    }\n    return value * conversions.get(unit, 1)\n</code></pre>"},{"location":"references/#src.util.ensure_list","title":"<code>ensure_list(item)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def ensure_list(item):\n    if not isinstance(item, (list, tuple)):\n        item = [item]\n    return item\n</code></pre>"},{"location":"references/#src.util.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def get_filetitle(filename):\n    return os.path.basename(os.path.splitext(filename)[0])\n</code></pre>"},{"location":"references/#src.util.pad_leading_zero","title":"<code>pad_leading_zero(input_string, num_digits=2)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def pad_leading_zero(input_string, num_digits=2):\n    output = str(input_string)\n    is_well = not output[0].isdigit()\n    if is_well:\n        row, col = split_well_name(output, remove_leading_zeros=True)\n        output = str(col)\n    while len(output) &lt; num_digits:\n        output = '0' + output\n    if is_well:\n        output = row + output\n    return output\n</code></pre>"},{"location":"references/#src.util.print_dict","title":"<code>print_dict(value, tab=0, max_len=250, bullet=False)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def print_dict(value, tab=0, max_len=250, bullet=False):\n    s = ''\n    if isinstance(value, dict):\n        for key, subvalue in value.items():\n            s += '\\n'\n            if bullet:\n                s += '-'\n                bullet = False\n            s += '\\t' * tab + str(key) + ': '\n            if isinstance(subvalue, dict):\n                s += print_dict(subvalue, tab+1)\n            elif isinstance(subvalue, list):\n                for v in subvalue:\n                    s += print_dict(v, tab+1, bullet=True)\n            else:\n                subvalue = str(subvalue)\n                if len(subvalue) &gt; max_len:\n                    subvalue = subvalue[:max_len] + '...'\n                s += subvalue\n    else:\n        s += str(value) + ' '\n    return s\n</code></pre>"},{"location":"references/#src.util.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def print_hbytes(nbytes):\n    exps = ['', 'K', 'M', 'G', 'T', 'P', 'E']\n    div = 1024\n    exp = 0\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    if exp &lt; len(exps):\n        e = exps[exp]\n    else:\n        e = f'e{exp * 3}'\n    return f'{nbytes:.1f}{e}B'\n</code></pre>"},{"location":"references/#src.util.split_well_name","title":"<code>split_well_name(well_name, remove_leading_zeros=True, col_as_int=False)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def split_well_name(well_name, remove_leading_zeros=True, col_as_int=False):\n    matches = re.findall(r'(\\D+)(\\d+)', well_name)\n    if len(matches) &gt; 0:\n        row, col = matches[0]\n        if col_as_int or remove_leading_zeros:\n            try:\n                col = int(col)\n            except ValueError:\n                pass\n        if not col_as_int:\n            col = str(col)\n        return row, col\n    else:\n        raise ValueError(f\"Invalid well name format: {well_name}. Expected format like 'A1', 'B2', etc.\")\n</code></pre>"},{"location":"references/#src.util.splitall","title":"<code>splitall(path)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def splitall(path):\n    allparts = []\n    while True:\n        parts = os.path.split(path)\n        if parts[0] == path:  # sentinel for absolute paths\n            allparts.insert(0, parts[0])\n            break\n        elif parts[1] == path: # sentinel for relative paths\n            allparts.insert(0, parts[1])\n            break\n        else:\n            path = parts[0]\n            allparts.insert(0, parts[1])\n    return allparts\n</code></pre>"},{"location":"references/#src.util.strip_leading_zeros","title":"<code>strip_leading_zeros(well_name)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def strip_leading_zeros(well_name):\n    row, col = split_well_name(well_name, remove_leading_zeros=True)\n    return f'{row}{col}'\n</code></pre>"},{"location":"references/#src.util.xml_content_to_dict","title":"<code>xml_content_to_dict(element)</code>","text":"Source code in <code>src\\util.py</code> <pre><code>def xml_content_to_dict(element):\n    key = element.tag\n    children = list(element)\n    if key == 'Array':\n        res = [xml_content_to_dict(child) for child in children]\n        return res\n    if len(children) &gt; 0:\n        if children[0].tag == 'Array':\n            value = []\n        else:\n            value = {}\n        for child in children:\n            child_value = xml_content_to_dict(child)\n            if isinstance(child_value, list):\n                value.extend(child_value)\n            else:\n                value |= child_value\n    else:\n        value = element.text\n        if value is not None:\n            if '\"' in value:\n                value = value.replace('\"', '')\n            else:\n                for t in (float, int, bool):\n                    try:\n                        if t == bool:\n                            if value.lower() == 'true':\n                                value = True\n                            if value.lower() == 'false':\n                                value = False\n                        else:\n                            value = t(value)\n                        break\n                    except (TypeError, ValueError):\n                        pass\n\n    if key == 'DataObject':\n        key = element.attrib['ObjectType']\n    if key == 'Attribute':\n        key = element.attrib['Name']\n    return {key: value}\n</code></pre>"}]}
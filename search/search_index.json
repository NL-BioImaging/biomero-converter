{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"biomero-converter","text":"<p>Conversion from various formats to Ome-tiff and Ome-zarr </p>"},{"location":"container/","title":"General container requirements","text":""},{"location":"container/#input-arguments","title":"Input arguments","text":"<ul> <li>--inputfile (required): Path to the input file</li> <li>--outputfolder (required): Output directory for converted files</li> <li>--altoutputfolder (optional): Alternative output directory</li> <li>--show_progress (optional): Show progress bar during conversion (boolean value)</li> </ul>"},{"location":"container/#output-format","title":"Output format","text":"<p>The container should return the following output as JSON string</p> <p>A list containing a dictionary of: - name: base name of the created or relevant file (without extension) - full_path: absolute path to the output file - alt_path: absolute path to the file in altoutputfolder (if used and file exists), else null - keyvalues (optional): a list with a dictionary containing per-channel intensity stats and optional metadata</p>"},{"location":"container/#keyvalues-example","title":"keyvalues example","text":"<pre><code>\"keyvalues\":\n[\n  {\n    \"channel_mins\": [1097, 2257, 335, 175],\n    \"channel_maxs\": [7423, 5907, 10261, 3716],\n    \"channel_display_black_values\": [1179, 2357, 372, 202],\n    \"channel_display_white_values\": [6798, 5641, 7002, 2969]\n  }\n]\n</code></pre>"},{"location":"convert/","title":"converter.convert() Usage","text":"<p>The <code>convert()</code> function in <code>converter.py</code> is used to convert an input file to OME format and write the result to one or more output folders.</p>"},{"location":"convert/#example-usage","title":"Example Usage","text":"<pre><code>from converter import convert\n\ninput_filename = \"path/to/input_file\"\noutput_folder = \"path/to/output_folder\"\nalt_output_folder = \"path/to/alternative_output_folder\"\n\nresult_json = convert(\n    input_filename,\n    output_folder,\n    alt_output_folder,\n    output_format=\"omezarr2\",\n    show_progress=False,\n    verbose=False\n)\n\nprint(result_json)\n</code></pre>"},{"location":"convert/#arguments","title":"Arguments","text":"<ul> <li><code>input_filename</code> (str): Path to the input file.</li> <li><code>output_folder</code> (str): Output folder path.</li> <li><code>alt_output_folder</code> (str, optional): Alternative output folder path.</li> <li><code>output_format</code> (str): Output format string (default: <code>'omezarr2'</code>).</li> <li><code>show_progress</code> (bool): If <code>True</code>, prints progress.</li> <li><code>verbose</code> (bool): If <code>True</code>, enables verbose logging.</li> </ul>"},{"location":"convert/#returns","title":"Returns","text":"<p>A JSON string containing an array with conversion result info, e.g.:</p> <pre><code>[\n  {\n    \"name\": \"experiment_name\",\n    \"full_path\": \"path/to/output_folder/experiment_name.ome.zarr\",\n    \"alt_path\": \"path/to/alternative_output_folder/experiment_name.ome.zarr\"\n  }\n]\n</code></pre>"},{"location":"main/","title":"Using Docker to Run the Main Script","text":"<p>You can use Docker to run the conversion process by mounting your input and output folders and passing the required arguments.</p>"},{"location":"main/#example","title":"Example","text":"<pre><code>docker run --rm \\\n  -v /local/input_folder:/data/input \\\n  -v /local/output_folder:/data/output \\\n  biomero-converter:latest \\\n  python main.py \\\n    --inputfile /data/input/input_file.tiff \\\n    --outputfolder /data/output \\\n    --outputformat omezarr2 \\\n    --show_progress \\\n    --verbose\n</code></pre> <p>Replace <code>/local/input_folder</code> and <code>/local/output_folder</code> with your actual local paths. Adjust the image name (<code>biomero-converter:latest</code>) as needed.</p>"},{"location":"main/#arguments","title":"Arguments","text":"<p>Refer to the main script for all available arguments:</p> <ul> <li><code>--inputfile</code>: Path to the input file (required)</li> <li><code>--outputfolder</code>: Path to the output folder (required)</li> <li><code>--altoutputfolder</code>: Alternative output folder (optional)</li> <li><code>--outputformat</code>: Output format version (default: <code>omezarr2</code>)</li> <li><code>--show_progress</code>: Show progress bar (flag)</li> <li><code>--verbose</code>: Enable verbose logging (flag)</li> </ul>"},{"location":"overview/","title":"Converter Overview","text":"<p>This project provides a converter that transforms source image data into OME-Tiff or OME-Zarr format. When creating a github release, a Docker image is built and published to Docker Hub with corresponding version tags here.</p>"},{"location":"overview/#architecture","title":"Architecture","text":"<p>The converter workflow consists of:</p> <ul> <li>Creating a Source reader to access image data and metadata.</li> <li>Creating a Writer to generate OME output.</li> <li>The Writer queries the Source for metadata and data, then writes the output.</li> </ul> <pre><code>flowchart TD\n    Converter[\"Converter\"]\n    Source[\"Source Reader\"]\n    Writer[\"Writer\"]\n    Output[\"OME Output\"]\n\n    Converter --&gt; Source\n    Converter --&gt; Writer\n    Writer --&gt;|Query Metadata| Source\n    Writer --&gt;|Query Data| Source\n    Writer --&gt; Output</code></pre>"},{"location":"references/","title":"References","text":""},{"location":"references/#converter.convert","title":"<code>convert(input_filename, output_folder, alt_output_folder=None, output_format='omezarr2', show_progress=False, verbose=False, **kwargs)</code>","text":"Source code in <code>converter.py</code> <pre><code>def convert(input_filename, output_folder, alt_output_folder=None,\n            output_format='omezarr2', show_progress=False, verbose=False, **kwargs):\n    attempts = 0\n    while True:\n        try:\n            return _convert(input_filename, output_folder, alt_output_folder=alt_output_folder,\n                            output_format=output_format, show_progress=show_progress, verbose=verbose,\n                            **kwargs)\n        except Exception as e:\n            if attempts &gt;= CONVERSION_ATTEMPTS - 1:\n                logging.error(e)\n                raise Exception(f'Conversion failed after {CONVERSION_ATTEMPTS} attempts: {input_filename}')\n        attempts += 1\n</code></pre>"},{"location":"references/#converter.init_logging","title":"<code>init_logging(log_filename, verbose=False)</code>","text":"<p>Initialize logging to file and optionally to console.</p> <p>Parameters:</p> Name Type Description Default <code>log_filename</code> <code>str</code> <p>Path to the log file.</p> required <code>verbose</code> <code>bool</code> <p>If True, also log to console.</p> <code>False</code> Source code in <code>converter.py</code> <pre><code>def init_logging(log_filename, verbose=False):\n    \"\"\"\n    Initialize logging to file and optionally to console.\n\n    Args:\n        log_filename (str): Path to the log file.\n        verbose (bool): If True, also log to console.\n    \"\"\"\n    basepath = os.path.dirname(log_filename)\n    if basepath and not os.path.exists(basepath):\n        os.makedirs(basepath)\n    handlers = [logging.FileHandler(log_filename, encoding='utf-8')]\n    if verbose:\n        handlers += [logging.StreamHandler()]\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s: %(message)s',\n                        handlers=handlers,\n                        encoding='utf-8')\n\n    logging.getLogger('ome_zarr').setLevel(logging.WARNING)     # mute verbose ome_zarr logging\n</code></pre>"},{"location":"references/#src.DbReader","title":"<code>DbReader</code>","text":""},{"location":"references/#src.DbReader.DBReader","title":"<code>DBReader</code>","text":"<p>Reads and queries a SQLite database, returning results as dictionaries.</p> Source code in <code>src/DbReader.py</code> <pre><code>class DBReader:\n    \"\"\"\n    Reads and queries a SQLite database, returning results as dictionaries.\n    \"\"\"\n\n    def __init__(self, db_file):\n        \"\"\"\n        Initialize DBReader with a database file.\n\n        Args:\n            db_file (str): Path to the SQLite database file.\n        \"\"\"\n        self.conn = sqlite3.connect(db_file)\n        self.conn.row_factory = DBReader.dict_factory\n\n    @staticmethod\n    def dict_factory(cursor, row):\n        \"\"\"\n        Converts a database row to a dictionary.\n\n        Args:\n            cursor: SQLite cursor object.\n            row: Row data.\n\n        Returns:\n            dict: Mapping column names to values.\n        \"\"\"\n        dct = {}\n        for index, column in enumerate(cursor.description):\n            dct[column[0]] = row[index]\n        return dct\n\n    def fetch_all(self, query, params=(), return_dicts=True):\n        \"\"\"\n        Executes a query and fetches all results.\n\n        Args:\n            query (str): SQL query string.\n            params (tuple): Query parameters.\n            return_dicts (bool): If True, returns list of dicts; else, returns first column values.\n\n        Returns:\n            list: Query results.\n        \"\"\"\n        cursor = self.conn.cursor()\n        cursor.execute(query, params)\n        dct = cursor.fetchall()\n        if return_dicts:\n            values = dct\n        else:\n            values = [list(row.values())[0] for row in dct]\n        return values\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        self.conn.close()\n</code></pre>"},{"location":"references/#src.DbReader.DBReader.conn","title":"<code>conn = sqlite3.connect(db_file)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.DbReader.DBReader.__init__","title":"<code>__init__(db_file)</code>","text":"<p>Initialize DBReader with a database file.</p> <p>Parameters:</p> Name Type Description Default <code>db_file</code> <code>str</code> <p>Path to the SQLite database file.</p> required Source code in <code>src/DbReader.py</code> <pre><code>def __init__(self, db_file):\n    \"\"\"\n    Initialize DBReader with a database file.\n\n    Args:\n        db_file (str): Path to the SQLite database file.\n    \"\"\"\n    self.conn = sqlite3.connect(db_file)\n    self.conn.row_factory = DBReader.dict_factory\n</code></pre>"},{"location":"references/#src.DbReader.DBReader.close","title":"<code>close()</code>","text":"<p>Closes the database connection.</p> Source code in <code>src/DbReader.py</code> <pre><code>def close(self):\n    \"\"\"\n    Closes the database connection.\n    \"\"\"\n    self.conn.close()\n</code></pre>"},{"location":"references/#src.DbReader.DBReader.dict_factory","title":"<code>dict_factory(cursor, row)</code>  <code>staticmethod</code>","text":"<p>Converts a database row to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <p>SQLite cursor object.</p> required <code>row</code> <p>Row data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Mapping column names to values.</p> Source code in <code>src/DbReader.py</code> <pre><code>@staticmethod\ndef dict_factory(cursor, row):\n    \"\"\"\n    Converts a database row to a dictionary.\n\n    Args:\n        cursor: SQLite cursor object.\n        row: Row data.\n\n    Returns:\n        dict: Mapping column names to values.\n    \"\"\"\n    dct = {}\n    for index, column in enumerate(cursor.description):\n        dct[column[0]] = row[index]\n    return dct\n</code></pre>"},{"location":"references/#src.DbReader.DBReader.fetch_all","title":"<code>fetch_all(query, params=(), return_dicts=True)</code>","text":"<p>Executes a query and fetches all results.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>SQL query string.</p> required <code>params</code> <code>tuple</code> <p>Query parameters.</p> <code>()</code> <code>return_dicts</code> <code>bool</code> <p>If True, returns list of dicts; else, returns first column values.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>list</code> <p>Query results.</p> Source code in <code>src/DbReader.py</code> <pre><code>def fetch_all(self, query, params=(), return_dicts=True):\n    \"\"\"\n    Executes a query and fetches all results.\n\n    Args:\n        query (str): SQL query string.\n        params (tuple): Query parameters.\n        return_dicts (bool): If True, returns list of dicts; else, returns first column values.\n\n    Returns:\n        list: Query results.\n    \"\"\"\n    cursor = self.conn.cursor()\n    cursor.execute(query, params)\n    dct = cursor.fetchall()\n    if return_dicts:\n        values = dct\n    else:\n        values = [list(row.values())[0] for row in dct]\n    return values\n</code></pre>"},{"location":"references/#src.ISyntaxSource","title":"<code>ISyntaxSource</code>","text":""},{"location":"references/#src.ISyntaxSource.CONVERSION_ATTEMPTS","title":"<code>CONVERSION_ATTEMPTS = 3</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.ISyntaxSource.PYRAMID_DOWNSCALE","title":"<code>PYRAMID_DOWNSCALE = 2</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.ISyntaxSource.PYRAMID_LEVELS","title":"<code>PYRAMID_LEVELS = 6</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.ISyntaxSource.TIFF_COMPRESSION","title":"<code>TIFF_COMPRESSION = 'LZW'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.ISyntaxSource.TILE_SIZE","title":"<code>TILE_SIZE = 1024</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.ISyntaxSource.VERSION","title":"<code>VERSION = 'v0.1.2'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.ISyntaxSource.ZARR_CHUNK_SIZE","title":"<code>ZARR_CHUNK_SIZE = TILE_SIZE</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.ISyntaxSource.ZARR_SHARD_MULTIPLIER","title":"<code>ZARR_SHARD_MULTIPLIER = 10</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.ISyntaxSource.ISyntaxSource","title":"<code>ISyntaxSource</code>","text":"<p>               Bases: <code>ImageSource</code></p> <p>Loads image and metadata from ISyntax format files.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>class ISyntaxSource(ImageSource):\n    \"\"\"\n    Loads image and metadata from ISyntax format files.\n    \"\"\"\n    def init_metadata(self):\n        \"\"\"\n        Initializes and loads metadata from the ISyntax file.\n\n        Returns:\n            dict: Metadata dictionary.\n        \"\"\"\n        # read XML metadata header\n        data = b''\n        block_size = 1024 * 1024\n        end_char = b'\\x04'   # EOT character\n        with open(self.uri, mode='rb') as file:\n            done = False\n            while not done:\n                data_block = file.read(block_size)\n                if end_char in data_block:\n                    index = data_block.index(end_char)\n                    data_block = data_block[:index]\n                    done = True\n                data += data_block\n\n        self.metadata = xml_content_to_dict(ElementTree.XML(data.decode()))\n        if 'DPUfsImport' in self.metadata:\n            self.metadata = self.metadata['DPUfsImport']\n\n        image = None\n        image_type = ''\n        for image0 in self.metadata.get('PIM_DP_SCANNED_IMAGES', []):\n            image = image0.get('DPScannedImage', {})\n            image_type = image.get('PIM_DP_IMAGE_TYPE').lower()\n            if image_type in ['wsi']:\n                break\n\n        if image is not None:\n            self.image_type = image_type\n            nbits = image.get('UFS_IMAGE_BLOCK_HEADER_TEMPLATES', [{}])[0].get('UFSImageBlockHeaderTemplate', {}).get('DICOM_BITS_STORED', 16)\n            nbits = int(np.ceil(nbits / 8)) * 8\n        else:\n            self.image_type = ''\n            nbits = 16\n\n        self.is_plate = 'screen' in self.image_type or 'plate' in self.image_type or 'wells' in self.image_type\n\n        self.isyntax = ISyntax.open(self.uri)\n        self.widths = [size[0] for size in self.isyntax.level_dimensions]\n        self.heights = [size[1] for size in self.isyntax.level_dimensions]\n        self.scales = [1 / scale for scale in self.isyntax.level_downsamples]\n        self.width, self.height = self.isyntax.dimensions\n\n        # original color channels get converted in pyisyntax package to 8-bit RGBA\n        nbits = 8\n        self.channels = []\n        self.nchannels = 4\n        self.source_shape = self.height, self.width, self.nchannels\n        self.source_dim_order = 'yxc'\n        self.is_rgb_channels = True\n        self.dtype = np.dtype(f'uint{nbits}')\n\n        self.shape = 1, self.nchannels, 1, self.height, self.width\n        self.dim_order = 'tczyx'\n\n        return self.metadata\n\n    def is_screen(self):\n        \"\"\"\n        Checks if the source is a plate/screen.\n\n        Returns:\n            bool: True if plate/screen.\n        \"\"\"\n        return self.is_plate\n\n    def get_shape(self):\n        \"\"\"\n        Returns the shape of the image data.\n\n        Returns:\n            tuple: Shape of the image data.\n        \"\"\"\n        return self.shape\n\n    def get_data(self, well_id=None, field_id=None, as_dask=False, as_generator=False, **kwargs):\n        \"\"\"\n        Gets image data for a specific well and field.\n\n        Returns:\n            ndarray: Image data.\n        \"\"\"\n\n        def get_lazy_tile(x, y, width, height):\n            lazy_array = dask.delayed(self.isyntax.read_region)(x, y, width, height)\n            return da.from_delayed(lazy_array, shape=(height, width, self.nchannels), dtype=self.dtype)\n\n        if as_dask:\n            dask.config.set(scheduler='single-threaded')\n            shape = self.shape[-2:]\n            y_chunks, x_chunks = da.core.normalize_chunks(TILE_SIZE, shape, dtype=self.dtype)\n            rows = []\n            x = 0\n            y = 0\n            for height in y_chunks:\n                row = []\n                for width in x_chunks:\n                    row.append(get_lazy_tile(x, y, width, height))\n                    x += width\n                rows.append(da.concatenate(row, axis=1))\n                y += height\n            data = da.concatenate(rows, axis=0)\n            return redimension_data(data, self.source_dim_order, self.dim_order)\n        elif as_generator:\n            # TODO: use Tiff.memmap?\n            def get_level_from_scale(target_scale=1):\n                best_level_scale = 0, target_scale\n                for level, scale in enumerate(self.scales):\n                    if np.isclose(scale, target_scale):\n                        return level, 1\n                    if scale &gt; target_scale:\n                        best_level_scale = level, target_scale / scale\n                return best_level_scale\n\n            def tile_generator(scale=1):\n                level, rescale = get_level_from_scale(scale)\n                read_size = int(TILE_SIZE / rescale)\n                for y in range(0, self.heights[level], read_size):\n                    for x in range(0, self.widths[level], read_size):\n                        data = self.isyntax.read_region(x, y, read_size, read_size, level)\n                        if rescale != 1:\n                            data = resize(data, (TILE_SIZE, TILE_SIZE), preserve_range=True).astype(data.dtype)\n                        yield data\n            return tile_generator\n        else:\n            data = self.isyntax.read_region(0, 0, self.width, self.height)\n            return redimension_data(data, self.source_dim_order, self.dim_order)\n\n\n    def get_image_window(self, well_id=None, field_id=None, data=None):\n        # For RGB(A) uint8 images don't change color value range\n        if not (self.is_rgb_channels and self.dtype == np.uint8):\n            level = None\n            dims = None\n            for level0, dims0 in enumerate(self.isyntax.level_dimensions):\n                if np.prod(dims0) &lt; 1e7:\n                    level = level0\n                    dims = dims0\n                    break\n            if level is not None:\n                window_scanner = WindowScanner()\n                data = self.isyntax.read_region(0, 0, dims[0], dims[1], level=level)\n                window_scanner.process(data, self.source_dim_order)\n                return window_scanner.get_window()\n        return [], []\n\n    def get_name(self):\n        \"\"\"\n        Gets the file title.\n\n        Returns:\n            str: Name.\n        \"\"\"\n        return get_filetitle(self.uri)\n\n    def get_dim_order(self):\n        \"\"\"\n        Returns the dimension order string.\n\n        Returns:\n            str: Dimension order.\n        \"\"\"\n        return self.dim_order\n\n    def get_pixel_size_um(self):\n        \"\"\"\n        Returns the pixel size in micrometers.\n\n        Returns:\n            dict: Pixel size dict for x and y.\n        \"\"\"\n        return {'x': self.isyntax.mpp_x, 'y': self.isyntax.mpp_y}\n\n    def get_dtype(self):\n        \"\"\"\n        Returns the numpy dtype of the image data.\n\n        Returns:\n            dtype: Numpy dtype.\n        \"\"\"\n        return self.dtype\n\n    def get_position_um(self, well_id=None):\n        \"\"\"\n        Returns the position in micrometers (empty for ISyntax).\n\n        Returns:\n            dict: Position dict for x and y.\n        \"\"\"\n        return {'x': self.isyntax.offset_x, 'y': self.isyntax.offset_y}\n\n    def get_channels(self):\n        \"\"\"\n        Returns channel metadata.\n\n        Returns:\n            list: List of channel dicts.\n        \"\"\"\n        return self.channels\n\n    def get_nchannels(self):\n        \"\"\"\n        Returns the number of channels.\n\n        Returns:\n            int: Number of channels.\n        \"\"\"\n        return self.nchannels\n\n    def is_rgb(self):\n        \"\"\"\n        Check if the source is a RGB(A) image.\n        \"\"\"\n        return self.is_rgb_channels\n\n    def get_rows(self):\n        \"\"\"\n        Returns the list of row identifiers (empty for ISyntax).\n\n        Returns:\n            list: Empty list.\n        \"\"\"\n        return []\n\n    def get_columns(self):\n        \"\"\"\n        Returns the list of column identifiers (empty for ISyntax).\n\n        Returns:\n            list: Empty list.\n        \"\"\"\n        return []\n\n    def get_wells(self):\n        \"\"\"\n        Returns the list of well identifiers (empty for ISyntax).\n\n        Returns:\n            list: Empty list.\n        \"\"\"\n        return []\n\n    def get_time_points(self):\n        \"\"\"\n        Returns the list of time points (empty for ISyntax).\n\n        Returns:\n            list: Empty list.\n        \"\"\"\n        return []\n\n    def get_fields(self):\n        \"\"\"\n        Returns the list of field indices (empty for ISyntax).\n\n        Returns:\n            list: Empty list.\n        \"\"\"\n        return []\n\n    def get_acquisitions(self):\n        \"\"\"\n        Returns acquisition metadata (empty for ISyntax).\n\n        Returns:\n            list: Empty list.\n        \"\"\"\n        return []\n\n    def get_total_data_size(self):\n        \"\"\"\n        Returns the estimated total data size.\n\n        Returns:\n            int: Total data size in bytes.\n        \"\"\"\n        total_size = np.prod(self.shape)\n        if self.is_plate:\n            total_size *= len(self.get_wells()) * len(self.get_fields())\n        return total_size\n\n    def close(self):\n        \"\"\"\n        Closes the ISyntax file.\n        \"\"\"\n        self.isyntax.close()\n        dask.config.set(scheduler='threads')\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.close","title":"<code>close()</code>","text":"<p>Closes the ISyntax file.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def close(self):\n    \"\"\"\n    Closes the ISyntax file.\n    \"\"\"\n    self.isyntax.close()\n    dask.config.set(scheduler='threads')\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_acquisitions","title":"<code>get_acquisitions()</code>","text":"<p>Returns acquisition metadata (empty for ISyntax).</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_acquisitions(self):\n    \"\"\"\n    Returns acquisition metadata (empty for ISyntax).\n\n    Returns:\n        list: Empty list.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_channels","title":"<code>get_channels()</code>","text":"<p>Returns channel metadata.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of channel dicts.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_channels(self):\n    \"\"\"\n    Returns channel metadata.\n\n    Returns:\n        list: List of channel dicts.\n    \"\"\"\n    return self.channels\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_columns","title":"<code>get_columns()</code>","text":"<p>Returns the list of column identifiers (empty for ISyntax).</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_columns(self):\n    \"\"\"\n    Returns the list of column identifiers (empty for ISyntax).\n\n    Returns:\n        list: Empty list.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_data","title":"<code>get_data(well_id=None, field_id=None, as_dask=False, as_generator=False, **kwargs)</code>","text":"<p>Gets image data for a specific well and field.</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <p>Image data.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_data(self, well_id=None, field_id=None, as_dask=False, as_generator=False, **kwargs):\n    \"\"\"\n    Gets image data for a specific well and field.\n\n    Returns:\n        ndarray: Image data.\n    \"\"\"\n\n    def get_lazy_tile(x, y, width, height):\n        lazy_array = dask.delayed(self.isyntax.read_region)(x, y, width, height)\n        return da.from_delayed(lazy_array, shape=(height, width, self.nchannels), dtype=self.dtype)\n\n    if as_dask:\n        dask.config.set(scheduler='single-threaded')\n        shape = self.shape[-2:]\n        y_chunks, x_chunks = da.core.normalize_chunks(TILE_SIZE, shape, dtype=self.dtype)\n        rows = []\n        x = 0\n        y = 0\n        for height in y_chunks:\n            row = []\n            for width in x_chunks:\n                row.append(get_lazy_tile(x, y, width, height))\n                x += width\n            rows.append(da.concatenate(row, axis=1))\n            y += height\n        data = da.concatenate(rows, axis=0)\n        return redimension_data(data, self.source_dim_order, self.dim_order)\n    elif as_generator:\n        # TODO: use Tiff.memmap?\n        def get_level_from_scale(target_scale=1):\n            best_level_scale = 0, target_scale\n            for level, scale in enumerate(self.scales):\n                if np.isclose(scale, target_scale):\n                    return level, 1\n                if scale &gt; target_scale:\n                    best_level_scale = level, target_scale / scale\n            return best_level_scale\n\n        def tile_generator(scale=1):\n            level, rescale = get_level_from_scale(scale)\n            read_size = int(TILE_SIZE / rescale)\n            for y in range(0, self.heights[level], read_size):\n                for x in range(0, self.widths[level], read_size):\n                    data = self.isyntax.read_region(x, y, read_size, read_size, level)\n                    if rescale != 1:\n                        data = resize(data, (TILE_SIZE, TILE_SIZE), preserve_range=True).astype(data.dtype)\n                    yield data\n        return tile_generator\n    else:\n        data = self.isyntax.read_region(0, 0, self.width, self.height)\n        return redimension_data(data, self.source_dim_order, self.dim_order)\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"<p>Returns the dimension order string.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Dimension order.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_dim_order(self):\n    \"\"\"\n    Returns the dimension order string.\n\n    Returns:\n        str: Dimension order.\n    \"\"\"\n    return self.dim_order\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_dtype","title":"<code>get_dtype()</code>","text":"<p>Returns the numpy dtype of the image data.</p> <p>Returns:</p> Name Type Description <code>dtype</code> <p>Numpy dtype.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_dtype(self):\n    \"\"\"\n    Returns the numpy dtype of the image data.\n\n    Returns:\n        dtype: Numpy dtype.\n    \"\"\"\n    return self.dtype\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_fields","title":"<code>get_fields()</code>","text":"<p>Returns the list of field indices (empty for ISyntax).</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_fields(self):\n    \"\"\"\n    Returns the list of field indices (empty for ISyntax).\n\n    Returns:\n        list: Empty list.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_image_window","title":"<code>get_image_window(well_id=None, field_id=None, data=None)</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_image_window(self, well_id=None, field_id=None, data=None):\n    # For RGB(A) uint8 images don't change color value range\n    if not (self.is_rgb_channels and self.dtype == np.uint8):\n        level = None\n        dims = None\n        for level0, dims0 in enumerate(self.isyntax.level_dimensions):\n            if np.prod(dims0) &lt; 1e7:\n                level = level0\n                dims = dims0\n                break\n        if level is not None:\n            window_scanner = WindowScanner()\n            data = self.isyntax.read_region(0, 0, dims[0], dims[1], level=level)\n            window_scanner.process(data, self.source_dim_order)\n            return window_scanner.get_window()\n    return [], []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_name","title":"<code>get_name()</code>","text":"<p>Gets the file title.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Name.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_name(self):\n    \"\"\"\n    Gets the file title.\n\n    Returns:\n        str: Name.\n    \"\"\"\n    return get_filetitle(self.uri)\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"<p>Returns the number of channels.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of channels.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_nchannels(self):\n    \"\"\"\n    Returns the number of channels.\n\n    Returns:\n        int: Number of channels.\n    \"\"\"\n    return self.nchannels\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"<p>Returns the pixel size in micrometers.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Pixel size dict for x and y.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_pixel_size_um(self):\n    \"\"\"\n    Returns the pixel size in micrometers.\n\n    Returns:\n        dict: Pixel size dict for x and y.\n    \"\"\"\n    return {'x': self.isyntax.mpp_x, 'y': self.isyntax.mpp_y}\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_position_um","title":"<code>get_position_um(well_id=None)</code>","text":"<p>Returns the position in micrometers (empty for ISyntax).</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Position dict for x and y.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_position_um(self, well_id=None):\n    \"\"\"\n    Returns the position in micrometers (empty for ISyntax).\n\n    Returns:\n        dict: Position dict for x and y.\n    \"\"\"\n    return {'x': self.isyntax.offset_x, 'y': self.isyntax.offset_y}\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_rows","title":"<code>get_rows()</code>","text":"<p>Returns the list of row identifiers (empty for ISyntax).</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_rows(self):\n    \"\"\"\n    Returns the list of row identifiers (empty for ISyntax).\n\n    Returns:\n        list: Empty list.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_shape","title":"<code>get_shape()</code>","text":"<p>Returns the shape of the image data.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Shape of the image data.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_shape(self):\n    \"\"\"\n    Returns the shape of the image data.\n\n    Returns:\n        tuple: Shape of the image data.\n    \"\"\"\n    return self.shape\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_time_points","title":"<code>get_time_points()</code>","text":"<p>Returns the list of time points (empty for ISyntax).</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_time_points(self):\n    \"\"\"\n    Returns the list of time points (empty for ISyntax).\n\n    Returns:\n        list: Empty list.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_total_data_size","title":"<code>get_total_data_size()</code>","text":"<p>Returns the estimated total data size.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Total data size in bytes.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_total_data_size(self):\n    \"\"\"\n    Returns the estimated total data size.\n\n    Returns:\n        int: Total data size in bytes.\n    \"\"\"\n    total_size = np.prod(self.shape)\n    if self.is_plate:\n        total_size *= len(self.get_wells()) * len(self.get_fields())\n    return total_size\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_wells","title":"<code>get_wells()</code>","text":"<p>Returns the list of well identifiers (empty for ISyntax).</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_wells(self):\n    \"\"\"\n    Returns the list of well identifiers (empty for ISyntax).\n\n    Returns:\n        list: Empty list.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.init_metadata","title":"<code>init_metadata()</code>","text":"<p>Initializes and loads metadata from the ISyntax file.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Metadata dictionary.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def init_metadata(self):\n    \"\"\"\n    Initializes and loads metadata from the ISyntax file.\n\n    Returns:\n        dict: Metadata dictionary.\n    \"\"\"\n    # read XML metadata header\n    data = b''\n    block_size = 1024 * 1024\n    end_char = b'\\x04'   # EOT character\n    with open(self.uri, mode='rb') as file:\n        done = False\n        while not done:\n            data_block = file.read(block_size)\n            if end_char in data_block:\n                index = data_block.index(end_char)\n                data_block = data_block[:index]\n                done = True\n            data += data_block\n\n    self.metadata = xml_content_to_dict(ElementTree.XML(data.decode()))\n    if 'DPUfsImport' in self.metadata:\n        self.metadata = self.metadata['DPUfsImport']\n\n    image = None\n    image_type = ''\n    for image0 in self.metadata.get('PIM_DP_SCANNED_IMAGES', []):\n        image = image0.get('DPScannedImage', {})\n        image_type = image.get('PIM_DP_IMAGE_TYPE').lower()\n        if image_type in ['wsi']:\n            break\n\n    if image is not None:\n        self.image_type = image_type\n        nbits = image.get('UFS_IMAGE_BLOCK_HEADER_TEMPLATES', [{}])[0].get('UFSImageBlockHeaderTemplate', {}).get('DICOM_BITS_STORED', 16)\n        nbits = int(np.ceil(nbits / 8)) * 8\n    else:\n        self.image_type = ''\n        nbits = 16\n\n    self.is_plate = 'screen' in self.image_type or 'plate' in self.image_type or 'wells' in self.image_type\n\n    self.isyntax = ISyntax.open(self.uri)\n    self.widths = [size[0] for size in self.isyntax.level_dimensions]\n    self.heights = [size[1] for size in self.isyntax.level_dimensions]\n    self.scales = [1 / scale for scale in self.isyntax.level_downsamples]\n    self.width, self.height = self.isyntax.dimensions\n\n    # original color channels get converted in pyisyntax package to 8-bit RGBA\n    nbits = 8\n    self.channels = []\n    self.nchannels = 4\n    self.source_shape = self.height, self.width, self.nchannels\n    self.source_dim_order = 'yxc'\n    self.is_rgb_channels = True\n    self.dtype = np.dtype(f'uint{nbits}')\n\n    self.shape = 1, self.nchannels, 1, self.height, self.width\n    self.dim_order = 'tczyx'\n\n    return self.metadata\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.is_rgb","title":"<code>is_rgb()</code>","text":"<p>Check if the source is a RGB(A) image.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def is_rgb(self):\n    \"\"\"\n    Check if the source is a RGB(A) image.\n    \"\"\"\n    return self.is_rgb_channels\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.is_screen","title":"<code>is_screen()</code>","text":"<p>Checks if the source is a plate/screen.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if plate/screen.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>def is_screen(self):\n    \"\"\"\n    Checks if the source is a plate/screen.\n\n    Returns:\n        bool: True if plate/screen.\n    \"\"\"\n    return self.is_plate\n</code></pre>"},{"location":"references/#src.ImageDbSource","title":"<code>ImageDbSource</code>","text":""},{"location":"references/#src.ImageDbSource.ImageDbSource","title":"<code>ImageDbSource</code>","text":"<p>               Bases: <code>ImageSource</code></p> <p>Loads image and metadata from a database source for high-content screening.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>class ImageDbSource(ImageSource):\n    \"\"\"\n    Loads image and metadata from a database source for high-content screening.\n    \"\"\"\n    def __init__(self, uri, metadata={}):\n        \"\"\"\n        Initialize ImageDbSource.\n\n        Args:\n            uri (str): Path to the database file.\n            metadata (dict): Optional metadata dictionary.\n        \"\"\"\n        super().__init__(uri, metadata)\n        self.db = DBReader(self.uri)\n        self.data = None\n        self.data_well_id = None\n        self.dim_order = 'tczyx'\n\n    def init_metadata(self):\n        \"\"\"\n        Initializes and loads metadata from the database.\n\n        Returns:\n            dict: Metadata dictionary.\n        \"\"\"\n        self._get_time_series_info()\n        self._get_experiment_metadata()\n        self._get_well_info()\n        self._get_image_info()\n        self._get_sizes()\n        return self.metadata\n\n    def get_shape(self):\n        \"\"\"\n        Returns the shape of the image data.\n\n        Returns:\n            tuple: Shape of the image data.\n        \"\"\"\n        return self.shape\n\n    def _get_time_series_info(self):\n        \"\"\"\n        Loads time series and image file info into metadata.\n        \"\"\"\n        time_series_ids = sorted(self.db.fetch_all('SELECT DISTINCT TimeSeriesElementId FROM SourceImageBase', return_dicts=False))\n        self.metadata['time_points'] = time_series_ids\n\n        level_ids = sorted(self.db.fetch_all('SELECT DISTINCT level FROM SourceImageBase', return_dicts=False))\n        self.metadata['levels'] = level_ids\n\n        image_files = {time_series_id: os.path.join(os.path.dirname(self.uri), f'images-{time_series_id}.db')\n                       for time_series_id in time_series_ids}\n        self.metadata['image_files'] = image_files\n\n    def _get_experiment_metadata(self):\n        \"\"\"\n        Loads experiment metadata and acquisition info into metadata.\n        \"\"\"\n        creation_info = self.db.fetch_all('SELECT DateCreated, Creator, Name FROM ExperimentBase')[0]\n        creation_info['DateCreated'] = convert_dotnet_ticks_to_datetime(creation_info['DateCreated'])\n        self.metadata.update(creation_info)\n\n        acquisitions = self.db.fetch_all('SELECT Name, Description, DateCreated, DateModified FROM AcquisitionExp')\n        for acquisition in acquisitions:\n            acquisition['DateCreated'] = convert_dotnet_ticks_to_datetime(acquisition['DateCreated'])\n            acquisition['DateModified'] = convert_dotnet_ticks_to_datetime(acquisition['DateModified'])\n        self.metadata['acquisitions'] = acquisitions\n\n    def _get_well_info(self):\n        \"\"\"\n        Loads well and channel information into metadata.\n        \"\"\"\n        well_info = self.db.fetch_all('''\n            SELECT SensorSizeYPixels, SensorSizeXPixels, Objective, PixelSizeUm, SensorBitness, SitesX, SitesY\n            FROM AcquisitionExp, AutomaticZonesParametersExp\n        ''')[0]\n\n        # Filter multiple duplicate channel entries\n        channel_infos = self.db.fetch_all('''\n            SELECT DISTINCT ChannelNumber, Emission, Excitation, Dye, Color\n            FROM ImagechannelExp\n            ORDER BY ChannelNumber\n        ''')\n        self.metadata['channels'] = channel_infos\n        self.metadata['num_channels'] = len(channel_infos)\n\n        wells = self.db.fetch_all('SELECT DISTINCT Name FROM Well')\n        zone_names = [well['Name'] for well in wells]\n        rows = set()\n        cols = set()\n        for zone_name in zone_names:\n            row, col = split_well_name(zone_name)\n            rows.add(row)\n            cols.add(col)\n        well_info['rows'] = sorted(list(rows))\n        well_info['columns'] = sorted(list(cols), key=lambda x: int(x))\n        num_sites = well_info['SitesX'] * well_info['SitesY']\n        well_info['num_sites'] = num_sites\n        well_info['fields'] = list(range(num_sites))\n\n        image_wells = self.db.fetch_all('SELECT Name, ZoneIndex, CoordX, CoordY FROM Well WHERE HasImages = 1')\n        self.metadata['wells'] = dict(sorted({well['Name']: well for well in image_wells}.items(),\n                                             key=lambda x: split_well_name(x[0], col_as_int=True)))\n\n        xmax, ymax = 0, 0\n        for well_id in self.metadata['wells']:\n            well_data = self._read_well_info(well_id)\n            xmax = max(xmax, np.max([info['CoordX'] + info['SizeX'] for info in well_data]))\n            ymax = max(ymax, np.max([info['CoordY'] + info['SizeY'] for info in well_data]))\n        pixel_size = well_info.get('PixelSizeUm', 1)\n        well_info['max_sizex_um'] = xmax * pixel_size\n        well_info['max_sizey_um'] = ymax * pixel_size\n\n        self.metadata['well_info'] = well_info\n\n    def _get_image_info(self):\n        \"\"\"\n        Loads image bit depth and dtype info into metadata.\n        \"\"\"\n        bits_per_pixel = self.db.fetch_all('SELECT DISTINCT BitsPerPixel FROM SourceImageBase', return_dicts=False)[0]\n        self.bits_per_pixel = bits_per_pixel\n        bits_per_pixel = int(np.ceil(bits_per_pixel / 8)) * 8\n        if bits_per_pixel == 24:\n            bits_per_pixel = 32\n        self.dtype = np.dtype(f'uint{bits_per_pixel}')\n\n    def _get_sizes(self):\n        \"\"\"\n        Calculates and stores image shape and estimated data size.\n        \"\"\"\n        well_info = self.metadata['well_info']\n        nbytes = self.dtype.itemsize\n        self.shape = len(self.metadata['time_points']), self.metadata['num_channels'], 1, well_info['SensorSizeYPixels'], well_info['SensorSizeXPixels']\n        max_data_size = np.prod(self.shape) * nbytes * len(self.metadata['wells']) * well_info['num_sites']\n        self.metadata['max_data_size'] = max_data_size\n\n    def _read_well_info(self, well_id, channel=None, time_point=None, level=0):\n        \"\"\"\n        Reads image info for a specific well, optionally filtered by channel and time point.\n\n        Args:\n            well_id (str): Well identifier.\n            channel (int, optional): Channel ID.\n            time_point (int, optional): Time point ID.\n            level (int, optional): Image level index.\n\n        Returns:\n            list: Well image info dictionaries.\n        \"\"\"\n        well_id = strip_leading_zeros(well_id)\n        well_ids = self.metadata.get('wells', {})\n\n        if well_id not in well_ids:\n            raise ValueError(f'Invalid Well: {well_id}. Available values: {well_ids}')\n\n        zone_index = well_ids[well_id]['ZoneIndex']\n        well_info = self.db.fetch_all('''\n            SELECT *\n            FROM SourceImageBase\n            WHERE ZoneIndex = ? AND level = ?\n            ORDER BY CoordX ASC, CoordY ASC\n        ''', (zone_index, level))\n\n        if channel is not None:\n             well_info = [info for info in well_info if info['ChannelId'] == channel]\n        if time_point is not None:\n             well_info = [info for info in well_info if info['TimeSeriesElementId'] == time_point]\n        if not well_info:\n            raise ValueError(f'No data found for well {well_id}')\n        return well_info\n\n    def _assemble_image_data(self, well_info):\n        \"\"\"\n        Assembles image data array using well info.\n\n        Args:\n            well_info (list): List of well image info dicts.\n        \"\"\"\n        well_info = np.asarray(well_info)\n        xmax = np.max([info['CoordX'] + info['SizeX'] for info in well_info])\n        ymax = np.max([info['CoordY'] + info['SizeY'] for info in well_info])\n        zmax = np.max([info.get('CoordZ', 0) + info.get('SizeZ', 1) for info in well_info])\n        nc = len(set([info['ChannelId'] for info in well_info]))\n        nt = len(self.metadata['time_points'])\n        data = np.zeros((nt, nc, zmax, ymax, xmax), dtype=self.dtype)\n\n        for timei, time_id in enumerate(self.metadata['time_points']):\n            image_file = self.metadata['image_files'][time_id]\n            with open(image_file, 'rb') as fid:\n                for info in well_info:\n                    if info['TimeSeriesElementId'] == time_id:\n                        fid.seek(info['ImageIndex'])\n                        coordx, coordy, coordz = info['CoordX'], info['CoordY'], info.get('CoordZ', 0)\n                        sizex, sizey, sizez = info['SizeX'], info['SizeY'], info.get('SizeZ', 1)\n                        channeli = info['ChannelId']\n                        tile = np.fromfile(fid, dtype=self.dtype, count=sizez * sizey * sizex)\n                        data[timei, channeli, coordz:coordz + sizez, coordy:coordy + sizey, coordx:coordx + sizex] = tile.reshape((sizez, sizey, sizex))\n\n        self.data = data\n\n    def _extract_site(self, site_id=None):\n        \"\"\"\n        Extracts image data for a specific site or all sites.\n\n        Args:\n            site_id (int, optional): Site index. If None, returns all data.\n\n        Returns:\n            ndarray or list: Image data for the site(s).\n        \"\"\"\n        well_info = self.metadata['well_info']\n        sitesx = well_info['SitesX']\n        sitesy = well_info['SitesY']\n        sitesz = well_info.get('SitesZ', 1)\n        num_sites = well_info['num_sites']\n        sizex = well_info['SensorSizeXPixels']\n        sizey = well_info['SensorSizeYPixels']\n        sizez = well_info.get('SensorSizeZPixels', 1)\n\n        if site_id is None:\n            # Return full image data\n            return self.data\n\n        site_id = int(site_id)\n        if site_id &lt; 0:\n            # Return list of all fields\n            data = []\n            for zi in range(sitesz):\n                for yi in range(sitesy):\n                    for xi in range(sitesx):\n                        startx = xi * sizex\n                        starty = yi * sizey\n                        startz = zi * sizez\n                        data.append(self.data[..., startz:startz + sizez, starty:starty + sizey, startx:startx + sizex])\n            return data\n        elif 0 &lt;= site_id &lt; num_sites:\n            # Return specific site\n            xi = site_id % sitesx\n            yi = (site_id // sitesx) % sitesy\n            zi = site_id // sitesx // sitesy\n            startx = xi * sizex\n            starty = yi * sizey\n            startz = zi * sizez\n            return self.data[..., startz:startz + sizez, starty:starty + sizey, startx:startx + sizex]\n        else:\n            raise ValueError(f'Invalid site: {site_id}')\n\n    def is_screen(self):\n        \"\"\"\n        Checks if the source is a screen (has wells).\n\n        Returns:\n            bool: True if wells exist.\n        \"\"\"\n        return len(self.metadata['wells']) &gt; 0\n\n    def get_data(self, well_id=None, field_id=None, as_dask=False, **kwargs):\n        \"\"\"\n        Gets image data for a specific well and field.\n\n        Returns:\n            ndarray: Image data.\n        \"\"\"\n        if well_id != self.data_well_id:\n            self._assemble_image_data(self._read_well_info(well_id))\n            self.data_well_id = well_id\n        return self._extract_site(field_id)\n\n    def get_image_window(self, well_id=None, field_id=None, data=None):\n        # Assume data is not RGB(A) &amp; uint8\n        window_scanner = WindowScanner()\n        window_scanner.process(data, self.get_dim_order())\n        return window_scanner.get_window()\n\n    def get_name(self):\n        \"\"\"\n        Gets the experiment or file name.\n\n        Returns:\n            str: Name.\n        \"\"\"\n        name = self.metadata.get('Name')\n        if not name:\n            name = splitall(os.path.splitext(self.uri)[0])[-2]\n        return name\n\n    def get_rows(self):\n        \"\"\"\n        Returns the list of row identifiers.\n\n        Returns:\n            list: Row identifiers.\n        \"\"\"\n        return self.metadata['well_info']['rows']\n\n    def get_columns(self):\n        \"\"\"\n        Returns the list of column identifiers.\n\n        Returns:\n            list: Column identifiers.\n        \"\"\"\n        return self.metadata['well_info']['columns']\n\n    def get_wells(self):\n        \"\"\"\n        Returns the list of well identifiers.\n\n        Returns:\n            list: Well identifiers.\n        \"\"\"\n        return list(self.metadata['wells'])\n\n    def get_time_points(self):\n        \"\"\"\n        Returns the list of time points.\n\n        Returns:\n            list: Time point IDs.\n        \"\"\"\n        return self.metadata['time_points']\n\n    def get_fields(self):\n        \"\"\"\n        Returns the list of field indices.\n\n        Returns:\n            list: Field indices.\n        \"\"\"\n        return self.metadata['well_info']['fields']\n\n    def get_dim_order(self):\n        \"\"\"\n        Returns the dimension order string.\n\n        Returns:\n            str: Dimension order.\n        \"\"\"\n        return self.dim_order\n\n    def get_dtype(self):\n        \"\"\"\n        Returns the numpy dtype of the image data.\n\n        Returns:\n            dtype: Numpy dtype.\n        \"\"\"\n        return self.dtype\n\n    def get_pixel_size_um(self):\n        \"\"\"\n        Returns the pixel size in micrometers.\n\n        Returns:\n            dict: Pixel size for x and y.\n        \"\"\"\n        pixel_size = self.metadata['well_info'].get('PixelSizeUm', 1)\n        return {'x': pixel_size, 'y': pixel_size}\n\n    def get_position_um(self, well_id=None):\n        \"\"\"\n        Returns the position in micrometers for a well.\n\n        Args:\n            well_id (str): Well identifier.\n\n        Returns:\n            dict: Position in micrometers.\n        \"\"\"\n        well = self.metadata['wells'][well_id]\n        well_info = self.metadata['well_info']\n        x = well.get('CoordX', 0) * well_info['max_sizex_um']\n        y = well.get('CoordY', 0) * well_info['max_sizey_um']\n        return {'x': x, 'y': y}\n\n    def get_channels(self):\n        \"\"\"\n        Returns channel metadata.\n\n        Returns:\n            list: List of channel dicts.\n        \"\"\"\n        channels = []\n        for channel0 in self.metadata['channels']:\n            channel = {}\n            if 'Dye' in channel0 and channel0['Dye']:\n                channel['label'] = channel0['Dye']\n            if 'Color' in channel0:\n                channel['color'] = hexrgb_to_rgba(channel0['Color'].lstrip('#'))\n            channels.append(channel)\n        return channels\n\n    def get_nchannels(self):\n        \"\"\"\n        Returns the number of channels.\n\n        Returns:\n            int: Number of channels.\n        \"\"\"\n        return max(self.metadata['num_channels'], 1)\n\n    def is_rgb(self):\n        \"\"\"\n        Check if the source is a RGB(A) image.\n        \"\"\"\n        return False\n\n    def get_acquisitions(self):\n        \"\"\"\n        Returns acquisition metadata.\n\n        Returns:\n            list: List of acquisition dicts.\n        \"\"\"\n        acquisitions = []\n        for index, acq in enumerate(self.metadata.get('acquisitions', [])):\n            acquisitions.append({\n                'id': index,\n                'name': acq['Name'],\n                'description': acq['Description'],\n                'date_created': acq['DateCreated'].isoformat(),\n                'date_modified': acq['DateModified'].isoformat()\n            })\n        return acquisitions\n\n    def get_total_data_size(self):\n        \"\"\"\n        Returns the estimated total data size.\n\n        Returns:\n            int: Total data size in bytes.\n        \"\"\"\n        return self.metadata['max_data_size']\n\n    def print_well_matrix(self):\n        \"\"\"\n        Returns a string representation of the well matrix.\n\n        Returns:\n            str: Well matrix.\n        \"\"\"\n        s = ''\n\n        well_info = self.metadata['well_info']\n        rows, cols = well_info['rows'], well_info['columns']\n        used_wells = [well for well in self.metadata['wells']]\n\n        well_matrix = []\n        for row_id in rows:\n            row = ''\n            for col_id in cols:\n                well_id = f'{row_id}{col_id}'\n                row += '+' if well_id in used_wells else ' '\n            well_matrix.append(row)\n\n        header = ' '.join([pad_leading_zero(col) for col in cols])\n        s += ' ' + header + '\\n'\n        for idx, row in enumerate(well_matrix):\n            s += f'{rows[idx]} ' + '  '.join(row) + '\\n'\n        return s\n\n    def print_timepoint_well_matrix(self):\n        \"\"\"\n        Returns a string representation of the timepoint-well matrix.\n\n        Returns:\n            str: Timepoint-well matrix.\n        \"\"\"\n        s = ''\n\n        time_points = self.metadata['time_points']\n        wells = [well for well in self.metadata['wells']]\n\n        well_matrix = []\n        for timepoint in time_points:\n            wells_at_timepoint = self.db.fetch_all('''\n                SELECT DISTINCT Well.Name FROM SourceImageBase\n                JOIN Well ON SourceImageBase.ZoneIndex = Well.ZoneIndex\n                WHERE TimeSeriesElementId = ?\n            ''', (timepoint,), return_dicts=False)\n\n            row = ['+' if well in wells_at_timepoint else ' ' for well in wells]\n            well_matrix.append(row)\n\n        header = ' '.join([pad_leading_zero(well) for well in wells])\n        s += 'Timepoint ' + header + '\\n'\n        for idx, row in enumerate(well_matrix):\n            s += f'{time_points[idx]:9}  ' + '   '.join(row) + '\\n'\n        return s\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        self.db.close()\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.data","title":"<code>data = None</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageDbSource.ImageDbSource.data_well_id","title":"<code>data_well_id = None</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageDbSource.ImageDbSource.db","title":"<code>db = DBReader(self.uri)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageDbSource.ImageDbSource.dim_order","title":"<code>dim_order = 'tczyx'</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageDbSource.ImageDbSource.__init__","title":"<code>__init__(uri, metadata={})</code>","text":"<p>Initialize ImageDbSource.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>Path to the database file.</p> required <code>metadata</code> <code>dict</code> <p>Optional metadata dictionary.</p> <code>{}</code> Source code in <code>src/ImageDbSource.py</code> <pre><code>def __init__(self, uri, metadata={}):\n    \"\"\"\n    Initialize ImageDbSource.\n\n    Args:\n        uri (str): Path to the database file.\n        metadata (dict): Optional metadata dictionary.\n    \"\"\"\n    super().__init__(uri, metadata)\n    self.db = DBReader(self.uri)\n    self.data = None\n    self.data_well_id = None\n    self.dim_order = 'tczyx'\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.close","title":"<code>close()</code>","text":"<p>Closes the database connection.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def close(self):\n    \"\"\"\n    Closes the database connection.\n    \"\"\"\n    self.db.close()\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_acquisitions","title":"<code>get_acquisitions()</code>","text":"<p>Returns acquisition metadata.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of acquisition dicts.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_acquisitions(self):\n    \"\"\"\n    Returns acquisition metadata.\n\n    Returns:\n        list: List of acquisition dicts.\n    \"\"\"\n    acquisitions = []\n    for index, acq in enumerate(self.metadata.get('acquisitions', [])):\n        acquisitions.append({\n            'id': index,\n            'name': acq['Name'],\n            'description': acq['Description'],\n            'date_created': acq['DateCreated'].isoformat(),\n            'date_modified': acq['DateModified'].isoformat()\n        })\n    return acquisitions\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_channels","title":"<code>get_channels()</code>","text":"<p>Returns channel metadata.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of channel dicts.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_channels(self):\n    \"\"\"\n    Returns channel metadata.\n\n    Returns:\n        list: List of channel dicts.\n    \"\"\"\n    channels = []\n    for channel0 in self.metadata['channels']:\n        channel = {}\n        if 'Dye' in channel0 and channel0['Dye']:\n            channel['label'] = channel0['Dye']\n        if 'Color' in channel0:\n            channel['color'] = hexrgb_to_rgba(channel0['Color'].lstrip('#'))\n        channels.append(channel)\n    return channels\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_columns","title":"<code>get_columns()</code>","text":"<p>Returns the list of column identifiers.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Column identifiers.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_columns(self):\n    \"\"\"\n    Returns the list of column identifiers.\n\n    Returns:\n        list: Column identifiers.\n    \"\"\"\n    return self.metadata['well_info']['columns']\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_data","title":"<code>get_data(well_id=None, field_id=None, as_dask=False, **kwargs)</code>","text":"<p>Gets image data for a specific well and field.</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <p>Image data.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_data(self, well_id=None, field_id=None, as_dask=False, **kwargs):\n    \"\"\"\n    Gets image data for a specific well and field.\n\n    Returns:\n        ndarray: Image data.\n    \"\"\"\n    if well_id != self.data_well_id:\n        self._assemble_image_data(self._read_well_info(well_id))\n        self.data_well_id = well_id\n    return self._extract_site(field_id)\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"<p>Returns the dimension order string.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Dimension order.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_dim_order(self):\n    \"\"\"\n    Returns the dimension order string.\n\n    Returns:\n        str: Dimension order.\n    \"\"\"\n    return self.dim_order\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_dtype","title":"<code>get_dtype()</code>","text":"<p>Returns the numpy dtype of the image data.</p> <p>Returns:</p> Name Type Description <code>dtype</code> <p>Numpy dtype.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_dtype(self):\n    \"\"\"\n    Returns the numpy dtype of the image data.\n\n    Returns:\n        dtype: Numpy dtype.\n    \"\"\"\n    return self.dtype\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_fields","title":"<code>get_fields()</code>","text":"<p>Returns the list of field indices.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Field indices.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_fields(self):\n    \"\"\"\n    Returns the list of field indices.\n\n    Returns:\n        list: Field indices.\n    \"\"\"\n    return self.metadata['well_info']['fields']\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_image_window","title":"<code>get_image_window(well_id=None, field_id=None, data=None)</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_image_window(self, well_id=None, field_id=None, data=None):\n    # Assume data is not RGB(A) &amp; uint8\n    window_scanner = WindowScanner()\n    window_scanner.process(data, self.get_dim_order())\n    return window_scanner.get_window()\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_name","title":"<code>get_name()</code>","text":"<p>Gets the experiment or file name.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Name.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_name(self):\n    \"\"\"\n    Gets the experiment or file name.\n\n    Returns:\n        str: Name.\n    \"\"\"\n    name = self.metadata.get('Name')\n    if not name:\n        name = splitall(os.path.splitext(self.uri)[0])[-2]\n    return name\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"<p>Returns the number of channels.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of channels.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_nchannels(self):\n    \"\"\"\n    Returns the number of channels.\n\n    Returns:\n        int: Number of channels.\n    \"\"\"\n    return max(self.metadata['num_channels'], 1)\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"<p>Returns the pixel size in micrometers.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Pixel size for x and y.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_pixel_size_um(self):\n    \"\"\"\n    Returns the pixel size in micrometers.\n\n    Returns:\n        dict: Pixel size for x and y.\n    \"\"\"\n    pixel_size = self.metadata['well_info'].get('PixelSizeUm', 1)\n    return {'x': pixel_size, 'y': pixel_size}\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_position_um","title":"<code>get_position_um(well_id=None)</code>","text":"<p>Returns the position in micrometers for a well.</p> <p>Parameters:</p> Name Type Description Default <code>well_id</code> <code>str</code> <p>Well identifier.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Position in micrometers.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_position_um(self, well_id=None):\n    \"\"\"\n    Returns the position in micrometers for a well.\n\n    Args:\n        well_id (str): Well identifier.\n\n    Returns:\n        dict: Position in micrometers.\n    \"\"\"\n    well = self.metadata['wells'][well_id]\n    well_info = self.metadata['well_info']\n    x = well.get('CoordX', 0) * well_info['max_sizex_um']\n    y = well.get('CoordY', 0) * well_info['max_sizey_um']\n    return {'x': x, 'y': y}\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_rows","title":"<code>get_rows()</code>","text":"<p>Returns the list of row identifiers.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Row identifiers.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_rows(self):\n    \"\"\"\n    Returns the list of row identifiers.\n\n    Returns:\n        list: Row identifiers.\n    \"\"\"\n    return self.metadata['well_info']['rows']\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_shape","title":"<code>get_shape()</code>","text":"<p>Returns the shape of the image data.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Shape of the image data.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_shape(self):\n    \"\"\"\n    Returns the shape of the image data.\n\n    Returns:\n        tuple: Shape of the image data.\n    \"\"\"\n    return self.shape\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_time_points","title":"<code>get_time_points()</code>","text":"<p>Returns the list of time points.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Time point IDs.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_time_points(self):\n    \"\"\"\n    Returns the list of time points.\n\n    Returns:\n        list: Time point IDs.\n    \"\"\"\n    return self.metadata['time_points']\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_total_data_size","title":"<code>get_total_data_size()</code>","text":"<p>Returns the estimated total data size.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Total data size in bytes.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_total_data_size(self):\n    \"\"\"\n    Returns the estimated total data size.\n\n    Returns:\n        int: Total data size in bytes.\n    \"\"\"\n    return self.metadata['max_data_size']\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_wells","title":"<code>get_wells()</code>","text":"<p>Returns the list of well identifiers.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Well identifiers.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_wells(self):\n    \"\"\"\n    Returns the list of well identifiers.\n\n    Returns:\n        list: Well identifiers.\n    \"\"\"\n    return list(self.metadata['wells'])\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.init_metadata","title":"<code>init_metadata()</code>","text":"<p>Initializes and loads metadata from the database.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Metadata dictionary.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def init_metadata(self):\n    \"\"\"\n    Initializes and loads metadata from the database.\n\n    Returns:\n        dict: Metadata dictionary.\n    \"\"\"\n    self._get_time_series_info()\n    self._get_experiment_metadata()\n    self._get_well_info()\n    self._get_image_info()\n    self._get_sizes()\n    return self.metadata\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.is_rgb","title":"<code>is_rgb()</code>","text":"<p>Check if the source is a RGB(A) image.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def is_rgb(self):\n    \"\"\"\n    Check if the source is a RGB(A) image.\n    \"\"\"\n    return False\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.is_screen","title":"<code>is_screen()</code>","text":"<p>Checks if the source is a screen (has wells).</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if wells exist.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def is_screen(self):\n    \"\"\"\n    Checks if the source is a screen (has wells).\n\n    Returns:\n        bool: True if wells exist.\n    \"\"\"\n    return len(self.metadata['wells']) &gt; 0\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.print_timepoint_well_matrix","title":"<code>print_timepoint_well_matrix()</code>","text":"<p>Returns a string representation of the timepoint-well matrix.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Timepoint-well matrix.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def print_timepoint_well_matrix(self):\n    \"\"\"\n    Returns a string representation of the timepoint-well matrix.\n\n    Returns:\n        str: Timepoint-well matrix.\n    \"\"\"\n    s = ''\n\n    time_points = self.metadata['time_points']\n    wells = [well for well in self.metadata['wells']]\n\n    well_matrix = []\n    for timepoint in time_points:\n        wells_at_timepoint = self.db.fetch_all('''\n            SELECT DISTINCT Well.Name FROM SourceImageBase\n            JOIN Well ON SourceImageBase.ZoneIndex = Well.ZoneIndex\n            WHERE TimeSeriesElementId = ?\n        ''', (timepoint,), return_dicts=False)\n\n        row = ['+' if well in wells_at_timepoint else ' ' for well in wells]\n        well_matrix.append(row)\n\n    header = ' '.join([pad_leading_zero(well) for well in wells])\n    s += 'Timepoint ' + header + '\\n'\n    for idx, row in enumerate(well_matrix):\n        s += f'{time_points[idx]:9}  ' + '   '.join(row) + '\\n'\n    return s\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.print_well_matrix","title":"<code>print_well_matrix()</code>","text":"<p>Returns a string representation of the well matrix.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Well matrix.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def print_well_matrix(self):\n    \"\"\"\n    Returns a string representation of the well matrix.\n\n    Returns:\n        str: Well matrix.\n    \"\"\"\n    s = ''\n\n    well_info = self.metadata['well_info']\n    rows, cols = well_info['rows'], well_info['columns']\n    used_wells = [well for well in self.metadata['wells']]\n\n    well_matrix = []\n    for row_id in rows:\n        row = ''\n        for col_id in cols:\n            well_id = f'{row_id}{col_id}'\n            row += '+' if well_id in used_wells else ' '\n        well_matrix.append(row)\n\n    header = ' '.join([pad_leading_zero(col) for col in cols])\n    s += ' ' + header + '\\n'\n    for idx, row in enumerate(well_matrix):\n        s += f'{rows[idx]} ' + '  '.join(row) + '\\n'\n    return s\n</code></pre>"},{"location":"references/#src.ImageDbSource.convert_dotnet_ticks_to_datetime","title":"<code>convert_dotnet_ticks_to_datetime(net_ticks)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def convert_dotnet_ticks_to_datetime(net_ticks):\n    return datetime(1, 1, 1) + timedelta(microseconds=net_ticks // 10)\n</code></pre>"},{"location":"references/#src.ImageDbSource.convert_to_um","title":"<code>convert_to_um(value, unit)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def convert_to_um(value, unit):\n    conversions = {\n        'nm': 1e-3,\n        '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'micron': 1,\n        'mm': 1e3, 'millimeter': 1e3,\n        'cm': 1e4, 'centimeter': 1e4,\n        'm': 1e6, 'meter': 1e6\n    }\n    return value * conversions.get(unit, 1)\n</code></pre>"},{"location":"references/#src.ImageDbSource.ensure_list","title":"<code>ensure_list(item)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def ensure_list(item):\n    if not isinstance(item, (list, tuple)):\n        item = [item]\n    return item\n</code></pre>"},{"location":"references/#src.ImageDbSource.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_filetitle(filename):\n    return os.path.basename(os.path.splitext(filename)[0])\n</code></pre>"},{"location":"references/#src.ImageDbSource.pad_leading_zero","title":"<code>pad_leading_zero(input_string, num_digits=2)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def pad_leading_zero(input_string, num_digits=2):\n    output = str(input_string)\n    is_well = not output[0].isdigit()\n    if is_well:\n        row, col = split_well_name(output, remove_leading_zeros=True)\n        output = str(col)\n    while len(output) &lt; num_digits:\n        output = '0' + output\n    if is_well:\n        output = row + output\n    return output\n</code></pre>"},{"location":"references/#src.ImageDbSource.print_dict","title":"<code>print_dict(value, tab=0, max_len=250, bullet=False)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def print_dict(value, tab=0, max_len=250, bullet=False):\n    s = ''\n    if isinstance(value, dict):\n        for key, subvalue in value.items():\n            s += '\\n'\n            if bullet:\n                s += '-'\n                bullet = False\n            s += '\\t' * tab + str(key) + ': '\n            if isinstance(subvalue, dict):\n                s += print_dict(subvalue, tab+1)\n            elif isinstance(subvalue, list):\n                for v in subvalue:\n                    s += print_dict(v, tab+1, bullet=True)\n            else:\n                subvalue = str(subvalue)\n                if len(subvalue) &gt; max_len:\n                    subvalue = subvalue[:max_len] + '...'\n                s += subvalue\n    else:\n        s += str(value) + ' '\n    return s\n</code></pre>"},{"location":"references/#src.ImageDbSource.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def print_hbytes(nbytes):\n    exps = ['', 'K', 'M', 'G', 'T', 'P', 'E']\n    div = 1024\n    exp = 0\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    if exp &lt; len(exps):\n        e = exps[exp]\n    else:\n        e = f'e{exp * 3}'\n    return f'{nbytes:.1f}{e}B'\n</code></pre>"},{"location":"references/#src.ImageDbSource.redimension_data","title":"<code>redimension_data(data, old_order, new_order, **indices)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def redimension_data(data, old_order, new_order, **indices):\n    # able to provide optional dimension values e.g. t=0, z=0\n    if new_order == old_order:\n        return data\n\n    new_data = data\n    order = old_order\n    # remove\n    for o in old_order:\n        if o not in new_order:\n            index = order.index(o)\n            dim_value = indices.get(o, 0)\n            new_data = np.take(new_data, indices=dim_value, axis=index)\n            order = order[:index] + order[index + 1:]\n    # add\n    for o in new_order:\n        if o not in order:\n            new_data = np.expand_dims(new_data, 0)\n            order = o + order\n    # move\n    old_indices = [order.index(o) for o in new_order]\n    new_indices = list(range(len(new_order)))\n    new_data = np.moveaxis(new_data, old_indices, new_indices)\n    return new_data\n</code></pre>"},{"location":"references/#src.ImageDbSource.split_well_name","title":"<code>split_well_name(well_name, remove_leading_zeros=True, col_as_int=False)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def split_well_name(well_name, remove_leading_zeros=True, col_as_int=False):\n    matches = re.findall(r'(\\D+)(\\d+)', well_name)\n    if len(matches) &gt; 0:\n        row, col = matches[0]\n        if col_as_int or remove_leading_zeros:\n            try:\n                col = int(col)\n            except ValueError:\n                pass\n        if not col_as_int:\n            col = str(col)\n        return row, col\n    else:\n        raise ValueError(f\"Invalid well name format: {well_name}. Expected format like 'A1', 'B2', etc.\")\n</code></pre>"},{"location":"references/#src.ImageDbSource.splitall","title":"<code>splitall(path)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def splitall(path):\n    allparts = []\n    while True:\n        parts = os.path.split(path)\n        if parts[0] == path:  # sentinel for absolute paths\n            allparts.insert(0, parts[0])\n            break\n        elif parts[1] == path: # sentinel for relative paths\n            allparts.insert(0, parts[1])\n            break\n        else:\n            path = parts[0]\n            allparts.insert(0, parts[1])\n    return allparts\n</code></pre>"},{"location":"references/#src.ImageDbSource.strip_leading_zeros","title":"<code>strip_leading_zeros(well_name)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def strip_leading_zeros(well_name):\n    row, col = split_well_name(well_name, remove_leading_zeros=True)\n    return f'{row}{col}'\n</code></pre>"},{"location":"references/#src.ImageDbSource.xml_content_to_dict","title":"<code>xml_content_to_dict(element)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def xml_content_to_dict(element):\n    key = element.tag\n    children = list(element)\n    if key == 'Array':\n        res = [xml_content_to_dict(child) for child in children]\n        return res\n    if len(children) &gt; 0:\n        if children[0].tag == 'Array':\n            value = []\n        else:\n            value = {}\n        for child in children:\n            child_value = xml_content_to_dict(child)\n            if isinstance(child_value, list):\n                value.extend(child_value)\n            else:\n                value |= child_value\n    else:\n        value = element.text\n        if value is not None:\n            if '\"' in value:\n                value = value.replace('\"', '')\n            else:\n                for t in (float, int, bool):\n                    try:\n                        if t == bool:\n                            if value.lower() == 'true':\n                                value = True\n                            if value.lower() == 'false':\n                                value = False\n                        else:\n                            value = t(value)\n                        break\n                    except (TypeError, ValueError):\n                        pass\n\n    if key == 'DataObject':\n        key = element.attrib['ObjectType']\n    if key == 'Attribute':\n        key = element.attrib['Name']\n    return {key: value}\n</code></pre>"},{"location":"references/#src.ImageSource","title":"<code>ImageSource</code>","text":""},{"location":"references/#src.ImageSource.ImageSource","title":"<code>ImageSource</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for image sources.</p> Source code in <code>src/ImageSource.py</code> <pre><code>class ImageSource(ABC):\n    \"\"\"\n    Abstract base class for image sources.\n    \"\"\"\n\n    def __init__(self, uri, metadata={}):\n        \"\"\"\n        Initialize ImageSource.\n\n        Args:\n            uri (str): Path to the image source.\n            metadata (dict): Optional metadata dictionary.\n        \"\"\"\n        self.uri = uri\n        self.metadata = metadata\n\n    def init_metadata(self):\n        \"\"\"\n        Initialize and load metadata.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'init_metadata' method must be implemented by subclasses.\")\n\n    def is_screen(self):\n        \"\"\"\n        Check if the source is a screen (multi-well).\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'is_screen' method must be implemented by subclasses.\")\n\n    def get_shape(self):\n        \"\"\"\n        Get the shape of the image data.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_shape' method must be implemented by subclasses.\")\n\n    def get_data(self, well_id=None, field_id=None, **kwargs):\n        \"\"\"\n        Get image data for a well and field.\n\n        Args:\n            well_id (str, optional): Well identifier\n            field_id (int, optional): Field identifier\n            kwargs (optional): Format specific keyword arguments.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_data' method must be implemented by subclasses.\")\n\n    def get_image_window(self, well_id=None, field_id=None, data=None):\n        \"\"\"\n        Get image value range window (for a well and field).\n\n        Args:\n            well_id (str, optional): Well identifier\n            field_id (int, optional): Field identifier\n            data (ndarray, optional): Image data to compute window from.\n        \"\"\"\n        return [], []\n\n    def get_name(self):\n        \"\"\"\n        Get the name of the image source.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_name' method must be implemented by subclasses.\")\n\n    def get_dim_order(self):\n        \"\"\"\n        Get the dimension order string.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_dim_order' method must be implemented by subclasses.\")\n\n    def get_dtype(self):\n        \"\"\"\n        Get the numpy dtype of the image data.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_dtype' method must be implemented by subclasses.\")\n\n    def get_pixel_size_um(self):\n        \"\"\"\n        Get the pixel size in micrometers.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_pixel_size_um' method must be implemented by subclasses.\")\n\n    def get_position_um(self, well_id=None):\n        \"\"\"\n        Get the position in micrometers for a well.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_position_um' method must be implemented by subclasses.\")\n\n    def get_channels(self):\n        \"\"\"\n        Get channel metadata in NGFF format, color provided as RGBA list with values between 0 and 1\n        e.g. white = [1, 1, 1, 1]\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_channels' method must be implemented by subclasses.\")\n\n    def get_nchannels(self):\n        \"\"\"\n        Get the number of channels.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_nchannels' method must be implemented by subclasses.\")\n\n    def is_rgb(self):\n        \"\"\"\n        Check if the source is a RGB(A) image.\n        \"\"\"\n        raise NotImplementedError(\"The 'is_rgb' method must be implemented by subclasses.\")\n\n    def get_rows(self):\n        \"\"\"\n        Get the list of row identifiers.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_rows' method must be implemented by subclasses.\")\n\n    def get_columns(self):\n        \"\"\"\n        Get the list of column identifiers.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_columns' method must be implemented by subclasses.\")\n\n    def get_wells(self):\n        \"\"\"\n        Get the list of well identifiers.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_wells' method must be implemented by subclasses.\")\n\n    def get_time_points(self):\n        \"\"\"\n        Get the list of time points.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_time_points' method must be implemented by subclasses.\")\n\n    def get_fields(self):\n        \"\"\"\n        Get the list of field indices.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_fields' method must be implemented by subclasses.\")\n\n    def get_acquisitions(self):\n        \"\"\"\n        Get acquisition metadata.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_acquisitions' method must be implemented by subclasses.\")\n\n    def get_total_data_size(self):\n        \"\"\"\n        Get the estimated total data size.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_total_data_size' method must be implemented by subclasses.\")\n\n    def close(self):\n        \"\"\"\n        Close the image source.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.metadata","title":"<code>metadata = metadata</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageSource.ImageSource.uri","title":"<code>uri = uri</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageSource.ImageSource.__init__","title":"<code>__init__(uri, metadata={})</code>","text":"<p>Initialize ImageSource.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>Path to the image source.</p> required <code>metadata</code> <code>dict</code> <p>Optional metadata dictionary.</p> <code>{}</code> Source code in <code>src/ImageSource.py</code> <pre><code>def __init__(self, uri, metadata={}):\n    \"\"\"\n    Initialize ImageSource.\n\n    Args:\n        uri (str): Path to the image source.\n        metadata (dict): Optional metadata dictionary.\n    \"\"\"\n    self.uri = uri\n    self.metadata = metadata\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.close","title":"<code>close()</code>","text":"<p>Close the image source.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def close(self):\n    \"\"\"\n    Close the image source.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_acquisitions","title":"<code>get_acquisitions()</code>","text":"<p>Get acquisition metadata.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_acquisitions(self):\n    \"\"\"\n    Get acquisition metadata.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_acquisitions' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_channels","title":"<code>get_channels()</code>","text":"<p>Get channel metadata in NGFF format, color provided as RGBA list with values between 0 and 1 e.g. white = [1, 1, 1, 1]</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_channels(self):\n    \"\"\"\n    Get channel metadata in NGFF format, color provided as RGBA list with values between 0 and 1\n    e.g. white = [1, 1, 1, 1]\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_channels' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_columns","title":"<code>get_columns()</code>","text":"<p>Get the list of column identifiers.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_columns(self):\n    \"\"\"\n    Get the list of column identifiers.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_columns' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_data","title":"<code>get_data(well_id=None, field_id=None, **kwargs)</code>","text":"<p>Get image data for a well and field.</p> <p>Parameters:</p> Name Type Description Default <code>well_id</code> <code>str</code> <p>Well identifier</p> <code>None</code> <code>field_id</code> <code>int</code> <p>Field identifier</p> <code>None</code> <code>kwargs</code> <code>optional</code> <p>Format specific keyword arguments.</p> <code>{}</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_data(self, well_id=None, field_id=None, **kwargs):\n    \"\"\"\n    Get image data for a well and field.\n\n    Args:\n        well_id (str, optional): Well identifier\n        field_id (int, optional): Field identifier\n        kwargs (optional): Format specific keyword arguments.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_data' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"<p>Get the dimension order string.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_dim_order(self):\n    \"\"\"\n    Get the dimension order string.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_dim_order' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_dtype","title":"<code>get_dtype()</code>","text":"<p>Get the numpy dtype of the image data.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_dtype(self):\n    \"\"\"\n    Get the numpy dtype of the image data.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_dtype' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_fields","title":"<code>get_fields()</code>","text":"<p>Get the list of field indices.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_fields(self):\n    \"\"\"\n    Get the list of field indices.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_fields' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_image_window","title":"<code>get_image_window(well_id=None, field_id=None, data=None)</code>","text":"<p>Get image value range window (for a well and field).</p> <p>Parameters:</p> Name Type Description Default <code>well_id</code> <code>str</code> <p>Well identifier</p> <code>None</code> <code>field_id</code> <code>int</code> <p>Field identifier</p> <code>None</code> <code>data</code> <code>ndarray</code> <p>Image data to compute window from.</p> <code>None</code> Source code in <code>src/ImageSource.py</code> <pre><code>def get_image_window(self, well_id=None, field_id=None, data=None):\n    \"\"\"\n    Get image value range window (for a well and field).\n\n    Args:\n        well_id (str, optional): Well identifier\n        field_id (int, optional): Field identifier\n        data (ndarray, optional): Image data to compute window from.\n    \"\"\"\n    return [], []\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_name","title":"<code>get_name()</code>","text":"<p>Get the name of the image source.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_name(self):\n    \"\"\"\n    Get the name of the image source.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_name' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"<p>Get the number of channels.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_nchannels(self):\n    \"\"\"\n    Get the number of channels.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_nchannels' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"<p>Get the pixel size in micrometers.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_pixel_size_um(self):\n    \"\"\"\n    Get the pixel size in micrometers.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_pixel_size_um' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_position_um","title":"<code>get_position_um(well_id=None)</code>","text":"<p>Get the position in micrometers for a well.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_position_um(self, well_id=None):\n    \"\"\"\n    Get the position in micrometers for a well.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_position_um' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_rows","title":"<code>get_rows()</code>","text":"<p>Get the list of row identifiers.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_rows(self):\n    \"\"\"\n    Get the list of row identifiers.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_rows' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_shape","title":"<code>get_shape()</code>","text":"<p>Get the shape of the image data.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_shape(self):\n    \"\"\"\n    Get the shape of the image data.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_shape' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_time_points","title":"<code>get_time_points()</code>","text":"<p>Get the list of time points.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_time_points(self):\n    \"\"\"\n    Get the list of time points.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_time_points' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_total_data_size","title":"<code>get_total_data_size()</code>","text":"<p>Get the estimated total data size.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_total_data_size(self):\n    \"\"\"\n    Get the estimated total data size.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_total_data_size' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_wells","title":"<code>get_wells()</code>","text":"<p>Get the list of well identifiers.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_wells(self):\n    \"\"\"\n    Get the list of well identifiers.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_wells' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.init_metadata","title":"<code>init_metadata()</code>","text":"<p>Initialize and load metadata.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def init_metadata(self):\n    \"\"\"\n    Initialize and load metadata.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'init_metadata' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.is_rgb","title":"<code>is_rgb()</code>","text":"<p>Check if the source is a RGB(A) image.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def is_rgb(self):\n    \"\"\"\n    Check if the source is a RGB(A) image.\n    \"\"\"\n    raise NotImplementedError(\"The 'is_rgb' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.is_screen","title":"<code>is_screen()</code>","text":"<p>Check if the source is a screen (multi-well).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def is_screen(self):\n    \"\"\"\n    Check if the source is a screen (multi-well).\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'is_screen' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.IncucyteSource","title":"<code>IncucyteSource</code>","text":""},{"location":"references/#src.IncucyteSource.IncucyteSource","title":"<code>IncucyteSource</code>","text":"<p>               Bases: <code>ImageSource</code></p> <p>ImageSource implementation for Incucyte data</p> <p>Handles the specific directory structure: EssenFiles/ScanData/YYMM/DD/HHMM/XXXX/*.tif</p> <p>Filenames follow pattern: WELL-FIELD-CHANNEL.tif e.g., A1-1-C1.tif, B2-1-Ph.tif</p> <p>Note: Multiple plates can exist in the same archive, identified by the XXXX folder. Use plate_id parameter to select a specific plate, or use get_available_plates()  to discover all plates in the archive.</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>class IncucyteSource(ImageSource):\n    \"\"\"\n    ImageSource implementation for Incucyte data\n\n    Handles the specific directory structure:\n    EssenFiles/ScanData/YYMM/DD/HHMM/XXXX/*.tif\n\n    Filenames follow pattern: WELL-FIELD-CHANNEL.tif\n    e.g., A1-1-C1.tif, B2-1-Ph.tif\n\n    Note: Multiple plates can exist in the same archive, identified by the XXXX folder.\n    Use plate_id parameter to select a specific plate, or use get_available_plates() \n    to discover all plates in the archive.\n    \"\"\"\n\n    def __init__(self, uri, metadata={}, plate_id=None):\n        \"\"\"\n        Initialize IncucyteSource.\n\n        Args:\n            uri (str): Path to the Incucyte archive folder\n            metadata (dict): Optional metadata dictionary\n            plate_id (str, optional): Specific plate ID to process (e.g., '700', '701').\n                                     If None, will use the first available plate or all \n                                     if only one exists.\n        \"\"\"\n        super().__init__(uri, metadata)\n        self.base_path = Path(self.uri)\n        self.scan_data_path = self.base_path / \"EssenFiles\" / \"ScanData\"\n        self._file_cache = {}\n        self._diag_metadata_cache = None  # Cache for Diag.log parsing\n        self._sample_image_info_cache = None  # Cache for sample image info\n        # Default to True for filling missing images\n        self.fill_missing_images = True\n        self.plate_id = plate_id\n\n    @staticmethod\n    def get_available_plates(uri):\n        \"\"\"\n        Discover all available plate IDs in an Incucyte archive.\n\n        Args:\n            uri (str): Path to the Incucyte archive folder\n\n        Returns:\n            list: List of plate IDs (strings) found in the archive\n        \"\"\"\n        base_path = Path(uri)\n        scan_data_path = base_path / \"EssenFiles\" / \"ScanData\"\n\n        if not scan_data_path.exists():\n            raise ValueError(f\"Scan data path not found: {scan_data_path}\")\n\n        plate_ids = set()\n\n        # Navigate through the directory structure to find all plate IDs\n        for year_month in scan_data_path.iterdir():\n            if not year_month.is_dir():\n                continue\n            for day in year_month.iterdir():\n                if not day.is_dir():\n                    continue\n                for time_dir in day.iterdir():\n                    if not time_dir.is_dir():\n                        continue\n                    for plate_dir in time_dir.iterdir():\n                        if plate_dir.is_dir():\n                            plate_ids.add(plate_dir.name)\n\n        return sorted(list(plate_ids))\n\n    def _parse_diag_log(self, diag_zip_path):\n        \"\"\"\n        Parse Diag.log from a Diag.zip file to extract imaging metadata.\n\n        Args:\n            diag_zip_path (Path): Path to Diag.zip file\n\n        Returns:\n            dict: Dictionary with 'pixel_sizes' (dict of mag-&gt;size),\n                  'experiments' (dict of expid-&gt;metadata), or None if failed\n        \"\"\"\n        import zipfile\n        import tempfile\n\n        try:\n            with tempfile.TemporaryDirectory() as temp_dir:\n                with zipfile.ZipFile(diag_zip_path, 'r') as zip_ref:\n                    zip_ref.extractall(temp_dir)\n                    diag_log_path = Path(temp_dir) / \"Diag.log\"\n\n                    if not diag_log_path.exists():\n                        return None\n\n                    with open(diag_log_path, 'r', encoding='utf-8', \n                              errors='ignore') as f:\n                        content = f.read()\n\n                    # Parse imaging specifications\n                    pixel_sizes = {}\n                    mag_pattern = r'(\\d+)x:\\s+.*?Image Resolution:\\s+([\\d.]+)\\s+microns/pixel'\n                    for match in re.finditer(mag_pattern, content, re.DOTALL):\n                        mag = match.group(1) + 'x'\n                        pixel_size = float(match.group(2))\n                        pixel_sizes[mag] = pixel_size\n\n                    # Parse experiment entries\n                    experiments = {}\n                    # Match ExpID and capture next 2 lines for Lmp info\n                    exp_pattern = r'ExpID=(\\d+)[^\\n]*Mag=(\\d+x)[^\\n]*(?:\\n[^\\n]*)?'\n                    for match in re.finditer(exp_pattern, content):\n                        exp_id = match.group(1)\n                        mag = match.group(2)\n\n                        # Extract all exposure times from matched section\n                        exp_section = match.group(0)\n                        acq_times = re.findall(r'AcqTime=(\\d+)', exp_section)\n\n                        experiments[exp_id] = {\n                            'magnification': mag,\n                            'exposure_times_ms': [int(t) for t in acq_times] if acq_times else None,\n                            'pixel_size_um': pixel_sizes.get(mag)\n                        }\n\n                    return {\n                        'pixel_sizes': pixel_sizes,\n                        'experiments': experiments\n                    }\n        except Exception as e:\n            print(f\"Warning: Could not parse Diag.log from {diag_zip_path}: {e}\")\n            return None\n\n    def _find_and_parse_diag_log(self):\n        \"\"\"\n        Find the first Diag.zip in the scan data and parse it.\n        Caches the result to avoid repeated parsing.\n\n        Returns:\n            dict: Parsed diag metadata or None if not found\n        \"\"\"\n        # Return cached result if available\n        if self._diag_metadata_cache is not None:\n            return self._diag_metadata_cache\n\n        # Look for first Diag.zip in the scan data\n        diag_zip_files = list(self.scan_data_path.rglob(\"Diag.zip\"))\n\n        if diag_zip_files:\n            self._diag_metadata_cache = self._parse_diag_log(diag_zip_files[0])\n        else:\n            self._diag_metadata_cache = {}  # Cache empty dict to avoid re-search\n\n        return self._diag_metadata_cache if self._diag_metadata_cache else None\n\n    def init_metadata(self):\n        \"\"\"Initialize all metadata from Incucyte structure\"\"\"\n        self._scan_timepoints()  # Must be first to set plate_id\n        self._get_experiment_metadata()  # Uses plate_id in name\n        self._get_well_info()\n        self._get_channel_info()\n        self._get_image_info()\n\n        # Initialize properties like TiffSource does\n        self.name = self.metadata.get(\"Name\", \"Incucyte_Experiment\")\n        self.dim_order = self.metadata.get(\"dim_order\", \"tczyx\")\n        self.dtype = self.metadata.get(\"dtype\", np.uint16)\n        self.pixel_size = self._get_pixel_size_dict()\n        self.channels = self._format_channels_for_interface()\n        self.is_plate = len(self.metadata.get(\"wells\", {})) &gt; 0\n        self.wells = list(self.metadata.get(\"wells\", {}).keys())\n        self.rows = self.metadata.get(\"well_info\", {}).get(\"rows\", [])\n        self.columns = self.metadata.get(\"well_info\", {}).get(\"columns\", [])\n\n        return self.metadata\n\n    def _get_experiment_metadata(self):\n        \"\"\"Extract experiment metadata from folder structure\"\"\"\n        experiment_name = self.base_path.name\n\n        # Add plate ID to name (plate_id is set by _scan_timepoints)\n        if self.plate_id:\n            experiment_name = f\"{experiment_name}_plate{self.plate_id}\"\n\n        self.metadata.update(\n            {\n                \"Name\": experiment_name,\n                \"Creator\": \"Incucyte\",\n                \"DateCreated\": datetime.now(),\n                \"dim_order\": \"tczyx\",\n            }\n        )\n\n    def _scan_timepoints(self):\n        \"\"\"Scan the Incucyte directory structure for timepoints\"\"\"\n        timepoints = []\n        wells = set()\n        fields = set()\n        channels = set()\n        found_plate_ids = set()\n\n        print(f\"Scanning directory: {self.scan_data_path}\")\n\n        if not self.scan_data_path.exists():\n            raise ValueError(\n                f\"Scan data path not found: {self.scan_data_path}\"\n            )\n\n        # Navigate through year/month directories (YYMM)\n        for year_month in self.scan_data_path.iterdir():\n            if not year_month.is_dir():\n                continue\n            # Navigate through day directories (DD)\n            for day in year_month.iterdir():\n                if not day.is_dir():\n                    continue\n                # Navigate through time directories (HHMM)\n                for time_dir in day.iterdir():\n                    if not time_dir.is_dir():\n                        continue\n                    # Navigate through plate ID directories (XXXX)\n                    for plate_dir in time_dir.iterdir():\n                        if not plate_dir.is_dir():\n                            continue\n\n                        current_plate_id = plate_dir.name\n                        found_plate_ids.add(current_plate_id)\n\n                        # Filter by plate_id if specified\n                        if self.plate_id is not None:\n                            if current_plate_id != self.plate_id:\n                                continue\n\n                        timepoint_path = plate_dir\n                        timestamp = (\n                            f\"{year_month.name}_{day.name}_{time_dir.name}\"\n                        )\n\n                        # Parse timestamp to datetime\n                        try:\n                            dt = datetime.strptime(timestamp, \"%y%m_%d_%H%M\")\n                            if dt.year &lt; 2000:\n                                dt = dt.replace(year=dt.year + 2000)\n                        except ValueError:\n                            dt = None\n\n                        timepoint_info = {\n                            \"path\": timepoint_path,\n                            \"timestamp\": timestamp,\n                            \"datetime\": dt,\n                            \"index\": len(timepoints),\n                            \"plate_id\": current_plate_id,\n                        }\n                        timepoints.append(timepoint_info)\n\n                        # Scan TIFF files in this timepoint\n                        for tiff_file in timepoint_path.glob(\"*.tif\"):\n                            parsed = self._parse_filename(tiff_file.name)\n                            well, field, channel = parsed\n                            if well and field is not None and channel:\n                                wells.add(well)\n                                fields.add(field)\n                                channels.add(channel)\n\n        # Handle plate selection\n        if self.plate_id is None:\n            # Auto-select plate\n            if len(found_plate_ids) == 0:\n                raise ValueError(\"No plates found in the archive\")\n            elif len(found_plate_ids) == 1:\n                # Single plate - use it automatically\n                self.plate_id = list(found_plate_ids)[0]\n            else:\n                # Multiple plates - use first with warning\n                plate_list = \", \".join(sorted(found_plate_ids))\n                print(\n                    f\"Warning: Multiple plates found ({plate_list}). \"\n                    f\"Using first plate: {sorted(found_plate_ids)[0]}\"\n                )\n                print(\n                    \"To process a specific plate, use: \"\n                    \"IncucyteSource(uri, plate_id='XXX')\"\n                )\n                print(\n                    \"To process all plates, call get_available_plates() \"\n                    \"and create separate sources\"\n                )\n                self.plate_id = sorted(found_plate_ids)[0]\n\n            # Filter timepoints to selected plate\n            timepoints = [\n                tp for tp in timepoints if tp[\"plate_id\"] == self.plate_id\n            ]\n        else:\n            # Validate specified plate_id\n            if self.plate_id not in found_plate_ids:\n                raise ValueError(\n                    f\"Plate ID '{self.plate_id}' not found. \"\n                    f\"Available plates: {', '.join(sorted(found_plate_ids))}\"\n                )\n            # Filter timepoints to specified plate\n            timepoints = [\n                tp for tp in timepoints if tp[\"plate_id\"] == self.plate_id\n            ]\n\n        # Store found plate IDs in metadata\n        self.metadata[\"available_plates\"] = sorted(found_plate_ids)\n        self.metadata[\"selected_plate\"] = self.plate_id\n\n        # Sort timepoints by datetime if available, otherwise by timestamp\n        timepoints.sort(\n            key=lambda x: x[\"datetime\"] if x[\"datetime\"] else x[\"timestamp\"]\n        )\n\n        # Update indices after sorting\n        for i, tp in enumerate(timepoints):\n            tp[\"index\"] = i\n\n        self.metadata.update(\n            {\n                \"timepoints\": timepoints,\n                \"time_points\": [tp[\"index\"] for tp in timepoints],\n                \"wells_raw\": sorted(wells),\n                \"fields_raw\": sorted(fields),\n                \"channels_raw\": sorted(channels),\n            }\n        )\n\n        plate_info = (\n            f\" (plate: {self.plate_id})\" if self.plate_id else \"\"\n        )\n        print(\n            f\"Found{plate_info}: {len(timepoints)} timepoints, \"\n            f\"{len(wells)} wells, {len(fields)} fields, \"\n            f\"{len(channels)} channels\"\n        )\n\n    def _parse_filename(self, filename):\n        \"\"\"\n        Parse Incucyte filename format: WELL-FIELD-CHANNEL.tif\n        Examples: A1-1-C1.tif, B2-1-Ph.tif\n        Returns: (well, field, channel)\n        \"\"\"\n        pattern = r\"([A-Z]\\d+)-(\\d+)-(.+)\\.tif\"\n        match = re.match(pattern, filename)\n        if match:\n            well = match.group(1)\n            field = int(match.group(2)) - 1  # Convert to 0-based indexing\n            channel = match.group(3)\n            return well, field, channel\n        return None, None, None\n\n    def _get_well_info(self):\n        \"\"\"Process well information and determine plate layout\"\"\"\n        wells_raw = self.metadata[\"wells_raw\"]\n\n        if not wells_raw:\n            raise ValueError(\"No wells found in data\")\n\n        # Parse well positions\n        rows = set()\n        cols = set()\n        wells_dict = {}\n\n        for well_name in wells_raw:\n            row_letter = well_name[0]\n            col_number = int(well_name[1:])\n\n            rows.add(row_letter)\n            cols.add(col_number)\n\n            wells_dict[well_name] = {\n                \"Name\": well_name,\n                \"row\": ord(row_letter) - ord(\"A\"),\n                \"column\": col_number - 1,\n                \"ZoneIndex\": len(wells_dict),\n            }\n\n        rows = sorted(rows)\n        cols = sorted(cols)\n\n        # Get image dimensions from first available image\n        sample_image_info = self._get_sample_image_info()\n\n        well_info = {\n            \"rows\": rows,\n            \"columns\": [str(c) for c in cols],\n            \"SensorSizeXPixels\": sample_image_info[\"width\"],\n            \"SensorSizeYPixels\": sample_image_info[\"height\"],\n            \"SitesX\": 1,\n            \"SitesY\": 1,\n            \"num_sites\": len(self.metadata[\"fields_raw\"]),\n            \"fields\": [str(f) for f in self.metadata[\"fields_raw\"]],\n            \"PixelSizeUm\": sample_image_info[\"pixel_x\"],\n            \"SensorBitness\": sample_image_info[\"bits\"],\n            \"max_sizex_um\": sample_image_info[\"width\"] * sample_image_info[\"pixel_x\"],\n            \"max_sizey_um\": sample_image_info[\"height\"] * sample_image_info[\"pixel_y\"],\n        }\n\n        # Add optional imaging metadata if available\n        if \"magnification\" in sample_image_info:\n            well_info[\"Magnification\"] = sample_image_info[\"magnification\"]\n        if \"exposure_times_ms\" in sample_image_info:\n            well_info[\"ExposureTimes_ms\"] = sample_image_info[\"exposure_times_ms\"]\n\n        self.metadata.update({\"wells\": wells_dict, \"well_info\": well_info})\n\n    def _get_sample_image_info(self):\n        \"\"\"Get image dimensions and bit depth from first available TIFF.\n        Attempts to get accurate pixel size from Diag.log if available.\n        Caches the result to avoid repeated parsing.\"\"\"\n\n        # Return cached result if available\n        if self._sample_image_info_cache is not None:\n            return self._sample_image_info_cache\n\n        # Try to get calibrated pixel size from Diag.log\n        diag_metadata = None\n        pixel_size_from_diag = None\n        magnification = None\n        exposure_time = None\n\n        if self.plate_id:\n            diag_metadata = self._find_and_parse_diag_log()\n            if diag_metadata and 'experiments' in diag_metadata:\n                exp_info = diag_metadata['experiments'].get(self.plate_id)\n                if exp_info:\n                    pixel_size_from_diag = exp_info.get('pixel_size_um')\n                    magnification = exp_info.get('magnification')\n                    exposure_times = exp_info.get('exposure_times_ms')\n                    # Use the exposure times list if available\n                    exposure_time = exposure_times\n                    if pixel_size_from_diag:\n                        print(f\"Found calibrated pixel size from Diag.log: \"\n                              f\"{pixel_size_from_diag} \u00b5m/pixel \"\n                              f\"(Magnification: {magnification})\")\n\n        for timepoint in self.metadata[\"timepoints\"]:\n            for tiff_file in timepoint[\"path\"].glob(\"*.tif\"):\n                try:\n                    # Get actual image dimensions from the file\n                    with tifffile.TiffFile(str(tiff_file)) as tif:\n                        page = tif.pages[0]\n                        array = page.asarray()\n\n                    # Use calibrated pixel size from Diag.log if available\n                    if pixel_size_from_diag:\n                        pixel_x = pixel_size_from_diag\n                        pixel_y = pixel_size_from_diag\n                    else:\n                        # Fallback to TIFF metadata\n                        temp_tiff_source = TiffSource(str(tiff_file))\n                        temp_tiff_source.init_metadata()\n                        pixel_size = temp_tiff_source.get_pixel_size_um()\n                        temp_tiff_source.close()\n                        pixel_x = pixel_size.get(\"x\", None)\n                        pixel_y = pixel_size.get(\"y\", None)\n\n                    result = {\n                        \"width\": array.shape[1],\n                        \"height\": array.shape[0],\n                        \"bits\": array.dtype.itemsize * 8,\n                        \"dtype\": array.dtype,\n                        \"pixel_x\": pixel_x,\n                        \"pixel_y\": pixel_y,\n                    }\n\n                    # Add optional metadata if available\n                    if magnification:\n                        result[\"magnification\"] = magnification\n                    if exposure_time:\n                        result[\"exposure_times_ms\"] = exposure_time\n\n                    # Cache the result\n                    self._sample_image_info_cache = result\n                    return result\n\n                except Exception as e:\n                    print(f\"Could not read sample image {tiff_file}: {e}\")\n                    continue\n\n        # If no valid TIFF files found\n        raise ValueError(\n            f\"No valid TIFF files found in experiment directory: \"\n            f\"{self.scan_data_path}\"\n        )\n\n    def _get_channel_info(self):\n        \"\"\"Process channel information\"\"\"\n        channels_raw = self.metadata[\"channels_raw\"]\n        channels = []\n\n        channel_mapping = {\n            \"C1\": {\"label\": \"Green\", \"color\": \"00FF00\"},\n            \"C2\": {\"label\": \"Red\", \"color\": \"FF0000\"},\n            \"Ph\": {\"label\": \"Phase_Contrast\", \"color\": \"FFFFFF\"},\n            \"P\": {\"label\": \"Phase_Contrast\", \"color\": \"FFFFFF\"},\n        }\n\n        for i, channel_code in enumerate(channels_raw):\n            channel_info = channel_mapping.get(\n                channel_code, {\"label\": channel_code, \"color\": \"FFFFFF\"}\n            )\n\n            channels.append(\n                {\n                    \"ChannelNumber\": i,\n                    \"Dye\": channel_info[\"label\"],\n                    \"Color\": f\"#{channel_info['color']}\",\n                    \"Emission\": None,\n                    \"Excitation\": None,\n                    \"code\": channel_code,\n                }\n            )\n\n        self.metadata.update({\"channels\": channels, \"num_channels\": len(channels)})\n\n    def _get_image_info(self):\n        \"\"\"Get image-related metadata\"\"\"\n        sample_info = self._get_sample_image_info()\n\n        well_info = self.metadata[\"well_info\"]\n        max_data_size = (\n            well_info[\"SensorSizeXPixels\"]\n            * well_info[\"SensorSizeYPixels\"]\n            * len(self.metadata[\"wells\"])\n            * well_info[\"num_sites\"]\n            * self.metadata[\"num_channels\"]\n            * len(self.metadata[\"time_points\"])\n            * (sample_info[\"bits\"] // 8)\n        )\n\n        self.metadata.update(\n            {\n                \"bits_per_pixel\": sample_info[\"bits\"],\n                \"dtype\": sample_info[\"dtype\"],\n                \"max_data_size\": max_data_size,\n            }\n        )\n\n    def _get_pixel_size_dict(self):\n        \"\"\"Get pixel size in TiffSource format\"\"\"\n        well_info = self.metadata.get(\"well_info\", {})\n        pixel_size = well_info.get(\"PixelSizeUm\", 1.0)\n        return {\"x\": pixel_size, \"y\": pixel_size}\n\n    def _format_channels_for_interface(self):\n        \"\"\"Format channels for interface compatibility\"\"\"\n        channels = self.metadata.get(\"channels\", [])\n        return [\n            {\"label\": ch[\"Dye\"], \"color\": ch[\"Color\"].lstrip(\"#\")} for ch in channels\n        ]\n\n    def _load_image_data(self, well_id, field_id, channel_id, timepoint_id):\n        \"\"\"Load specific image data\"\"\"\n        cache_key = (well_id, field_id, channel_id, timepoint_id)\n        if cache_key in self._file_cache:\n            return self._file_cache[cache_key]\n\n        # Find the file for this combination\n        timepoint_info = self.metadata[\"timepoints\"][timepoint_id]\n        channel_code = self.metadata[\"channels_raw\"][channel_id]\n\n        filename = f\"{well_id}-{field_id + 1}-{channel_code}.tif\"\n        file_path = timepoint_info[\"path\"] / filename\n\n        # Check if file exists\n        if not file_path.exists():\n            if self.fill_missing_images:\n                # Create a black image with the same dimensions as other images\n                sample_info = self._get_sample_image_info()\n                black_image = np.zeros((sample_info[\"height\"], sample_info[\"width\"]), \n                                     dtype=sample_info[\"dtype\"])\n                self._file_cache[cache_key] = black_image\n                print(f\"Warning: Missing image file {file_path}, filled with black image\")\n                return black_image\n            else:\n                raise FileNotFoundError(f\"Image file not found: {file_path}\")\n\n        try:\n            # Let TiffFile handle the file reading errors naturally\n            with tifffile.TiffFile(str(file_path)) as tif:\n                page = tif.pages[0]\n                data = page.asarray()\n                self._file_cache[cache_key] = data\n                return data\n        except Exception as e:\n            if self.fill_missing_images:\n                # If file exists but can't be read, also fill with black image\n                sample_info = self._get_sample_image_info()\n                black_image = np.zeros((sample_info[\"height\"], sample_info[\"width\"]), \n                                     dtype=sample_info[\"dtype\"])\n                self._file_cache[cache_key] = black_image\n                print(f\"Warning: Could not read image file {file_path}: {e}, filled with black image\")\n                return black_image\n            else:\n                raise e\n\n    # ImageSource interface methods\n    def is_screen(self):\n        return self.is_plate\n\n    def get_data(self, well_id, field_id):\n        \"\"\"Get data for a specific well and field\"\"\"\n        well_id = strip_leading_zeros(well_id)\n\n        if well_id not in self.metadata[\"wells\"]:\n            raise ValueError(\n                f\"Invalid Well: {well_id}. Available: {list(self.metadata['wells'].keys())}\"\n            )\n\n        field_id = int(field_id)\n        if field_id not in self.metadata[\"fields_raw\"]:\n            raise ValueError(\n                f\"Invalid Field: {field_id}. Available: {self.metadata['fields_raw']}\"\n            )\n\n        # Build 5D array: (t, c, z, y, x)\n        nt = len(self.metadata[\"time_points\"])\n        nc = self.metadata[\"num_channels\"]\n        sample_info = self._get_sample_image_info()\n        ny, nx = sample_info[\"height\"], sample_info[\"width\"]\n        nz = 1  # Incucyte is typically 2D\n\n        data = np.zeros((nt, nc, nz, ny, nx), dtype=sample_info[\"dtype\"])\n\n        for t in range(nt):\n            for c in range(nc):\n                image_data = self._load_image_data(well_id, field_id, c, t)\n                # Handle different image shapes\n                if len(image_data.shape) == 2:\n                    data[t, c, 0, :, :] = image_data\n                elif len(image_data.shape) == 3 and image_data.shape[0] == 1:\n                    data[t, c, 0, :, :] = image_data[0]\n                else:\n                    # Take first z-plane if 3D\n                    data[t, c, 0, :, :] = (\n                        image_data[..., 0] if len(image_data.shape) &gt; 2 else image_data\n                    )\n\n        return data\n\n    def get_name(self):\n        return self.name\n\n    def get_dim_order(self):\n        return self.dim_order\n\n    def get_dtype(self):\n        return self.dtype\n\n    def get_pixel_size_um(self):\n        return self.pixel_size\n\n    def get_position_um(self, well_id=None):\n        well = self.metadata[\"wells\"].get(well_id, {})\n        well_info = self.metadata[\"well_info\"]\n        x = well.get(\"CoordX\", 0) * well_info.get(\"max_sizex_um\", 0)\n        y = well.get(\"CoordY\", 0) * well_info.get(\"max_sizey_um\", 0)\n        return {\"x\": x, \"y\": y}\n\n    def get_channels(self):\n        return self.channels\n\n    def get_nchannels(self):\n        return max(self.metadata.get(\"num_channels\", 1), 1)\n\n    def get_rows(self):\n        return self.rows\n\n    def get_columns(self):\n        return self.columns\n\n    def get_wells(self):\n        return self.wells\n\n    def get_time_points(self):\n        return self.metadata.get(\"time_points\", [])\n\n    def get_fields(self):\n        return self.metadata.get(\"well_info\", {}).get(\"fields\", [])\n\n    def get_well_coords_um(self, well_id):\n        \"\"\"Get well coordinates (placeholder - Incucyte doesn't typically have stage coordinates)\"\"\"\n        return {\"x\": 0.0, \"y\": 0.0}\n\n    def get_acquisitions(self):\n        \"\"\"Return acquisition information based on timepoints\"\"\"\n        acquisitions = []\n        for i, tp in enumerate(self.metadata.get(\"timepoints\", [])):\n            acq = {\n                \"id\": i,\n                \"name\": f\"Timepoint_{tp['timestamp']}\",\n                \"description\": f\"Incucyte acquisition at {tp['timestamp']}\",\n                \"date_created\": tp[\"datetime\"].isoformat()\n                if tp[\"datetime\"]\n                else tp[\"timestamp\"],\n                \"date_modified\": tp[\"datetime\"].isoformat()\n                if tp[\"datetime\"]\n                else tp[\"timestamp\"],\n            }\n            acquisitions.append(acq)\n        return acquisitions\n\n    def get_total_data_size(self):\n        return self.metadata.get(\"max_data_size\", 0)\n\n    def print_well_matrix(self):\n        \"\"\"Print a visual representation of the plate layout\"\"\"\n        s = \"\"\n        well_info = self.metadata.get(\"well_info\", {})\n        rows = well_info.get(\"rows\", [])\n        cols = [int(c) for c in well_info.get(\"columns\", [])]\n        used_wells = set(self.metadata.get(\"wells\", {}).keys())\n\n        # Header with column numbers\n        header = \"   \" + \"  \".join(f\"{col:2d}\" for col in cols)\n        s += header + \"\\n\"\n\n        # Each row\n        for row_letter in rows:\n            row_line = f\"{row_letter}  \"\n            for col_num in cols:\n                well_id = f\"{row_letter}{col_num}\"\n                row_line += \" + \" if well_id in used_wells else \"   \"\n            s += row_line + \"\\n\"\n\n        return s\n\n    def print_timepoint_well_matrix(self):\n        \"\"\"Print timepoint vs well matrix\"\"\"\n        s = \"\"\n        timepoints = self.metadata.get(\"timepoints\", [])\n        wells = list(self.metadata.get(\"wells\", {}).keys())\n\n        # Header\n        header = \"Timepoint   \" + \"  \".join(f\"{well:&gt;3}\" for well in wells)\n        s += header + \"\\n\"\n\n        # Check which wells have data at each timepoint\n        for tp in timepoints:\n            line = f\"{tp['timestamp']:&gt;9}   \"\n            for well in wells:\n                # Check if any files exist for this well at this timepoint\n                has_data = any(\n                    (tp[\"path\"] / f\"{well}-{field + 1}-{channel}.tif\").exists()\n                    for field in self.metadata.get(\"fields_raw\", [])\n                    for channel in self.metadata.get(\"channels_raw\", [])\n                )\n                line += \" + \" if has_data else \"   \"\n            s += line + \"\\n\"\n\n        return s\n\n    def is_rgb(self):\n        \"\"\"\n        Check if the source is a RGB(A) image.\n        Incucyte data stores channels separately, not as RGB.\n        \"\"\"\n        return False\n\n    def close(self):\n        \"\"\"Clean up resources\"\"\"\n        self._file_cache.clear()\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.base_path","title":"<code>base_path = Path(self.uri)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.IncucyteSource.IncucyteSource.fill_missing_images","title":"<code>fill_missing_images = True</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.IncucyteSource.IncucyteSource.plate_id","title":"<code>plate_id = plate_id</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.IncucyteSource.IncucyteSource.scan_data_path","title":"<code>scan_data_path = self.base_path / 'EssenFiles' / 'ScanData'</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.IncucyteSource.IncucyteSource.__init__","title":"<code>__init__(uri, metadata={}, plate_id=None)</code>","text":"<p>Initialize IncucyteSource.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>Path to the Incucyte archive folder</p> required <code>metadata</code> <code>dict</code> <p>Optional metadata dictionary</p> <code>{}</code> <code>plate_id</code> <code>str</code> <p>Specific plate ID to process (e.g., '700', '701').                      If None, will use the first available plate or all                       if only one exists.</p> <code>None</code> Source code in <code>src/IncucyteSource.py</code> <pre><code>def __init__(self, uri, metadata={}, plate_id=None):\n    \"\"\"\n    Initialize IncucyteSource.\n\n    Args:\n        uri (str): Path to the Incucyte archive folder\n        metadata (dict): Optional metadata dictionary\n        plate_id (str, optional): Specific plate ID to process (e.g., '700', '701').\n                                 If None, will use the first available plate or all \n                                 if only one exists.\n    \"\"\"\n    super().__init__(uri, metadata)\n    self.base_path = Path(self.uri)\n    self.scan_data_path = self.base_path / \"EssenFiles\" / \"ScanData\"\n    self._file_cache = {}\n    self._diag_metadata_cache = None  # Cache for Diag.log parsing\n    self._sample_image_info_cache = None  # Cache for sample image info\n    # Default to True for filling missing images\n    self.fill_missing_images = True\n    self.plate_id = plate_id\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.close","title":"<code>close()</code>","text":"<p>Clean up resources</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>def close(self):\n    \"\"\"Clean up resources\"\"\"\n    self._file_cache.clear()\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_acquisitions","title":"<code>get_acquisitions()</code>","text":"<p>Return acquisition information based on timepoints</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_acquisitions(self):\n    \"\"\"Return acquisition information based on timepoints\"\"\"\n    acquisitions = []\n    for i, tp in enumerate(self.metadata.get(\"timepoints\", [])):\n        acq = {\n            \"id\": i,\n            \"name\": f\"Timepoint_{tp['timestamp']}\",\n            \"description\": f\"Incucyte acquisition at {tp['timestamp']}\",\n            \"date_created\": tp[\"datetime\"].isoformat()\n            if tp[\"datetime\"]\n            else tp[\"timestamp\"],\n            \"date_modified\": tp[\"datetime\"].isoformat()\n            if tp[\"datetime\"]\n            else tp[\"timestamp\"],\n        }\n        acquisitions.append(acq)\n    return acquisitions\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_available_plates","title":"<code>get_available_plates(uri)</code>  <code>staticmethod</code>","text":"<p>Discover all available plate IDs in an Incucyte archive.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>Path to the Incucyte archive folder</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of plate IDs (strings) found in the archive</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>@staticmethod\ndef get_available_plates(uri):\n    \"\"\"\n    Discover all available plate IDs in an Incucyte archive.\n\n    Args:\n        uri (str): Path to the Incucyte archive folder\n\n    Returns:\n        list: List of plate IDs (strings) found in the archive\n    \"\"\"\n    base_path = Path(uri)\n    scan_data_path = base_path / \"EssenFiles\" / \"ScanData\"\n\n    if not scan_data_path.exists():\n        raise ValueError(f\"Scan data path not found: {scan_data_path}\")\n\n    plate_ids = set()\n\n    # Navigate through the directory structure to find all plate IDs\n    for year_month in scan_data_path.iterdir():\n        if not year_month.is_dir():\n            continue\n        for day in year_month.iterdir():\n            if not day.is_dir():\n                continue\n            for time_dir in day.iterdir():\n                if not time_dir.is_dir():\n                    continue\n                for plate_dir in time_dir.iterdir():\n                    if plate_dir.is_dir():\n                        plate_ids.add(plate_dir.name)\n\n    return sorted(list(plate_ids))\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_channels","title":"<code>get_channels()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_channels(self):\n    return self.channels\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_columns","title":"<code>get_columns()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_columns(self):\n    return self.columns\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_data","title":"<code>get_data(well_id, field_id)</code>","text":"<p>Get data for a specific well and field</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_data(self, well_id, field_id):\n    \"\"\"Get data for a specific well and field\"\"\"\n    well_id = strip_leading_zeros(well_id)\n\n    if well_id not in self.metadata[\"wells\"]:\n        raise ValueError(\n            f\"Invalid Well: {well_id}. Available: {list(self.metadata['wells'].keys())}\"\n        )\n\n    field_id = int(field_id)\n    if field_id not in self.metadata[\"fields_raw\"]:\n        raise ValueError(\n            f\"Invalid Field: {field_id}. Available: {self.metadata['fields_raw']}\"\n        )\n\n    # Build 5D array: (t, c, z, y, x)\n    nt = len(self.metadata[\"time_points\"])\n    nc = self.metadata[\"num_channels\"]\n    sample_info = self._get_sample_image_info()\n    ny, nx = sample_info[\"height\"], sample_info[\"width\"]\n    nz = 1  # Incucyte is typically 2D\n\n    data = np.zeros((nt, nc, nz, ny, nx), dtype=sample_info[\"dtype\"])\n\n    for t in range(nt):\n        for c in range(nc):\n            image_data = self._load_image_data(well_id, field_id, c, t)\n            # Handle different image shapes\n            if len(image_data.shape) == 2:\n                data[t, c, 0, :, :] = image_data\n            elif len(image_data.shape) == 3 and image_data.shape[0] == 1:\n                data[t, c, 0, :, :] = image_data[0]\n            else:\n                # Take first z-plane if 3D\n                data[t, c, 0, :, :] = (\n                    image_data[..., 0] if len(image_data.shape) &gt; 2 else image_data\n                )\n\n    return data\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_dim_order(self):\n    return self.dim_order\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_dtype","title":"<code>get_dtype()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_dtype(self):\n    return self.dtype\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_fields","title":"<code>get_fields()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_fields(self):\n    return self.metadata.get(\"well_info\", {}).get(\"fields\", [])\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_name","title":"<code>get_name()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_name(self):\n    return self.name\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_nchannels(self):\n    return max(self.metadata.get(\"num_channels\", 1), 1)\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_pixel_size_um(self):\n    return self.pixel_size\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_position_um","title":"<code>get_position_um(well_id=None)</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_position_um(self, well_id=None):\n    well = self.metadata[\"wells\"].get(well_id, {})\n    well_info = self.metadata[\"well_info\"]\n    x = well.get(\"CoordX\", 0) * well_info.get(\"max_sizex_um\", 0)\n    y = well.get(\"CoordY\", 0) * well_info.get(\"max_sizey_um\", 0)\n    return {\"x\": x, \"y\": y}\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_rows","title":"<code>get_rows()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_rows(self):\n    return self.rows\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_time_points","title":"<code>get_time_points()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_time_points(self):\n    return self.metadata.get(\"time_points\", [])\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_total_data_size","title":"<code>get_total_data_size()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_total_data_size(self):\n    return self.metadata.get(\"max_data_size\", 0)\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_well_coords_um","title":"<code>get_well_coords_um(well_id)</code>","text":"<p>Get well coordinates (placeholder - Incucyte doesn't typically have stage coordinates)</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_well_coords_um(self, well_id):\n    \"\"\"Get well coordinates (placeholder - Incucyte doesn't typically have stage coordinates)\"\"\"\n    return {\"x\": 0.0, \"y\": 0.0}\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_wells","title":"<code>get_wells()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_wells(self):\n    return self.wells\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.init_metadata","title":"<code>init_metadata()</code>","text":"<p>Initialize all metadata from Incucyte structure</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>def init_metadata(self):\n    \"\"\"Initialize all metadata from Incucyte structure\"\"\"\n    self._scan_timepoints()  # Must be first to set plate_id\n    self._get_experiment_metadata()  # Uses plate_id in name\n    self._get_well_info()\n    self._get_channel_info()\n    self._get_image_info()\n\n    # Initialize properties like TiffSource does\n    self.name = self.metadata.get(\"Name\", \"Incucyte_Experiment\")\n    self.dim_order = self.metadata.get(\"dim_order\", \"tczyx\")\n    self.dtype = self.metadata.get(\"dtype\", np.uint16)\n    self.pixel_size = self._get_pixel_size_dict()\n    self.channels = self._format_channels_for_interface()\n    self.is_plate = len(self.metadata.get(\"wells\", {})) &gt; 0\n    self.wells = list(self.metadata.get(\"wells\", {}).keys())\n    self.rows = self.metadata.get(\"well_info\", {}).get(\"rows\", [])\n    self.columns = self.metadata.get(\"well_info\", {}).get(\"columns\", [])\n\n    return self.metadata\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.is_rgb","title":"<code>is_rgb()</code>","text":"<p>Check if the source is a RGB(A) image. Incucyte data stores channels separately, not as RGB.</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>def is_rgb(self):\n    \"\"\"\n    Check if the source is a RGB(A) image.\n    Incucyte data stores channels separately, not as RGB.\n    \"\"\"\n    return False\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.is_screen","title":"<code>is_screen()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def is_screen(self):\n    return self.is_plate\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.print_timepoint_well_matrix","title":"<code>print_timepoint_well_matrix()</code>","text":"<p>Print timepoint vs well matrix</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>def print_timepoint_well_matrix(self):\n    \"\"\"Print timepoint vs well matrix\"\"\"\n    s = \"\"\n    timepoints = self.metadata.get(\"timepoints\", [])\n    wells = list(self.metadata.get(\"wells\", {}).keys())\n\n    # Header\n    header = \"Timepoint   \" + \"  \".join(f\"{well:&gt;3}\" for well in wells)\n    s += header + \"\\n\"\n\n    # Check which wells have data at each timepoint\n    for tp in timepoints:\n        line = f\"{tp['timestamp']:&gt;9}   \"\n        for well in wells:\n            # Check if any files exist for this well at this timepoint\n            has_data = any(\n                (tp[\"path\"] / f\"{well}-{field + 1}-{channel}.tif\").exists()\n                for field in self.metadata.get(\"fields_raw\", [])\n                for channel in self.metadata.get(\"channels_raw\", [])\n            )\n            line += \" + \" if has_data else \"   \"\n        s += line + \"\\n\"\n\n    return s\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.print_well_matrix","title":"<code>print_well_matrix()</code>","text":"<p>Print a visual representation of the plate layout</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>def print_well_matrix(self):\n    \"\"\"Print a visual representation of the plate layout\"\"\"\n    s = \"\"\n    well_info = self.metadata.get(\"well_info\", {})\n    rows = well_info.get(\"rows\", [])\n    cols = [int(c) for c in well_info.get(\"columns\", [])]\n    used_wells = set(self.metadata.get(\"wells\", {}).keys())\n\n    # Header with column numbers\n    header = \"   \" + \"  \".join(f\"{col:2d}\" for col in cols)\n    s += header + \"\\n\"\n\n    # Each row\n    for row_letter in rows:\n        row_line = f\"{row_letter}  \"\n        for col_num in cols:\n            well_id = f\"{row_letter}{col_num}\"\n            row_line += \" + \" if well_id in used_wells else \"   \"\n        s += row_line + \"\\n\"\n\n    return s\n</code></pre>"},{"location":"references/#src.OmeTiffWriter","title":"<code>OmeTiffWriter</code>","text":""},{"location":"references/#src.OmeTiffWriter.CONVERSION_ATTEMPTS","title":"<code>CONVERSION_ATTEMPTS = 3</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.PYRAMID_DOWNSCALE","title":"<code>PYRAMID_DOWNSCALE = 2</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.PYRAMID_LEVELS","title":"<code>PYRAMID_LEVELS = 6</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.TIFF_COMPRESSION","title":"<code>TIFF_COMPRESSION = 'LZW'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.TILE_SIZE","title":"<code>TILE_SIZE = 1024</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.VERSION","title":"<code>VERSION = 'v0.1.2'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.ZARR_CHUNK_SIZE","title":"<code>ZARR_CHUNK_SIZE = TILE_SIZE</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.ZARR_SHARD_MULTIPLIER","title":"<code>ZARR_SHARD_MULTIPLIER = 10</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.OmeTiffWriter","title":"<code>OmeTiffWriter</code>","text":"<p>               Bases: <code>OmeWriter</code></p> <p>Writes image data and metadata to OME-TIFF files.</p> Source code in <code>src/OmeTiffWriter.py</code> <pre><code>class OmeTiffWriter(OmeWriter):\n    \"\"\"\n    Writes image data and metadata to OME-TIFF files.\n    \"\"\"\n    def __init__(self, verbose=False):\n        \"\"\"\n        Initialize OmeTiffWriter.\n\n        Args:\n            verbose (bool): If True, prints progress info.\n        \"\"\"\n        super().__init__()\n        self.verbose = verbose\n\n    def write(self, filepath, source, **kwargs):\n        \"\"\"\n        Writes image or screen data to OME-TIFF files.\n\n        Args:\n            filepath (str): Output file path.\n            source (ImageSource): Source object.\n            **kwargs: Additional options (e.g. wells selection).\n\n        Returns:\n            str or list: Output file path(s).\n        \"\"\"\n        if source.is_screen():\n            filepath, total_size = self._write_screen(filepath, source, **kwargs)\n        else:\n            filepath, total_size = self._write_image(filepath, source, **kwargs)\n\n        if self.verbose:\n            print(f'Total data written: {print_hbytes(total_size)}')\n\n        return filepath\n\n    def _write_screen(self, filename, source, **kwargs):\n        \"\"\"\n        Writes multi-well screen data to separate TIFF files and companion metadata.\n\n        Args:\n            filename (str): Output file name.\n            source (ImageSource): Source object.\n            **kwargs: Additional options (e.g. wells selection).\n\n        Returns:\n            tuple: (List of output paths, total data size)\n        \"\"\"\n        # writes separate tiff files for each field, and separate metadata companion file\n        output_paths = []\n        filepath, filename = os.path.split(filename)\n        filetitle = os.path.splitext(filename)[0].rstrip('.ome')\n\n        companion_filename = os.path.join(filepath, filetitle + '.companion.ome')\n        companion_uuid = create_uuid()\n\n        wells = kwargs.get('wells', source.get_wells())\n\n        total_size = 0\n        image_uuids = []\n        image_filenames = []\n        for well_id in wells:\n            for field in source.get_fields():\n                resolution, resolution_unit = create_resolution_metadata(source)\n                data = source.get_data(well_id, field)\n\n                filename = f'{filetitle}'\n                filename += f'_{pad_leading_zero(well_id)}'\n                if field is not None:\n                    filename += f'_{pad_leading_zero(field)}'\n                filename = os.path.join(filepath, filename + '.ome.tiff')\n                xml_metadata, image_uuid = create_binaryonly_metadata(os.path.basename(companion_filename), companion_uuid)\n\n                size = self._write_tiff(filename, source, data,\n                                        resolution=resolution, resolution_unit=resolution_unit,\n                                        tile_size=TILE_SIZE, compression=TIFF_COMPRESSION,\n                                        xml_metadata=xml_metadata,\n                                        pyramid_levels=PYRAMID_LEVELS, pyramid_downscale=PYRAMID_DOWNSCALE)\n\n                image_uuids.append(image_uuid)\n                image_filenames.append(os.path.basename(filename))\n                output_paths.append(filename)\n                total_size += size\n\n        xml_metadata = create_metadata(source, companion_uuid, image_uuids, image_filenames, wells=wells)\n        with open(companion_filename, 'wb') as file:\n            file.write(xml_metadata.encode())\n\n        output_paths = [companion_filename] + output_paths\n        return output_paths, total_size\n\n    def _write_image(self, filename, source, **kwargs):\n        \"\"\"\n        Writes single image data to a TIFF file.\n\n        Args:\n            filename (str): Output file name.\n            source (ImageSource): Source object.\n            **kwargs: Additional options.\n\n        Returns:\n            tuple: (Output path, data size)\n        \"\"\"\n        xml_metadata = create_metadata(source, image_filenames=[filename])\n        resolution, resolution_unit = create_resolution_metadata(source)\n        data = source.get_data(as_generator=True)\n\n        size = self._write_tiff(filename, source, data,\n                                resolution=resolution, resolution_unit=resolution_unit,\n                                tile_size=TILE_SIZE, compression=TIFF_COMPRESSION,\n                                xml_metadata=xml_metadata,\n                                pyramid_levels=PYRAMID_LEVELS, pyramid_downscale=PYRAMID_DOWNSCALE)\n\n        return filename, size\n\n    def _write_tiff(self, filename, source, data,\n                    resolution=None, resolution_unit=None, tile_size=None, compression=None, compressionargs=None,\n                    xml_metadata=None, pyramid_levels=0, pyramid_downscale=2):\n        \"\"\"\n        Writes image data to a TIFF file with optional pyramids and metadata.\n\n        Args:\n            filename (str): Output file name.\n            source (ImageSource): Source object.\n            data (ndarray or generator): Image data.\n            resolution (tuple, optional): Pixel resolution.\n            resolution_unit (str, optional): Resolution unit.\n            tile_size (int or tuple, optional): Tile size.\n            compression (str, optional): Compression type.\n            xml_metadata (str, optional): OME-XML metadata.\n            pyramid_levels (int): Number of pyramid levels.\n            pyramid_downscale (int): Pyramid downscale factor.\n\n        Returns:\n            int: Data size in bytes.\n        \"\"\"\n        is_generator = inspect.isgeneratorfunction(data)\n        if is_generator:\n            data_generator = data\n            shape = list(source.source_shape)\n            dim_order = source.source_dim_order\n            dtype = source.get_dtype()\n        else:\n            shape = list(data.shape)\n            dim_order = source.get_dim_order()\n            dtype = data.dtype\n        if source.is_rgb() and dim_order[-1] != 'c' and not is_generator:\n            # For Tiff allow RGB written with color channel at end for better compression\n            old_dimc = dim_order.index('c')\n            data = np.moveaxis(data, old_dimc, -1)\n            dim_order = dim_order[:old_dimc] + dim_order[old_dimc+1:] + 'c'\n            shape = shape[:old_dimc] + shape[old_dimc+1:] + [shape[old_dimc]]\n\n        x_index = dim_order.index('x')\n        y_index = dim_order.index('y')\n        if tile_size is not None:\n            if isinstance(tile_size, int):\n                tile_size = [tile_size] * 2\n            if tile_size[0] &gt; shape[y_index] or tile_size[1] &gt; shape[x_index]:\n                tile_size = None\n\n        if xml_metadata is not None:\n            # set ome=False to provide custom OME xml in description\n            xml_metadata_bytes = xml_metadata.encode()\n            is_ome = False\n        else:\n            xml_metadata_bytes = None\n            is_ome = True\n\n        # maximum size (w/o compression)\n        if is_generator:\n            data_size = np.prod(shape) * dtype.itemsize\n        else:\n            data_size = data.size * data.itemsize\n        max_size = 0\n        scale = 1\n        for level in range(1 + pyramid_levels):\n            max_size += data_size * scale ** 2\n            scale /= pyramid_downscale\n        bigtiff = (max_size &gt; 2 ** 32)\n\n        with TiffWriter(filename, bigtiff=bigtiff, ome=is_ome) as writer:\n            for level in range(pyramid_levels + 1):\n                if level == 0:\n                    scale = 1\n                    subifds = pyramid_levels\n                    subfiletype = None\n                    new_shape = shape\n                else:\n                    scale /= pyramid_downscale\n                    new_shape = list(shape)\n                    new_shape[x_index] = int(shape[x_index] * scale)\n                    new_shape[y_index] = int(shape[y_index] * scale)\n                    if not is_generator:\n                        data = resize(data, new_shape, preserve_range=True).astype(dtype)\n                    subifds = None\n                    subfiletype = 1\n                    xml_metadata_bytes = None\n                if is_generator:\n                    data = data_generator(scale)\n                writer.write(data, shape=tuple(new_shape), dtype=dtype, metadata={'axes':dim_order},\n                             subifds=subifds, subfiletype=subfiletype,\n                             resolution=resolution, resolutionunit=resolution_unit, tile=tile_size,\n                             compression=compression, compressionargs=compressionargs,\n                             description=xml_metadata_bytes)\n        return data_size\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.OmeTiffWriter.verbose","title":"<code>verbose = verbose</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.OmeTiffWriter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>Initialize OmeTiffWriter.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, prints progress info.</p> <code>False</code> Source code in <code>src/OmeTiffWriter.py</code> <pre><code>def __init__(self, verbose=False):\n    \"\"\"\n    Initialize OmeTiffWriter.\n\n    Args:\n        verbose (bool): If True, prints progress info.\n    \"\"\"\n    super().__init__()\n    self.verbose = verbose\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.OmeTiffWriter.write","title":"<code>write(filepath, source, **kwargs)</code>","text":"<p>Writes image or screen data to OME-TIFF files.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Output file path.</p> required <code>source</code> <code>ImageSource</code> <p>Source object.</p> required <code>**kwargs</code> <p>Additional options (e.g. wells selection).</p> <code>{}</code> <p>Returns:</p> Type Description <p>str or list: Output file path(s).</p> Source code in <code>src/OmeTiffWriter.py</code> <pre><code>def write(self, filepath, source, **kwargs):\n    \"\"\"\n    Writes image or screen data to OME-TIFF files.\n\n    Args:\n        filepath (str): Output file path.\n        source (ImageSource): Source object.\n        **kwargs: Additional options (e.g. wells selection).\n\n    Returns:\n        str or list: Output file path(s).\n    \"\"\"\n    if source.is_screen():\n        filepath, total_size = self._write_screen(filepath, source, **kwargs)\n    else:\n        filepath, total_size = self._write_image(filepath, source, **kwargs)\n\n    if self.verbose:\n        print(f'Total data written: {print_hbytes(total_size)}')\n\n    return filepath\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.convert_dotnet_ticks_to_datetime","title":"<code>convert_dotnet_ticks_to_datetime(net_ticks)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def convert_dotnet_ticks_to_datetime(net_ticks):\n    return datetime(1, 1, 1) + timedelta(microseconds=net_ticks // 10)\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.convert_to_um","title":"<code>convert_to_um(value, unit)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def convert_to_um(value, unit):\n    conversions = {\n        'nm': 1e-3,\n        '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'micron': 1,\n        'mm': 1e3, 'millimeter': 1e3,\n        'cm': 1e4, 'centimeter': 1e4,\n        'm': 1e6, 'meter': 1e6\n    }\n    return value * conversions.get(unit, 1)\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.ensure_list","title":"<code>ensure_list(item)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def ensure_list(item):\n    if not isinstance(item, (list, tuple)):\n        item = [item]\n    return item\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_filetitle(filename):\n    return os.path.basename(os.path.splitext(filename)[0])\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.pad_leading_zero","title":"<code>pad_leading_zero(input_string, num_digits=2)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def pad_leading_zero(input_string, num_digits=2):\n    output = str(input_string)\n    is_well = not output[0].isdigit()\n    if is_well:\n        row, col = split_well_name(output, remove_leading_zeros=True)\n        output = str(col)\n    while len(output) &lt; num_digits:\n        output = '0' + output\n    if is_well:\n        output = row + output\n    return output\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.print_dict","title":"<code>print_dict(value, tab=0, max_len=250, bullet=False)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def print_dict(value, tab=0, max_len=250, bullet=False):\n    s = ''\n    if isinstance(value, dict):\n        for key, subvalue in value.items():\n            s += '\\n'\n            if bullet:\n                s += '-'\n                bullet = False\n            s += '\\t' * tab + str(key) + ': '\n            if isinstance(subvalue, dict):\n                s += print_dict(subvalue, tab+1)\n            elif isinstance(subvalue, list):\n                for v in subvalue:\n                    s += print_dict(v, tab+1, bullet=True)\n            else:\n                subvalue = str(subvalue)\n                if len(subvalue) &gt; max_len:\n                    subvalue = subvalue[:max_len] + '...'\n                s += subvalue\n    else:\n        s += str(value) + ' '\n    return s\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def print_hbytes(nbytes):\n    exps = ['', 'K', 'M', 'G', 'T', 'P', 'E']\n    div = 1024\n    exp = 0\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    if exp &lt; len(exps):\n        e = exps[exp]\n    else:\n        e = f'e{exp * 3}'\n    return f'{nbytes:.1f}{e}B'\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.redimension_data","title":"<code>redimension_data(data, old_order, new_order, **indices)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def redimension_data(data, old_order, new_order, **indices):\n    # able to provide optional dimension values e.g. t=0, z=0\n    if new_order == old_order:\n        return data\n\n    new_data = data\n    order = old_order\n    # remove\n    for o in old_order:\n        if o not in new_order:\n            index = order.index(o)\n            dim_value = indices.get(o, 0)\n            new_data = np.take(new_data, indices=dim_value, axis=index)\n            order = order[:index] + order[index + 1:]\n    # add\n    for o in new_order:\n        if o not in order:\n            new_data = np.expand_dims(new_data, 0)\n            order = o + order\n    # move\n    old_indices = [order.index(o) for o in new_order]\n    new_indices = list(range(len(new_order)))\n    new_data = np.moveaxis(new_data, old_indices, new_indices)\n    return new_data\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.split_well_name","title":"<code>split_well_name(well_name, remove_leading_zeros=True, col_as_int=False)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def split_well_name(well_name, remove_leading_zeros=True, col_as_int=False):\n    matches = re.findall(r'(\\D+)(\\d+)', well_name)\n    if len(matches) &gt; 0:\n        row, col = matches[0]\n        if col_as_int or remove_leading_zeros:\n            try:\n                col = int(col)\n            except ValueError:\n                pass\n        if not col_as_int:\n            col = str(col)\n        return row, col\n    else:\n        raise ValueError(f\"Invalid well name format: {well_name}. Expected format like 'A1', 'B2', etc.\")\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.splitall","title":"<code>splitall(path)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def splitall(path):\n    allparts = []\n    while True:\n        parts = os.path.split(path)\n        if parts[0] == path:  # sentinel for absolute paths\n            allparts.insert(0, parts[0])\n            break\n        elif parts[1] == path: # sentinel for relative paths\n            allparts.insert(0, parts[1])\n            break\n        else:\n            path = parts[0]\n            allparts.insert(0, parts[1])\n    return allparts\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.strip_leading_zeros","title":"<code>strip_leading_zeros(well_name)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def strip_leading_zeros(well_name):\n    row, col = split_well_name(well_name, remove_leading_zeros=True)\n    return f'{row}{col}'\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.xml_content_to_dict","title":"<code>xml_content_to_dict(element)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def xml_content_to_dict(element):\n    key = element.tag\n    children = list(element)\n    if key == 'Array':\n        res = [xml_content_to_dict(child) for child in children]\n        return res\n    if len(children) &gt; 0:\n        if children[0].tag == 'Array':\n            value = []\n        else:\n            value = {}\n        for child in children:\n            child_value = xml_content_to_dict(child)\n            if isinstance(child_value, list):\n                value.extend(child_value)\n            else:\n                value |= child_value\n    else:\n        value = element.text\n        if value is not None:\n            if '\"' in value:\n                value = value.replace('\"', '')\n            else:\n                for t in (float, int, bool):\n                    try:\n                        if t == bool:\n                            if value.lower() == 'true':\n                                value = True\n                            if value.lower() == 'false':\n                                value = False\n                        else:\n                            value = t(value)\n                        break\n                    except (TypeError, ValueError):\n                        pass\n\n    if key == 'DataObject':\n        key = element.attrib['ObjectType']\n    if key == 'Attribute':\n        key = element.attrib['Name']\n    return {key: value}\n</code></pre>"},{"location":"references/#src.OmeWriter","title":"<code>OmeWriter</code>","text":""},{"location":"references/#src.OmeWriter.OmeWriter","title":"<code>OmeWriter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for OME writers.</p> Source code in <code>src/OmeWriter.py</code> <pre><code>class OmeWriter(ABC):\n    \"\"\"\n    Abstract base class for OME writers.\n    \"\"\"\n\n    def write(self, filepath, source, verbose=False, **kwargs) -&gt; str:\n        \"\"\"\n        Write image data and metadata to output.\n\n        Args:\n            filepath (str): Output file path.\n            source (ImageSource): Source object.\n            verbose (bool): If True, prints progress info.\n            **kwargs: Additional options.\n\n        Returns:\n            str: Output file path(s).\n        \"\"\"\n        # Expect to return output path (or filepath)\n        raise NotImplementedError(\"This method should be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.OmeWriter.OmeWriter.write","title":"<code>write(filepath, source, verbose=False, **kwargs)</code>","text":"<p>Write image data and metadata to output.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Output file path.</p> required <code>source</code> <code>ImageSource</code> <p>Source object.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints progress info.</p> <code>False</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Output file path(s).</p> Source code in <code>src/OmeWriter.py</code> <pre><code>def write(self, filepath, source, verbose=False, **kwargs) -&gt; str:\n    \"\"\"\n    Write image data and metadata to output.\n\n    Args:\n        filepath (str): Output file path.\n        source (ImageSource): Source object.\n        verbose (bool): If True, prints progress info.\n        **kwargs: Additional options.\n\n    Returns:\n        str: Output file path(s).\n    \"\"\"\n    # Expect to return output path (or filepath)\n    raise NotImplementedError(\"This method should be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.OmeZarrSource","title":"<code>OmeZarrSource</code>","text":""},{"location":"references/#src.OmeZarrSource.OmeZarrSource","title":"<code>OmeZarrSource</code>","text":"<p>               Bases: <code>ImageSource</code></p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>class OmeZarrSource(ImageSource):\n\n    def _get_reader(self, add_path=None):\n        uri = self.uri\n        if add_path:\n            uri = os.path.join(uri, add_path)\n        location = parse_url(uri)\n        if location is None:\n            raise FileNotFoundError(f'Error parsing ome-zarr file {uri}')\n        reader = Reader(location)\n        nodes = list(reader())\n        return reader, nodes\n\n    def _get_metadata(self, add_path=None):\n        metadata = {}\n        _, nodes = self._get_reader(add_path)\n        if len(nodes) &gt; 0:\n            metadata = nodes[0].metadata\n        return metadata\n\n    def init_metadata(self):\n        \"\"\"\n        Initializes and loads metadata from the (OME) TIFF file.\n\n        Returns:\n            dict: Metadata dictionary.\n        \"\"\"\n        reader, nodes = self._get_reader()\n        if 'bioformats2raw.layout' in reader.zarr.root_attrs:\n            # TODO: use paths provided in metadata\n            reader, nodes = self._get_reader('/0')\n        # nodes may include images, labels etc\n        if len(nodes) == 0:\n            raise FileNotFoundError(f'No image data found in ome-zarr file {self.uri}')\n        # first node will be the image pixel data\n        image_node = nodes[0]\n        self.metadata = image_node.metadata\n        # channel metadata from ome-zarr-py limited; get from root_attrs manually\n        #self.root_metadata = reader.zarr.root_attrs\n\n        axes = self.metadata.get('axes', [])\n        self.dim_order = ''.join([axis.get('name') for axis in axes])\n        self.plate = self.metadata.get('metadata', {}).get('plate')\n        self.is_plate = self.plate is not None\n\n        pixel_sizes0 = [transform for transform\n                        in self.metadata['coordinateTransformations'][0]\n                        if transform['type'] == 'scale'][0]['scale']\n        self.pixel_size = {axis: pixel_size for axis, pixel_size in zip(self.dim_order, pixel_sizes0) if axis in 'xyz'}\n        if self.is_plate:\n            self.name = self.plate.get('name', '')\n            self.rows = [row['name'] for row in self.plate.get('rows', [])]\n            self.columns = [column['name'] for column in self.plate.get('columns', [])]\n            self.wells = {well['path'].replace('/', ''): well['path'] for well in self.plate.get('wells')}\n            self.fields = list(range(self.plate.get('field_count', 0)))\n            self.paths = {well_id: {field: f'{well_path}/{field}' for field in self.fields} for well_id, well_path in self.wells.items()}\n            self.acquisitions = self.plate.get('acquisitions', [])\n        else:\n            self.name = self.metadata.get('name', '')\n            self.data = image_node.data\n        self.shape = image_node.data[0].shape\n        self.dtype = image_node.data[0].dtype\n\n    def is_screen(self):\n        \"\"\"\n        Checks if the source is a plate/screen.\n\n        Returns:\n            bool: True if plate/screen.\n        \"\"\"\n        return self.is_plate\n\n    def get_shape(self):\n        \"\"\"\n        Returns the shape of the image data.\n\n        Returns:\n            tuple: Shape of the image data.\n        \"\"\"\n        return self.shape\n\n    def get_data(self, well_id=None, field_id=None, level=0, **kwargs):\n        \"\"\"\n        Gets image data from ZARR nodes.\n\n        Returns:\n            ndarray: Image data.\n        \"\"\"\n\n        if well_id is None and field_id is None:\n            return self.data[level]\n        else:\n            _, nodes = self._get_reader(self.paths[well_id][field_id])\n            return nodes[0].data[level]\n\n    def get_image_window(self, well_id=None, field_id=None, data=None):\n        if well_id is None and field_id is None:\n            metadata = self.metadata\n        else:\n            metadata = self._get_metadata(self.paths[well_id][field_id])\n        window = np.transpose(metadata.get('contrast_limits', ([], [])))\n        return window\n\n    def get_name(self):\n        \"\"\"\n        Gets the image or plate name.\n\n        Returns:\n            str: Name.\n        \"\"\"\n        return self.name\n\n    def get_dim_order(self):\n        \"\"\"\n        Returns the dimension order string.\n\n        Returns:\n            str: Dimension order.\n        \"\"\"\n        return self.dim_order\n\n    def get_dtype(self):\n        \"\"\"\n        Returns the numpy dtype of the image data.\n\n        Returns:\n            dtype: Numpy dtype.\n        \"\"\"\n        return self.dtype\n\n    def get_pixel_size_um(self):\n        \"\"\"\n        Returns the pixel size in micrometers.\n\n        Returns:\n            dict: Pixel size for x, y, (and z).\n        \"\"\"\n        return self.pixel_size\n\n    def get_position_um(self, well_id=None):\n        \"\"\"\n        Returns the position in micrometers.\n\n        Returns:\n            dict: Position in micrometers.\n        \"\"\"\n        metadata = self._get_metadata(self.paths[well_id][0])\n        for transforms in metadata['coordinateTransformations'][0]:\n            if transforms['type'] == 'translation':\n                return {dim:value for dim, value in zip(self.dim_order, transforms['translation'])}\n        return {}\n\n    def get_channels(self):\n        \"\"\"\n        Returns channel metadata.\n\n        Returns:\n            list: List of channel dicts.\n        \"\"\"\n        channels = []\n        colormaps = self.metadata['colormap']\n        for channeli, channel_name in enumerate(self.metadata['channel_names']):\n            channel = {'label': channel_name}\n            if channeli &lt; len(colormaps):\n                channel['color'] = colormaps[channeli][-1]\n            channels.append(channel)\n        return channels\n\n    def get_nchannels(self):\n        \"\"\"\n        Returns the number of channels.\n\n        Returns:\n            int: Number of channels.\n        \"\"\"\n        return self.shape[self.dim_order.index('c')] if 'c' in self.dim_order else 1\n\n    def is_rgb(self):\n        \"\"\"\n        Check if the source is a RGB(A) image.\n        \"\"\"\n        return self.get_nchannels() in (3, 4)\n\n    def get_rows(self):\n        \"\"\"\n        Returns the list of row identifiers.\n\n        Returns:\n            list: Row identifiers.\n        \"\"\"\n        return self.rows\n\n    def get_columns(self):\n        \"\"\"\n        Returns the list of column identifiers.\n\n        Returns:\n            list: Column identifiers.\n        \"\"\"\n        return self.columns\n\n    def get_wells(self):\n        \"\"\"\n        Returns the list of well identifiers.\n\n        Returns:\n            list: Well identifiers.\n        \"\"\"\n        return self.wells\n\n    def get_time_points(self):\n        \"\"\"\n        Returns the list of time points.\n\n        Returns:\n            list: Time point IDs.\n        \"\"\"\n        nt = self.shape[self.dim_order.index('t')] if 't' in self.dim_order else 1\n        return list(range(nt))\n\n    def get_fields(self):\n        \"\"\"\n        Returns the list of field indices.\n\n        Returns:\n            list: Field indices.\n        \"\"\"\n        return self.fields\n\n    def get_acquisitions(self):\n        \"\"\"\n        Returns acquisition metadata (empty for TIFF).\n\n        Returns:\n            list: acquisition metadata.\n        \"\"\"\n        return self.acquisitions\n\n    def get_total_data_size(self):\n        \"\"\"\n        Returns the estimated total data size.\n\n        Returns:\n            int: Total data size in bytes.\n        \"\"\"\n        total_size = np.prod(self.shape)\n        if self.is_plate:\n            total_size *= len(self.get_wells()) * len(self.get_fields())\n        return total_size\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_acquisitions","title":"<code>get_acquisitions()</code>","text":"<p>Returns acquisition metadata (empty for TIFF).</p> <p>Returns:</p> Name Type Description <code>list</code> <p>acquisition metadata.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_acquisitions(self):\n    \"\"\"\n    Returns acquisition metadata (empty for TIFF).\n\n    Returns:\n        list: acquisition metadata.\n    \"\"\"\n    return self.acquisitions\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_channels","title":"<code>get_channels()</code>","text":"<p>Returns channel metadata.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of channel dicts.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_channels(self):\n    \"\"\"\n    Returns channel metadata.\n\n    Returns:\n        list: List of channel dicts.\n    \"\"\"\n    channels = []\n    colormaps = self.metadata['colormap']\n    for channeli, channel_name in enumerate(self.metadata['channel_names']):\n        channel = {'label': channel_name}\n        if channeli &lt; len(colormaps):\n            channel['color'] = colormaps[channeli][-1]\n        channels.append(channel)\n    return channels\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_columns","title":"<code>get_columns()</code>","text":"<p>Returns the list of column identifiers.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Column identifiers.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_columns(self):\n    \"\"\"\n    Returns the list of column identifiers.\n\n    Returns:\n        list: Column identifiers.\n    \"\"\"\n    return self.columns\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_data","title":"<code>get_data(well_id=None, field_id=None, level=0, **kwargs)</code>","text":"<p>Gets image data from ZARR nodes.</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <p>Image data.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_data(self, well_id=None, field_id=None, level=0, **kwargs):\n    \"\"\"\n    Gets image data from ZARR nodes.\n\n    Returns:\n        ndarray: Image data.\n    \"\"\"\n\n    if well_id is None and field_id is None:\n        return self.data[level]\n    else:\n        _, nodes = self._get_reader(self.paths[well_id][field_id])\n        return nodes[0].data[level]\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"<p>Returns the dimension order string.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Dimension order.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_dim_order(self):\n    \"\"\"\n    Returns the dimension order string.\n\n    Returns:\n        str: Dimension order.\n    \"\"\"\n    return self.dim_order\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_dtype","title":"<code>get_dtype()</code>","text":"<p>Returns the numpy dtype of the image data.</p> <p>Returns:</p> Name Type Description <code>dtype</code> <p>Numpy dtype.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_dtype(self):\n    \"\"\"\n    Returns the numpy dtype of the image data.\n\n    Returns:\n        dtype: Numpy dtype.\n    \"\"\"\n    return self.dtype\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_fields","title":"<code>get_fields()</code>","text":"<p>Returns the list of field indices.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Field indices.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_fields(self):\n    \"\"\"\n    Returns the list of field indices.\n\n    Returns:\n        list: Field indices.\n    \"\"\"\n    return self.fields\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_image_window","title":"<code>get_image_window(well_id=None, field_id=None, data=None)</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_image_window(self, well_id=None, field_id=None, data=None):\n    if well_id is None and field_id is None:\n        metadata = self.metadata\n    else:\n        metadata = self._get_metadata(self.paths[well_id][field_id])\n    window = np.transpose(metadata.get('contrast_limits', ([], [])))\n    return window\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_name","title":"<code>get_name()</code>","text":"<p>Gets the image or plate name.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Name.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_name(self):\n    \"\"\"\n    Gets the image or plate name.\n\n    Returns:\n        str: Name.\n    \"\"\"\n    return self.name\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"<p>Returns the number of channels.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of channels.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_nchannels(self):\n    \"\"\"\n    Returns the number of channels.\n\n    Returns:\n        int: Number of channels.\n    \"\"\"\n    return self.shape[self.dim_order.index('c')] if 'c' in self.dim_order else 1\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"<p>Returns the pixel size in micrometers.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Pixel size for x, y, (and z).</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_pixel_size_um(self):\n    \"\"\"\n    Returns the pixel size in micrometers.\n\n    Returns:\n        dict: Pixel size for x, y, (and z).\n    \"\"\"\n    return self.pixel_size\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_position_um","title":"<code>get_position_um(well_id=None)</code>","text":"<p>Returns the position in micrometers.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Position in micrometers.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_position_um(self, well_id=None):\n    \"\"\"\n    Returns the position in micrometers.\n\n    Returns:\n        dict: Position in micrometers.\n    \"\"\"\n    metadata = self._get_metadata(self.paths[well_id][0])\n    for transforms in metadata['coordinateTransformations'][0]:\n        if transforms['type'] == 'translation':\n            return {dim:value for dim, value in zip(self.dim_order, transforms['translation'])}\n    return {}\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_rows","title":"<code>get_rows()</code>","text":"<p>Returns the list of row identifiers.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Row identifiers.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_rows(self):\n    \"\"\"\n    Returns the list of row identifiers.\n\n    Returns:\n        list: Row identifiers.\n    \"\"\"\n    return self.rows\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_shape","title":"<code>get_shape()</code>","text":"<p>Returns the shape of the image data.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Shape of the image data.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_shape(self):\n    \"\"\"\n    Returns the shape of the image data.\n\n    Returns:\n        tuple: Shape of the image data.\n    \"\"\"\n    return self.shape\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_time_points","title":"<code>get_time_points()</code>","text":"<p>Returns the list of time points.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Time point IDs.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_time_points(self):\n    \"\"\"\n    Returns the list of time points.\n\n    Returns:\n        list: Time point IDs.\n    \"\"\"\n    nt = self.shape[self.dim_order.index('t')] if 't' in self.dim_order else 1\n    return list(range(nt))\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_total_data_size","title":"<code>get_total_data_size()</code>","text":"<p>Returns the estimated total data size.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Total data size in bytes.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_total_data_size(self):\n    \"\"\"\n    Returns the estimated total data size.\n\n    Returns:\n        int: Total data size in bytes.\n    \"\"\"\n    total_size = np.prod(self.shape)\n    if self.is_plate:\n        total_size *= len(self.get_wells()) * len(self.get_fields())\n    return total_size\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_wells","title":"<code>get_wells()</code>","text":"<p>Returns the list of well identifiers.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Well identifiers.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_wells(self):\n    \"\"\"\n    Returns the list of well identifiers.\n\n    Returns:\n        list: Well identifiers.\n    \"\"\"\n    return self.wells\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.init_metadata","title":"<code>init_metadata()</code>","text":"<p>Initializes and loads metadata from the (OME) TIFF file.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Metadata dictionary.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def init_metadata(self):\n    \"\"\"\n    Initializes and loads metadata from the (OME) TIFF file.\n\n    Returns:\n        dict: Metadata dictionary.\n    \"\"\"\n    reader, nodes = self._get_reader()\n    if 'bioformats2raw.layout' in reader.zarr.root_attrs:\n        # TODO: use paths provided in metadata\n        reader, nodes = self._get_reader('/0')\n    # nodes may include images, labels etc\n    if len(nodes) == 0:\n        raise FileNotFoundError(f'No image data found in ome-zarr file {self.uri}')\n    # first node will be the image pixel data\n    image_node = nodes[0]\n    self.metadata = image_node.metadata\n    # channel metadata from ome-zarr-py limited; get from root_attrs manually\n    #self.root_metadata = reader.zarr.root_attrs\n\n    axes = self.metadata.get('axes', [])\n    self.dim_order = ''.join([axis.get('name') for axis in axes])\n    self.plate = self.metadata.get('metadata', {}).get('plate')\n    self.is_plate = self.plate is not None\n\n    pixel_sizes0 = [transform for transform\n                    in self.metadata['coordinateTransformations'][0]\n                    if transform['type'] == 'scale'][0]['scale']\n    self.pixel_size = {axis: pixel_size for axis, pixel_size in zip(self.dim_order, pixel_sizes0) if axis in 'xyz'}\n    if self.is_plate:\n        self.name = self.plate.get('name', '')\n        self.rows = [row['name'] for row in self.plate.get('rows', [])]\n        self.columns = [column['name'] for column in self.plate.get('columns', [])]\n        self.wells = {well['path'].replace('/', ''): well['path'] for well in self.plate.get('wells')}\n        self.fields = list(range(self.plate.get('field_count', 0)))\n        self.paths = {well_id: {field: f'{well_path}/{field}' for field in self.fields} for well_id, well_path in self.wells.items()}\n        self.acquisitions = self.plate.get('acquisitions', [])\n    else:\n        self.name = self.metadata.get('name', '')\n        self.data = image_node.data\n    self.shape = image_node.data[0].shape\n    self.dtype = image_node.data[0].dtype\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.is_rgb","title":"<code>is_rgb()</code>","text":"<p>Check if the source is a RGB(A) image.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def is_rgb(self):\n    \"\"\"\n    Check if the source is a RGB(A) image.\n    \"\"\"\n    return self.get_nchannels() in (3, 4)\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.is_screen","title":"<code>is_screen()</code>","text":"<p>Checks if the source is a plate/screen.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if plate/screen.</p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>def is_screen(self):\n    \"\"\"\n    Checks if the source is a plate/screen.\n\n    Returns:\n        bool: True if plate/screen.\n    \"\"\"\n    return self.is_plate\n</code></pre>"},{"location":"references/#src.OmeZarrSource.create_axes_metadata","title":"<code>create_axes_metadata(dimension_order)</code>","text":"<p>Create axes metadata for OME-Zarr from dimension order.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of axis metadata dictionaries.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_axes_metadata(dimension_order):\n    \"\"\"\n    Create axes metadata for OME-Zarr from dimension order.\n\n    Args:\n        dimension_order (str): String of dimension characters.\n\n    Returns:\n        list: List of axis metadata dictionaries.\n    \"\"\"\n    axes = []\n    for dimension in dimension_order:\n        unit1 = None\n        if dimension == 't':\n            type1 = 'time'\n            unit1 = 'millisecond'\n        elif dimension == 'c':\n            type1 = 'channel'\n        else:\n            type1 = 'space'\n            unit1 = 'micrometer'\n        axis = {'name': dimension, 'type': type1}\n        if unit1 is not None and unit1 != '':\n            axis['unit'] = unit1\n        axes.append(axis)\n    return axes\n</code></pre>"},{"location":"references/#src.OmeZarrSource.create_channel_metadata","title":"<code>create_channel_metadata(dtype, channels, nchannels, is_rgb, window, ome_version)</code>","text":"<p>Create channel metadata for OME-Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <p>Numpy dtype of image data.</p> required <code>channels</code> <code>list</code> <p>List of channel dicts.</p> required <code>nchannels</code> <code>int</code> <p>Number of channels.</p> required <code>window</code> <code>tuple</code> <p>Min/max window values.</p> required <code>ome_version</code> <code>str</code> <p>OME-Zarr version.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Channel metadata dictionary.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_channel_metadata(dtype, channels, nchannels, is_rgb, window, ome_version):\n    \"\"\"\n    Create channel metadata for OME-Zarr.\n\n    Args:\n        dtype: Numpy dtype of image data.\n        channels (list): List of channel dicts.\n        nchannels (int): Number of channels.\n        window (tuple): Min/max window values.\n        ome_version (str): OME-Zarr version.\n\n    Returns:\n        dict: Channel metadata dictionary.\n    \"\"\"\n    if len(channels) &lt; nchannels:\n        labels = []\n        colors = []\n        if is_rgb and nchannels in (3, 4):\n            labels = ['Red', 'Green', 'Blue']\n            colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n        if is_rgb and nchannels == 4:\n            labels += ['Alpha']\n            colors += [(1, 1, 1)]\n        channels = [{'label': label, 'color': color} for label, color in zip(labels, colors)]\n\n    omezarr_channels = []\n    starts, ends = window\n    for channeli, channel in enumerate(channels):\n        omezarr_channel = {'label': channel.get('label', channel.get('Name', f'{channeli}')), 'active': True}\n        color = channel.get('color', channel.get('Color'))\n        if color is not None:\n            omezarr_channel['color'] = rgba_to_hexrgb(color)\n        if dtype.kind == 'f':\n            min, max = 0, 1\n        else:\n            info = np.iinfo(dtype)\n            min, max = info.min, info.max\n        if starts and ends:\n            start, end = starts[channeli], ends[channeli]\n        else:\n            start, end = min, max\n        omezarr_channel['window'] = {'min': min, 'max': max, 'start': start, 'end': end}\n        omezarr_channels.append(omezarr_channel)\n\n    metadata = {\n        'version': ome_version,\n        'channels': omezarr_channels,\n    }\n    return metadata\n</code></pre>"},{"location":"references/#src.OmeZarrSource.create_transformation_metadata","title":"<code>create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um=None)</code>","text":"<p>Create transformation metadata (scale and translation) for OME-Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <code>pixel_size_um</code> <code>dict</code> <p>Pixel size in micrometers per dimension.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <code>translation_um</code> <code>dict</code> <p>Translation in micrometers per dimension.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>List of transformation metadata dictionaries.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um=None):\n    \"\"\"\n    Create transformation metadata (scale and translation) for OME-Zarr.\n\n    Args:\n        dimension_order (str): String of dimension characters.\n        pixel_size_um (dict): Pixel size in micrometers per dimension.\n        scale (float): Scaling factor.\n        translation_um (dict, optional): Translation in micrometers per dimension.\n\n    Returns:\n        list: List of transformation metadata dictionaries.\n    \"\"\"\n    metadata = []\n    pixel_size_scale = []\n    translation_scale = []\n    for dimension in dimension_order:\n        pixel_size_scale1 = pixel_size_um.get(dimension, 1)\n        if pixel_size_scale1 == 0:\n            pixel_size_scale1 = 1\n        if dimension in ['x', 'y']:\n            pixel_size_scale1 /= scale\n        pixel_size_scale.append(pixel_size_scale1)\n\n        if translation_um is not None:\n            translation1 = translation_um.get(dimension, 0)\n            if dimension in ['x', 'y']:\n                translation1 *= scale\n            translation_scale.append(translation1)\n\n    metadata.append({'type': 'scale', 'scale': pixel_size_scale})\n    if translation_um is not None:\n        metadata.append({'type': 'translation', 'translation': translation_scale})\n    return metadata\n</code></pre>"},{"location":"references/#src.OmeZarrSource.rgba_to_hexrgb","title":"<code>rgba_to_hexrgb(rgba)</code>","text":"Source code in <code>src/color_conversion.py</code> <pre><code>def rgba_to_hexrgb(rgba: list) -&gt; str:\n    hexrgb = ''.join([hex(int(x * 255))[2:].upper().zfill(2) for x in rgba[:3]])\n    return hexrgb\n</code></pre>"},{"location":"references/#src.OmeZarrSource.scale_dimensions_dict","title":"<code>scale_dimensions_dict(shape0, scale)</code>","text":"<p>Scale x and y dimensions in a shape dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>shape0</code> <code>dict</code> <p>Original shape dictionary.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Scaled shape dictionary.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def scale_dimensions_dict(shape0, scale):\n    \"\"\"\n    Scale x and y dimensions in a shape dictionary.\n\n    Args:\n        shape0 (dict): Original shape dictionary.\n        scale (float): Scaling factor.\n\n    Returns:\n        dict: Scaled shape dictionary.\n    \"\"\"\n    shape = {}\n    if scale == 1:\n        return shape0\n    for dimension, shape1 in shape0.items():\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape[dimension] = shape1\n    return shape\n</code></pre>"},{"location":"references/#src.OmeZarrSource.scale_dimensions_xy","title":"<code>scale_dimensions_xy(shape0, dimension_order, scale)</code>","text":"<p>Scale x and y dimensions in a shape tuple.</p> <p>Parameters:</p> Name Type Description Default <code>shape0</code> <code>tuple</code> <p>Original shape.</p> required <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Scaled shape.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def scale_dimensions_xy(shape0, dimension_order, scale):\n    \"\"\"\n    Scale x and y dimensions in a shape tuple.\n\n    Args:\n        shape0 (tuple): Original shape.\n        dimension_order (str): String of dimension characters.\n        scale (float): Scaling factor.\n\n    Returns:\n        list: Scaled shape.\n    \"\"\"\n    shape = []\n    if scale == 1:\n        return shape0\n    for shape1, dimension in zip(shape0, dimension_order):\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape.append(shape1)\n    return shape\n</code></pre>"},{"location":"references/#src.OmeZarrWriter","title":"<code>OmeZarrWriter</code>","text":""},{"location":"references/#src.OmeZarrWriter.CONVERSION_ATTEMPTS","title":"<code>CONVERSION_ATTEMPTS = 3</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.PYRAMID_DOWNSCALE","title":"<code>PYRAMID_DOWNSCALE = 2</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.PYRAMID_LEVELS","title":"<code>PYRAMID_LEVELS = 6</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.TIFF_COMPRESSION","title":"<code>TIFF_COMPRESSION = 'LZW'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.TILE_SIZE","title":"<code>TILE_SIZE = 1024</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.VERSION","title":"<code>VERSION = 'v0.1.2'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.ZARR_CHUNK_SIZE","title":"<code>ZARR_CHUNK_SIZE = TILE_SIZE</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.ZARR_SHARD_MULTIPLIER","title":"<code>ZARR_SHARD_MULTIPLIER = 10</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter","title":"<code>OmeZarrWriter</code>","text":"<p>               Bases: <code>OmeWriter</code></p> <p>Writer for exporting image or screen data to OME-Zarr format. Supports both single images and high-content screening (HCS) plates.</p> Source code in <code>src/OmeZarrWriter.py</code> <pre><code>class OmeZarrWriter(OmeWriter):\n    \"\"\"\n    Writer for exporting image or screen data to OME-Zarr format.\n    Supports both single images and high-content screening (HCS) plates.\n    \"\"\"\n\n    def __init__(self, zarr_version=2, ome_version='0.4', verbose=False):\n        \"\"\"\n        Initialize the OmeZarrWriter.\n\n        Args:\n            zarr_version (int): Zarr format version (2 or 3).\n            ome_version (str): OME-Zarr metadata version ('0.4' or '0.5').\n            verbose (bool): If True, print additional information.\n        \"\"\"\n        super().__init__()\n        self.zarr_version = zarr_version\n        self.ome_version = ome_version\n        if ome_version == '0.4':\n            from ome_zarr.format import FormatV04\n            self.ome_format = FormatV04()\n        elif ome_version == '0.5':\n            from ome_zarr.format import FormatV05\n            self.ome_format = FormatV05()\n        else:\n            self.ome_format = None\n        self.verbose = verbose\n\n    def write(self, filepath, source, **kwargs):\n        \"\"\"\n        Write the provided source data to an OME-Zarr file.\n\n        Args:\n            filepath (str): Output path for the Zarr file.\n            source: source reader supporting required interface.\n            **kwargs: Additional arguments (e.g. wells selection).\n\n        Returns:\n            str: The filepath of the written Zarr file.\n        \"\"\"\n        if source.is_screen():\n            zarr_root, total_size = self._write_screen(filepath, source, **kwargs)\n        else:\n            zarr_root, total_size = self._write_image(filepath, source, **kwargs)\n\n        zarr_root.attrs['_creator'] = {'name': 'nl.biomero.OmeZarrWriter', 'version': VERSION}\n\n        if self.verbose:\n            print(f'Total data written: {print_hbytes(total_size)}')\n\n        return filepath\n\n    def _write_screen(self, filepath, source, **kwargs):\n        \"\"\"\n        Write a high-content screening (HCS) plate to OME-Zarr.\n\n        Args:\n            filepath (str): Output path for the Zarr file.\n            source: source reader supporting required interface.\n            **kwargs: Additional arguments (e.g., wells).\n\n        Returns:\n            tuple: (zarr_root, total_size) where zarr_root is the root group and total_size is bytes written.\n        \"\"\"\n        #zarr_location = parse_url(filename, mode='w', fmt=self.ome_format)\n        zarr_location = filepath\n        zarr_root = zarr.open_group(zarr_location, mode='w', zarr_version=self.zarr_version)\n\n        row_names = source.get_rows()\n        col_names = source.get_columns()\n        wells = kwargs.get('wells', source.get_wells())\n        well_paths = ['/'.join(split_well_name(well)) for well in wells]\n        fields = list(map(str, source.get_fields()))\n\n        acquisitions = source.get_acquisitions()\n        name = source.get_name()\n        write_plate_metadata(zarr_root, row_names, col_names, well_paths,\n                             name=name, field_count=len(fields), acquisitions=acquisitions,\n                             fmt=self.ome_format)\n        total_size = 0\n        for well_id in wells:\n            row, col = split_well_name(well_id)\n            row_group = zarr_root.require_group(str(row))\n            well_group = row_group.require_group(str(col))\n            write_well_metadata(well_group, fields, fmt=self.ome_format)\n            position = source.get_position_um(well_id)\n            for field in fields:\n                image_group = well_group.require_group(field)\n                data = source.get_data(well_id, field)\n                window = source.get_image_window(well_id, field, data=data)\n                size = self._write_data(image_group, data, source, window, position=position)\n                total_size += size\n\n        return zarr_root, total_size\n\n    def _write_image(self, filepath, source, **kwargs):\n        \"\"\"\n        Write a single image to OME-Zarr.\n\n        Args:\n            filepath (str): Output path for the Zarr file.\n            source: source reader for image data.\n            **kwargs: Additional arguments.\n\n        Returns:\n            tuple: (zarr_root, size) where zarr_root is the root group and size is bytes written.\n        \"\"\"\n        #zarr_location = parse_url(filename, mode='w', fmt=self.ome_format)\n        zarr_location = filepath\n        zarr_root = zarr.open_group(zarr_location, mode='w', zarr_version=self.zarr_version)\n\n        data = source.get_data(as_dask=True)\n        window = source.get_image_window()\n        size = self._write_data(zarr_root, data, source, window)\n        return zarr_root, size\n\n    def _write_data(self, group, data, source, window, position=None):\n        \"\"\"\n        Write image data and metadata to a Zarr group.\n\n        Args:\n            group: Zarr group to write into.\n            data: Image data array.\n            source: source reader.\n            window: Image window information.\n            position: Optional position information.\n\n        Returns:\n            int: Number of bytes written.\n        \"\"\"\n        dim_order = source.get_dim_order()\n        dtype = source.get_dtype()\n        channels = source.get_channels()\n        nchannels = source.get_nchannels()\n        is_rgb = source.is_rgb()\n\n        axes = create_axes_metadata(dim_order)\n        pixel_size_scales, scaler = self._create_scale_metadata(source, dim_order, position)\n        metadata = {'omero': create_channel_metadata(dtype, channels, nchannels, is_rgb, window, self.ome_version),\n                    'metadata': {'method': scaler.method}}\n\n        storage_options = None\n        if self.zarr_version &gt;= 3:\n            if not hasattr(data, 'chunksize'):\n                chunks = []\n                shards = []\n                for dim, n in zip(dim_order, data.shape):\n                    if dim in 'xy':\n                        chunks += [ZARR_CHUNK_SIZE]\n                        shards += [ZARR_CHUNK_SIZE * ZARR_SHARD_MULTIPLIER]\n                    else:\n                        chunks += [1]\n                        shards += [1]\n                storage_options = {'chunks': chunks, 'shards': shards}\n\n        size = data.size * data.itemsize\n        write_image(image=data, group=group, axes=axes, coordinate_transformations=pixel_size_scales,\n                    scaler=scaler, fmt=self.ome_format, storage_options=storage_options,\n                    name=source.get_name(), metadata=metadata)\n\n        return size\n\n    def _create_scale_metadata(self, source, dim_order, translation, scaler=None):\n        \"\"\"\n        Create coordinate transformation metadata for multiscale images.\n\n        Args:\n            source: source reader.\n            dim_order (str): Dimension order string.\n            translation: Translation or position information.\n            scaler: Optional Scaler object.\n\n        Returns:\n            tuple: (pixel_size_scales, scaler)\n        \"\"\"\n        if scaler is None:\n            scaler = Scaler(downscale=PYRAMID_DOWNSCALE, max_layer=PYRAMID_LEVELS)\n        pixel_size_scales = []\n        scale = 1\n        for i in range(scaler.max_layer + 1):\n            pixel_size_scales.append(\n                create_transformation_metadata(dim_order, source.get_pixel_size_um(),\n                                               scale, translation))\n            scale /= scaler.downscale\n        return pixel_size_scales, scaler\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.ome_format","title":"<code>ome_format = FormatV04()</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.ome_version","title":"<code>ome_version = ome_version</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.verbose","title":"<code>verbose = verbose</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.zarr_version","title":"<code>zarr_version = zarr_version</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.__init__","title":"<code>__init__(zarr_version=2, ome_version='0.4', verbose=False)</code>","text":"<p>Initialize the OmeZarrWriter.</p> <p>Parameters:</p> Name Type Description Default <code>zarr_version</code> <code>int</code> <p>Zarr format version (2 or 3).</p> <code>2</code> <code>ome_version</code> <code>str</code> <p>OME-Zarr metadata version ('0.4' or '0.5').</p> <code>'0.4'</code> <code>verbose</code> <code>bool</code> <p>If True, print additional information.</p> <code>False</code> Source code in <code>src/OmeZarrWriter.py</code> <pre><code>def __init__(self, zarr_version=2, ome_version='0.4', verbose=False):\n    \"\"\"\n    Initialize the OmeZarrWriter.\n\n    Args:\n        zarr_version (int): Zarr format version (2 or 3).\n        ome_version (str): OME-Zarr metadata version ('0.4' or '0.5').\n        verbose (bool): If True, print additional information.\n    \"\"\"\n    super().__init__()\n    self.zarr_version = zarr_version\n    self.ome_version = ome_version\n    if ome_version == '0.4':\n        from ome_zarr.format import FormatV04\n        self.ome_format = FormatV04()\n    elif ome_version == '0.5':\n        from ome_zarr.format import FormatV05\n        self.ome_format = FormatV05()\n    else:\n        self.ome_format = None\n    self.verbose = verbose\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.write","title":"<code>write(filepath, source, **kwargs)</code>","text":"<p>Write the provided source data to an OME-Zarr file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Output path for the Zarr file.</p> required <code>source</code> <p>source reader supporting required interface.</p> required <code>**kwargs</code> <p>Additional arguments (e.g. wells selection).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The filepath of the written Zarr file.</p> Source code in <code>src/OmeZarrWriter.py</code> <pre><code>def write(self, filepath, source, **kwargs):\n    \"\"\"\n    Write the provided source data to an OME-Zarr file.\n\n    Args:\n        filepath (str): Output path for the Zarr file.\n        source: source reader supporting required interface.\n        **kwargs: Additional arguments (e.g. wells selection).\n\n    Returns:\n        str: The filepath of the written Zarr file.\n    \"\"\"\n    if source.is_screen():\n        zarr_root, total_size = self._write_screen(filepath, source, **kwargs)\n    else:\n        zarr_root, total_size = self._write_image(filepath, source, **kwargs)\n\n    zarr_root.attrs['_creator'] = {'name': 'nl.biomero.OmeZarrWriter', 'version': VERSION}\n\n    if self.verbose:\n        print(f'Total data written: {print_hbytes(total_size)}')\n\n    return filepath\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.create_axes_metadata","title":"<code>create_axes_metadata(dimension_order)</code>","text":"<p>Create axes metadata for OME-Zarr from dimension order.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of axis metadata dictionaries.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_axes_metadata(dimension_order):\n    \"\"\"\n    Create axes metadata for OME-Zarr from dimension order.\n\n    Args:\n        dimension_order (str): String of dimension characters.\n\n    Returns:\n        list: List of axis metadata dictionaries.\n    \"\"\"\n    axes = []\n    for dimension in dimension_order:\n        unit1 = None\n        if dimension == 't':\n            type1 = 'time'\n            unit1 = 'millisecond'\n        elif dimension == 'c':\n            type1 = 'channel'\n        else:\n            type1 = 'space'\n            unit1 = 'micrometer'\n        axis = {'name': dimension, 'type': type1}\n        if unit1 is not None and unit1 != '':\n            axis['unit'] = unit1\n        axes.append(axis)\n    return axes\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.create_channel_metadata","title":"<code>create_channel_metadata(dtype, channels, nchannels, is_rgb, window, ome_version)</code>","text":"<p>Create channel metadata for OME-Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <p>Numpy dtype of image data.</p> required <code>channels</code> <code>list</code> <p>List of channel dicts.</p> required <code>nchannels</code> <code>int</code> <p>Number of channels.</p> required <code>window</code> <code>tuple</code> <p>Min/max window values.</p> required <code>ome_version</code> <code>str</code> <p>OME-Zarr version.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Channel metadata dictionary.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_channel_metadata(dtype, channels, nchannels, is_rgb, window, ome_version):\n    \"\"\"\n    Create channel metadata for OME-Zarr.\n\n    Args:\n        dtype: Numpy dtype of image data.\n        channels (list): List of channel dicts.\n        nchannels (int): Number of channels.\n        window (tuple): Min/max window values.\n        ome_version (str): OME-Zarr version.\n\n    Returns:\n        dict: Channel metadata dictionary.\n    \"\"\"\n    if len(channels) &lt; nchannels:\n        labels = []\n        colors = []\n        if is_rgb and nchannels in (3, 4):\n            labels = ['Red', 'Green', 'Blue']\n            colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n        if is_rgb and nchannels == 4:\n            labels += ['Alpha']\n            colors += [(1, 1, 1)]\n        channels = [{'label': label, 'color': color} for label, color in zip(labels, colors)]\n\n    omezarr_channels = []\n    starts, ends = window\n    for channeli, channel in enumerate(channels):\n        omezarr_channel = {'label': channel.get('label', channel.get('Name', f'{channeli}')), 'active': True}\n        color = channel.get('color', channel.get('Color'))\n        if color is not None:\n            omezarr_channel['color'] = rgba_to_hexrgb(color)\n        if dtype.kind == 'f':\n            min, max = 0, 1\n        else:\n            info = np.iinfo(dtype)\n            min, max = info.min, info.max\n        if starts and ends:\n            start, end = starts[channeli], ends[channeli]\n        else:\n            start, end = min, max\n        omezarr_channel['window'] = {'min': min, 'max': max, 'start': start, 'end': end}\n        omezarr_channels.append(omezarr_channel)\n\n    metadata = {\n        'version': ome_version,\n        'channels': omezarr_channels,\n    }\n    return metadata\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.create_transformation_metadata","title":"<code>create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um=None)</code>","text":"<p>Create transformation metadata (scale and translation) for OME-Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <code>pixel_size_um</code> <code>dict</code> <p>Pixel size in micrometers per dimension.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <code>translation_um</code> <code>dict</code> <p>Translation in micrometers per dimension.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>List of transformation metadata dictionaries.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um=None):\n    \"\"\"\n    Create transformation metadata (scale and translation) for OME-Zarr.\n\n    Args:\n        dimension_order (str): String of dimension characters.\n        pixel_size_um (dict): Pixel size in micrometers per dimension.\n        scale (float): Scaling factor.\n        translation_um (dict, optional): Translation in micrometers per dimension.\n\n    Returns:\n        list: List of transformation metadata dictionaries.\n    \"\"\"\n    metadata = []\n    pixel_size_scale = []\n    translation_scale = []\n    for dimension in dimension_order:\n        pixel_size_scale1 = pixel_size_um.get(dimension, 1)\n        if pixel_size_scale1 == 0:\n            pixel_size_scale1 = 1\n        if dimension in ['x', 'y']:\n            pixel_size_scale1 /= scale\n        pixel_size_scale.append(pixel_size_scale1)\n\n        if translation_um is not None:\n            translation1 = translation_um.get(dimension, 0)\n            if dimension in ['x', 'y']:\n                translation1 *= scale\n            translation_scale.append(translation1)\n\n    metadata.append({'type': 'scale', 'scale': pixel_size_scale})\n    if translation_um is not None:\n        metadata.append({'type': 'translation', 'translation': translation_scale})\n    return metadata\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.rgba_to_hexrgb","title":"<code>rgba_to_hexrgb(rgba)</code>","text":"Source code in <code>src/color_conversion.py</code> <pre><code>def rgba_to_hexrgb(rgba: list) -&gt; str:\n    hexrgb = ''.join([hex(int(x * 255))[2:].upper().zfill(2) for x in rgba[:3]])\n    return hexrgb\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.scale_dimensions_dict","title":"<code>scale_dimensions_dict(shape0, scale)</code>","text":"<p>Scale x and y dimensions in a shape dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>shape0</code> <code>dict</code> <p>Original shape dictionary.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Scaled shape dictionary.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def scale_dimensions_dict(shape0, scale):\n    \"\"\"\n    Scale x and y dimensions in a shape dictionary.\n\n    Args:\n        shape0 (dict): Original shape dictionary.\n        scale (float): Scaling factor.\n\n    Returns:\n        dict: Scaled shape dictionary.\n    \"\"\"\n    shape = {}\n    if scale == 1:\n        return shape0\n    for dimension, shape1 in shape0.items():\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape[dimension] = shape1\n    return shape\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.scale_dimensions_xy","title":"<code>scale_dimensions_xy(shape0, dimension_order, scale)</code>","text":"<p>Scale x and y dimensions in a shape tuple.</p> <p>Parameters:</p> Name Type Description Default <code>shape0</code> <code>tuple</code> <p>Original shape.</p> required <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Scaled shape.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def scale_dimensions_xy(shape0, dimension_order, scale):\n    \"\"\"\n    Scale x and y dimensions in a shape tuple.\n\n    Args:\n        shape0 (tuple): Original shape.\n        dimension_order (str): String of dimension characters.\n        scale (float): Scaling factor.\n\n    Returns:\n        list: Scaled shape.\n    \"\"\"\n    shape = []\n    if scale == 1:\n        return shape0\n    for shape1, dimension in zip(shape0, dimension_order):\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape.append(shape1)\n    return shape\n</code></pre>"},{"location":"references/#src.TiffSource","title":"<code>TiffSource</code>","text":""},{"location":"references/#src.TiffSource.TiffSource","title":"<code>TiffSource</code>","text":"<p>               Bases: <code>ImageSource</code></p> <p>Loads image and metadata from TIFF or OME-TIFF files.</p> Source code in <code>src/TiffSource.py</code> <pre><code>class TiffSource(ImageSource):\n    \"\"\"\n    Loads image and metadata from TIFF or OME-TIFF files.\n    \"\"\"\n    def __init__(self, uri, metadata={}):\n        \"\"\"\n        Initialize TiffSource.\n\n        Args:\n            uri (str): Path to the TIFF file.\n            metadata (dict): Optional metadata dictionary.\n        \"\"\"\n        super().__init__(uri, metadata)\n        image_filename = None\n        ext = os.path.splitext(uri)[1].lower()\n        if 'tif' in ext:\n            image_filename = uri\n        elif 'ome' in ext:\n            # read metadata\n            with open(uri, 'rb') as file:\n                self.metadata = metadata_to_dict(file.read().decode())\n            # try to open a ome-tiff file\n            self.image_filenames = {}\n            for image in ensure_list(self.metadata.get('Image', {})):\n                filename = image.get('Pixels', {}).get('TiffData', {}).get('UUID', {}).get('FileName')\n                if filename:\n                    filepath = os.path.join(os.path.dirname(uri), filename)\n                    self.image_filenames[image['ID']] = filepath\n                    if image_filename is None:\n                        image_filename = filepath\n        else:\n            raise RuntimeError(f'Unsupported tiff extension: {ext}')\n\n        self.tiff = TiffFile(image_filename)\n\n    def init_metadata(self):\n        \"\"\"\n        Initializes and loads metadata from the (OME) TIFF file.\n\n        Returns:\n            dict: Metadata dictionary.\n        \"\"\"\n        self.is_ome = self.tiff.is_ome\n        self.is_imagej = self.tiff.is_imagej\n        pixel_size = {'x': 1, 'y': 1}\n        position = {}\n        channels = []\n\n        if self.tiff.series:\n            page = self.tiff.series[0]\n        else:\n            page = self.tiff.pages.first\n        self.is_photometric_rgb = (self.tiff.pages.first.photometric == PHOTOMETRIC.RGB)\n        self.source_shape = page.shape\n        self.source_dim_order = page.axes.lower().replace('s', 'c').replace('r', '')\n\n        if self.is_ome:\n            metadata = metadata_to_dict(self.tiff.ome_metadata)\n            if metadata and not 'BinaryOnly' in metadata:\n                self.metadata = metadata\n            image0 = ensure_list(self.metadata.get('Image', []))[0]\n            self.is_plate = 'Plate' in self.metadata\n            if self.is_plate:\n                plate = self.metadata['Plate']\n                self.name = plate.get('Name')\n                rows = set()\n                columns = set()\n                wells = {}\n                fields = []\n                image_refs = {}\n                for well in ensure_list(plate['Well']):\n                    row = create_col_row_label(well['Row'], plate['RowNamingConvention'])\n                    column = create_col_row_label(well['Column'], plate['ColumnNamingConvention'])\n                    rows.add(row)\n                    columns.add(column)\n                    label = f'{row}{column}'\n                    wells[label] = well['ID']\n                    image_refs[label] = {}\n                    for sample in ensure_list(well.get('WellSample')):\n                        index = sample.get('Index', 0)\n                        image_refs[label][str(index)] = sample['ImageRef']['ID']\n                        if index not in fields:\n                            fields.append(index)\n                self.rows = sorted(rows)\n                self.columns = list(columns)\n                self.wells = list(wells.keys())\n                self.fields = fields\n                self.image_refs = image_refs\n            else:\n                self.name = image0.get('Name')\n            if not self.name:\n                self.name = get_filetitle(self.uri)\n            self.name = self.name.rstrip('.tiff').rstrip('.tif').rstrip('.ome')\n            pixels = image0.get('Pixels', {})\n            self.shape = pixels.get('SizeT'), pixels.get('SizeC'), pixels.get('SizeZ'), pixels.get('SizeY'), pixels.get('SizeX')\n            #self.source_dim_order = ''.join(reversed(pixels['DimensionOrder'].lower()))\n            self.dtype = np.dtype(pixels['Type'])\n            if 'PhysicalSizeX' in pixels:\n                pixel_size['x'] = convert_to_um(float(pixels.get('PhysicalSizeX')), pixels.get('PhysicalSizeXUnit'))\n            if 'PhysicalSizeY' in pixels:\n                pixel_size['y'] = convert_to_um(float(pixels.get('PhysicalSizeY')), pixels.get('PhysicalSizeYUnit'))\n            if 'PhysicalSizeZ' in pixels:\n                pixel_size['z'] = convert_to_um(float(pixels.get('PhysicalSizeZ')), pixels.get('PhysicalSizeZUnit'))\n            plane = pixels.get('Plane')\n            if plane:\n                if 'PositionX' in plane:\n                    position['x'] = convert_to_um(float(plane.get('PositionX')), plane.get('PositionXUnit'))\n                if 'PositionY' in plane:\n                    position['y'] = convert_to_um(float(plane.get('PositionY')), plane.get('PositionYUnit'))\n                if 'PositionZ' in plane:\n                    position['z'] = convert_to_um(float(plane.get('PositionZ')), plane.get('PositionZUnit'))\n            for channel0 in ensure_list(pixels.get('Channel')):\n                channel = {}\n                if 'Name' in channel0:\n                    channel['label'] = channel0['Name']\n                if 'Color' in channel0:\n                    channel['color'] = int_to_rgba(channel0['Color'])\n                channels.append(channel)\n        else:\n            self.is_plate = False\n            if self.is_imagej:\n                self.imagej_metadata = self.tiff.imagej_metadata\n                pixel_size_unit = self.imagej_metadata.get('unit', '').encode().decode('unicode_escape')\n                if 'scales' in self.imagej_metadata:\n                    for dim, scale in zip(['x', 'y'], self.imagej_metadata['scales'].split(',')):\n                        scale = scale.strip()\n                        if scale != '':\n                            pixel_size[dim] = convert_to_um(float(scale), pixel_size_unit)\n                if 'spacing' in self.imagej_metadata:\n                    pixel_size['z'] = convert_to_um(self.imagej_metadata['spacing'], pixel_size_unit)\n            self.metadata = tags_to_dict(self.tiff.pages.first.tags)\n            self.name = os.path.splitext(self.tiff.filename)[0]\n            nt = self.source_shape[self.source_dim_order.index('t')] if 't' in self.source_dim_order else 1\n            nc = self.source_shape[self.source_dim_order.index('c')] if 'c' in self.source_dim_order else 1\n            nz = self.source_shape[self.source_dim_order.index('z')] if 'z' in self.source_dim_order else 1\n            ny = self.source_shape[self.source_dim_order.index('y')] if 'y' in self.source_dim_order else 1\n            nx = self.source_shape[self.source_dim_order.index('x')] if 'x' in self.source_dim_order else 1\n            self.shape = nt, nc, nz, ny, nx\n            self.dtype = page.dtype\n            res_unit = self.metadata.get('ResolutionUnit', '')\n            if isinstance(res_unit, Enum):\n                res_unit = res_unit.name\n            res_unit = res_unit.lower()\n            if res_unit == 'none':\n                res_unit = ''\n            if 'x' in pixel_size:\n                res0 = convert_rational_value(self.metadata.get('XResolution'))\n                if res0 is not None and res0 != 0:\n                    pixel_size['x'] = convert_to_um(1 / res0, res_unit)\n            if 'y' in pixel_size:\n                res0 = convert_rational_value(self.metadata.get('YResolution'))\n                if res0 is not None and res0 != 0:\n                    pixel_size['y'] = convert_to_um(1 / res0, res_unit)\n        self.pixel_size = pixel_size\n        self.position = position\n        self.channels = channels\n        self.dim_order = 'tczyx'\n        return self.metadata\n\n    def is_screen(self):\n        \"\"\"\n        Checks if the source is a plate/screen.\n\n        Returns:\n            bool: True if plate/screen.\n        \"\"\"\n        return self.is_plate\n\n    def get_shape(self):\n        \"\"\"\n        Returns the shape of the image data.\n\n        Returns:\n            tuple: Shape of the image data.\n        \"\"\"\n        return self.shape\n\n    def get_data(self, well_id=None, field_id=None, as_dask=False, **kwargs):\n        \"\"\"\n        Gets image data from the TIFF file.\n\n        Returns:\n            ndarray: Image data.\n        \"\"\"\n        if as_dask and not self.is_plate:\n            lazy_array = dask.delayed(imread)(self.uri)\n            data = da.from_delayed(lazy_array, shape=self.source_shape, dtype=self.dtype)\n            data = data.rechunk(TILE_SIZE)\n        else:\n            if well_id is not None:\n                index = self.image_refs[well_id][str(field_id)]\n                self.tiff = TiffFile(self.image_filenames[index])\n            data = self.tiff.asarray()\n        return redimension_data(data, self.source_dim_order, self.dim_order)\n\n    def get_image_window(self, well_id=None, field_id=None, data=None):\n        # For RGB(A) uint8 images don't change color value range\n        if not (self.is_photometric_rgb and self.dtype == np.uint8):\n            if self.tiff.series:\n                page = self.tiff.series[0]\n            else:\n                page = self.tiff.pages.first\n            if hasattr(page, 'levels'):\n                small = None\n                for level in page.levels:\n                    if level.nbytes &lt; 1e8:  # less than 100 MB\n                        small = level\n                        break\n                if small:\n                    window_scanner = WindowScanner()\n                    window_scanner.process(small.asarray(), self.source_dim_order)\n                    return window_scanner.get_window()\n        return [], []\n\n\n    def get_name(self):\n        \"\"\"\n        Gets the image or plate name.\n\n        Returns:\n            str: Name.\n        \"\"\"\n        return self.name\n\n    def get_dim_order(self):\n        \"\"\"\n        Returns the dimension order string.\n\n        Returns:\n            str: Dimension order.\n        \"\"\"\n        return self.dim_order\n\n    def get_dtype(self):\n        \"\"\"\n        Returns the numpy dtype of the image data.\n\n        Returns:\n            dtype: Numpy dtype.\n        \"\"\"\n        return self.dtype\n\n    def get_pixel_size_um(self):\n        \"\"\"\n        Returns the pixel size in micrometers.\n\n        Returns:\n            dict: Pixel size for x, y, (and z).\n        \"\"\"\n        return self.pixel_size\n\n    def get_position_um(self, well_id=None):\n        \"\"\"\n        Returns the position in micrometers.\n\n        Returns:\n            dict: Position in micrometers.\n        \"\"\"\n        return self.position\n\n    def get_channels(self):\n        \"\"\"\n        Returns channel metadata.\n\n        Returns:\n            list: List of channel dicts.\n        \"\"\"\n        return self.channels\n\n    def get_nchannels(self):\n        \"\"\"\n        Returns the number of channels.\n\n        Returns:\n            int: Number of channels.\n        \"\"\"\n        return self.shape[1]\n\n    def is_rgb(self):\n        \"\"\"\n        Check if the source is a RGB(A) image.\n        \"\"\"\n        return self.is_photometric_rgb\n\n    def get_rows(self):\n        \"\"\"\n        Returns the list of row identifiers.\n\n        Returns:\n            list: Row identifiers.\n        \"\"\"\n        return self.rows\n\n    def get_columns(self):\n        \"\"\"\n        Returns the list of column identifiers.\n\n        Returns:\n            list: Column identifiers.\n        \"\"\"\n        return self.columns\n\n    def get_wells(self):\n        \"\"\"\n        Returns the list of well identifiers.\n\n        Returns:\n            list: Well identifiers.\n        \"\"\"\n        return self.wells\n\n    def get_time_points(self):\n        \"\"\"\n        Returns the list of time points.\n\n        Returns:\n            list: Time point IDs.\n        \"\"\"\n        nt = 1\n        if 't' in self.dim_order:\n            t_index = self.dim_order.index('t')\n            nt = self.tiff.pages.first.shape[t_index]\n        return list(range(nt))\n\n    def get_fields(self):\n        \"\"\"\n        Returns the list of field indices.\n\n        Returns:\n            list: Field indices.\n        \"\"\"\n        return self.fields\n\n    def get_acquisitions(self):\n        \"\"\"\n        Returns acquisition metadata (empty for TIFF).\n\n        Returns:\n            list: Empty list.\n        \"\"\"\n        return []\n\n    def get_total_data_size(self):\n        \"\"\"\n        Returns the estimated total data size.\n\n        Returns:\n            int: Total data size in bytes.\n        \"\"\"\n        total_size = np.prod(self.shape)\n        if self.is_plate:\n            total_size *= len(self.get_wells()) * len(self.get_fields())\n        return total_size\n\n    def close(self):\n        \"\"\"\n        Closes the TIFF file.\n        \"\"\"\n        self.tiff.close()\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.image_filenames","title":"<code>image_filenames = {}</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.TiffSource.TiffSource.metadata","title":"<code>metadata = metadata_to_dict(file.read().decode())</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.TiffSource.TiffSource.tiff","title":"<code>tiff = TiffFile(image_filename)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.TiffSource.TiffSource.__init__","title":"<code>__init__(uri, metadata={})</code>","text":"<p>Initialize TiffSource.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>Path to the TIFF file.</p> required <code>metadata</code> <code>dict</code> <p>Optional metadata dictionary.</p> <code>{}</code> Source code in <code>src/TiffSource.py</code> <pre><code>def __init__(self, uri, metadata={}):\n    \"\"\"\n    Initialize TiffSource.\n\n    Args:\n        uri (str): Path to the TIFF file.\n        metadata (dict): Optional metadata dictionary.\n    \"\"\"\n    super().__init__(uri, metadata)\n    image_filename = None\n    ext = os.path.splitext(uri)[1].lower()\n    if 'tif' in ext:\n        image_filename = uri\n    elif 'ome' in ext:\n        # read metadata\n        with open(uri, 'rb') as file:\n            self.metadata = metadata_to_dict(file.read().decode())\n        # try to open a ome-tiff file\n        self.image_filenames = {}\n        for image in ensure_list(self.metadata.get('Image', {})):\n            filename = image.get('Pixels', {}).get('TiffData', {}).get('UUID', {}).get('FileName')\n            if filename:\n                filepath = os.path.join(os.path.dirname(uri), filename)\n                self.image_filenames[image['ID']] = filepath\n                if image_filename is None:\n                    image_filename = filepath\n    else:\n        raise RuntimeError(f'Unsupported tiff extension: {ext}')\n\n    self.tiff = TiffFile(image_filename)\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.close","title":"<code>close()</code>","text":"<p>Closes the TIFF file.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def close(self):\n    \"\"\"\n    Closes the TIFF file.\n    \"\"\"\n    self.tiff.close()\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_acquisitions","title":"<code>get_acquisitions()</code>","text":"<p>Returns acquisition metadata (empty for TIFF).</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Empty list.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def get_acquisitions(self):\n    \"\"\"\n    Returns acquisition metadata (empty for TIFF).\n\n    Returns:\n        list: Empty list.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_channels","title":"<code>get_channels()</code>","text":"<p>Returns channel metadata.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of channel dicts.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def get_channels(self):\n    \"\"\"\n    Returns channel metadata.\n\n    Returns:\n        list: List of channel dicts.\n    \"\"\"\n    return self.channels\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_columns","title":"<code>get_columns()</code>","text":"<p>Returns the list of column identifiers.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Column identifiers.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def get_columns(self):\n    \"\"\"\n    Returns the list of column identifiers.\n\n    Returns:\n        list: Column identifiers.\n    \"\"\"\n    return self.columns\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_data","title":"<code>get_data(well_id=None, field_id=None, as_dask=False, **kwargs)</code>","text":"<p>Gets image data from the TIFF file.</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <p>Image data.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def get_data(self, well_id=None, field_id=None, as_dask=False, **kwargs):\n    \"\"\"\n    Gets image data from the TIFF file.\n\n    Returns:\n        ndarray: Image data.\n    \"\"\"\n    if as_dask and not self.is_plate:\n        lazy_array = dask.delayed(imread)(self.uri)\n        data = da.from_delayed(lazy_array, shape=self.source_shape, dtype=self.dtype)\n        data = data.rechunk(TILE_SIZE)\n    else:\n        if well_id is not None:\n            index = self.image_refs[well_id][str(field_id)]\n            self.tiff = TiffFile(self.image_filenames[index])\n        data = self.tiff.asarray()\n    return redimension_data(data, self.source_dim_order, self.dim_order)\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"<p>Returns the dimension order string.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Dimension order.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def get_dim_order(self):\n    \"\"\"\n    Returns the dimension order string.\n\n    Returns:\n        str: Dimension order.\n    \"\"\"\n    return self.dim_order\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_dtype","title":"<code>get_dtype()</code>","text":"<p>Returns the numpy dtype of the image data.</p> <p>Returns:</p> Name Type Description <code>dtype</code> <p>Numpy dtype.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def get_dtype(self):\n    \"\"\"\n    Returns the numpy dtype of the image data.\n\n    Returns:\n        dtype: Numpy dtype.\n    \"\"\"\n    return self.dtype\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_fields","title":"<code>get_fields()</code>","text":"<p>Returns the list of field indices.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Field indices.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def get_fields(self):\n    \"\"\"\n    Returns the list of field indices.\n\n    Returns:\n        list: Field indices.\n    \"\"\"\n    return self.fields\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_image_window","title":"<code>get_image_window(well_id=None, field_id=None, data=None)</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_image_window(self, well_id=None, field_id=None, data=None):\n    # For RGB(A) uint8 images don't change color value range\n    if not (self.is_photometric_rgb and self.dtype == np.uint8):\n        if self.tiff.series:\n            page = self.tiff.series[0]\n        else:\n            page = self.tiff.pages.first\n        if hasattr(page, 'levels'):\n            small = None\n            for level in page.levels:\n                if level.nbytes &lt; 1e8:  # less than 100 MB\n                    small = level\n                    break\n            if small:\n                window_scanner = WindowScanner()\n                window_scanner.process(small.asarray(), self.source_dim_order)\n                return window_scanner.get_window()\n    return [], []\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_name","title":"<code>get_name()</code>","text":"<p>Gets the image or plate name.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Name.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def get_name(self):\n    \"\"\"\n    Gets the image or plate name.\n\n    Returns:\n        str: Name.\n    \"\"\"\n    return self.name\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"<p>Returns the number of channels.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of channels.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def get_nchannels(self):\n    \"\"\"\n    Returns the number of channels.\n\n    Returns:\n        int: Number of channels.\n    \"\"\"\n    return self.shape[1]\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"<p>Returns the pixel size in micrometers.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Pixel size for x, y, (and z).</p> Source code in <code>src/TiffSource.py</code> <pre><code>def get_pixel_size_um(self):\n    \"\"\"\n    Returns the pixel size in micrometers.\n\n    Returns:\n        dict: Pixel size for x, y, (and z).\n    \"\"\"\n    return self.pixel_size\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_position_um","title":"<code>get_position_um(well_id=None)</code>","text":"<p>Returns the position in micrometers.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Position in micrometers.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def get_position_um(self, well_id=None):\n    \"\"\"\n    Returns the position in micrometers.\n\n    Returns:\n        dict: Position in micrometers.\n    \"\"\"\n    return self.position\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_rows","title":"<code>get_rows()</code>","text":"<p>Returns the list of row identifiers.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Row identifiers.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def get_rows(self):\n    \"\"\"\n    Returns the list of row identifiers.\n\n    Returns:\n        list: Row identifiers.\n    \"\"\"\n    return self.rows\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_shape","title":"<code>get_shape()</code>","text":"<p>Returns the shape of the image data.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>Shape of the image data.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def get_shape(self):\n    \"\"\"\n    Returns the shape of the image data.\n\n    Returns:\n        tuple: Shape of the image data.\n    \"\"\"\n    return self.shape\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_time_points","title":"<code>get_time_points()</code>","text":"<p>Returns the list of time points.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Time point IDs.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def get_time_points(self):\n    \"\"\"\n    Returns the list of time points.\n\n    Returns:\n        list: Time point IDs.\n    \"\"\"\n    nt = 1\n    if 't' in self.dim_order:\n        t_index = self.dim_order.index('t')\n        nt = self.tiff.pages.first.shape[t_index]\n    return list(range(nt))\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_total_data_size","title":"<code>get_total_data_size()</code>","text":"<p>Returns the estimated total data size.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Total data size in bytes.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def get_total_data_size(self):\n    \"\"\"\n    Returns the estimated total data size.\n\n    Returns:\n        int: Total data size in bytes.\n    \"\"\"\n    total_size = np.prod(self.shape)\n    if self.is_plate:\n        total_size *= len(self.get_wells()) * len(self.get_fields())\n    return total_size\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_wells","title":"<code>get_wells()</code>","text":"<p>Returns the list of well identifiers.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Well identifiers.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def get_wells(self):\n    \"\"\"\n    Returns the list of well identifiers.\n\n    Returns:\n        list: Well identifiers.\n    \"\"\"\n    return self.wells\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.init_metadata","title":"<code>init_metadata()</code>","text":"<p>Initializes and loads metadata from the (OME) TIFF file.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Metadata dictionary.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def init_metadata(self):\n    \"\"\"\n    Initializes and loads metadata from the (OME) TIFF file.\n\n    Returns:\n        dict: Metadata dictionary.\n    \"\"\"\n    self.is_ome = self.tiff.is_ome\n    self.is_imagej = self.tiff.is_imagej\n    pixel_size = {'x': 1, 'y': 1}\n    position = {}\n    channels = []\n\n    if self.tiff.series:\n        page = self.tiff.series[0]\n    else:\n        page = self.tiff.pages.first\n    self.is_photometric_rgb = (self.tiff.pages.first.photometric == PHOTOMETRIC.RGB)\n    self.source_shape = page.shape\n    self.source_dim_order = page.axes.lower().replace('s', 'c').replace('r', '')\n\n    if self.is_ome:\n        metadata = metadata_to_dict(self.tiff.ome_metadata)\n        if metadata and not 'BinaryOnly' in metadata:\n            self.metadata = metadata\n        image0 = ensure_list(self.metadata.get('Image', []))[0]\n        self.is_plate = 'Plate' in self.metadata\n        if self.is_plate:\n            plate = self.metadata['Plate']\n            self.name = plate.get('Name')\n            rows = set()\n            columns = set()\n            wells = {}\n            fields = []\n            image_refs = {}\n            for well in ensure_list(plate['Well']):\n                row = create_col_row_label(well['Row'], plate['RowNamingConvention'])\n                column = create_col_row_label(well['Column'], plate['ColumnNamingConvention'])\n                rows.add(row)\n                columns.add(column)\n                label = f'{row}{column}'\n                wells[label] = well['ID']\n                image_refs[label] = {}\n                for sample in ensure_list(well.get('WellSample')):\n                    index = sample.get('Index', 0)\n                    image_refs[label][str(index)] = sample['ImageRef']['ID']\n                    if index not in fields:\n                        fields.append(index)\n            self.rows = sorted(rows)\n            self.columns = list(columns)\n            self.wells = list(wells.keys())\n            self.fields = fields\n            self.image_refs = image_refs\n        else:\n            self.name = image0.get('Name')\n        if not self.name:\n            self.name = get_filetitle(self.uri)\n        self.name = self.name.rstrip('.tiff').rstrip('.tif').rstrip('.ome')\n        pixels = image0.get('Pixels', {})\n        self.shape = pixels.get('SizeT'), pixels.get('SizeC'), pixels.get('SizeZ'), pixels.get('SizeY'), pixels.get('SizeX')\n        #self.source_dim_order = ''.join(reversed(pixels['DimensionOrder'].lower()))\n        self.dtype = np.dtype(pixels['Type'])\n        if 'PhysicalSizeX' in pixels:\n            pixel_size['x'] = convert_to_um(float(pixels.get('PhysicalSizeX')), pixels.get('PhysicalSizeXUnit'))\n        if 'PhysicalSizeY' in pixels:\n            pixel_size['y'] = convert_to_um(float(pixels.get('PhysicalSizeY')), pixels.get('PhysicalSizeYUnit'))\n        if 'PhysicalSizeZ' in pixels:\n            pixel_size['z'] = convert_to_um(float(pixels.get('PhysicalSizeZ')), pixels.get('PhysicalSizeZUnit'))\n        plane = pixels.get('Plane')\n        if plane:\n            if 'PositionX' in plane:\n                position['x'] = convert_to_um(float(plane.get('PositionX')), plane.get('PositionXUnit'))\n            if 'PositionY' in plane:\n                position['y'] = convert_to_um(float(plane.get('PositionY')), plane.get('PositionYUnit'))\n            if 'PositionZ' in plane:\n                position['z'] = convert_to_um(float(plane.get('PositionZ')), plane.get('PositionZUnit'))\n        for channel0 in ensure_list(pixels.get('Channel')):\n            channel = {}\n            if 'Name' in channel0:\n                channel['label'] = channel0['Name']\n            if 'Color' in channel0:\n                channel['color'] = int_to_rgba(channel0['Color'])\n            channels.append(channel)\n    else:\n        self.is_plate = False\n        if self.is_imagej:\n            self.imagej_metadata = self.tiff.imagej_metadata\n            pixel_size_unit = self.imagej_metadata.get('unit', '').encode().decode('unicode_escape')\n            if 'scales' in self.imagej_metadata:\n                for dim, scale in zip(['x', 'y'], self.imagej_metadata['scales'].split(',')):\n                    scale = scale.strip()\n                    if scale != '':\n                        pixel_size[dim] = convert_to_um(float(scale), pixel_size_unit)\n            if 'spacing' in self.imagej_metadata:\n                pixel_size['z'] = convert_to_um(self.imagej_metadata['spacing'], pixel_size_unit)\n        self.metadata = tags_to_dict(self.tiff.pages.first.tags)\n        self.name = os.path.splitext(self.tiff.filename)[0]\n        nt = self.source_shape[self.source_dim_order.index('t')] if 't' in self.source_dim_order else 1\n        nc = self.source_shape[self.source_dim_order.index('c')] if 'c' in self.source_dim_order else 1\n        nz = self.source_shape[self.source_dim_order.index('z')] if 'z' in self.source_dim_order else 1\n        ny = self.source_shape[self.source_dim_order.index('y')] if 'y' in self.source_dim_order else 1\n        nx = self.source_shape[self.source_dim_order.index('x')] if 'x' in self.source_dim_order else 1\n        self.shape = nt, nc, nz, ny, nx\n        self.dtype = page.dtype\n        res_unit = self.metadata.get('ResolutionUnit', '')\n        if isinstance(res_unit, Enum):\n            res_unit = res_unit.name\n        res_unit = res_unit.lower()\n        if res_unit == 'none':\n            res_unit = ''\n        if 'x' in pixel_size:\n            res0 = convert_rational_value(self.metadata.get('XResolution'))\n            if res0 is not None and res0 != 0:\n                pixel_size['x'] = convert_to_um(1 / res0, res_unit)\n        if 'y' in pixel_size:\n            res0 = convert_rational_value(self.metadata.get('YResolution'))\n            if res0 is not None and res0 != 0:\n                pixel_size['y'] = convert_to_um(1 / res0, res_unit)\n    self.pixel_size = pixel_size\n    self.position = position\n    self.channels = channels\n    self.dim_order = 'tczyx'\n    return self.metadata\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.is_rgb","title":"<code>is_rgb()</code>","text":"<p>Check if the source is a RGB(A) image.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def is_rgb(self):\n    \"\"\"\n    Check if the source is a RGB(A) image.\n    \"\"\"\n    return self.is_photometric_rgb\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.is_screen","title":"<code>is_screen()</code>","text":"<p>Checks if the source is a plate/screen.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if plate/screen.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def is_screen(self):\n    \"\"\"\n    Checks if the source is a plate/screen.\n\n    Returns:\n        bool: True if plate/screen.\n    \"\"\"\n    return self.is_plate\n</code></pre>"},{"location":"references/#src.TiffSource.convert_rational_value","title":"<code>convert_rational_value(value)</code>","text":"<p>Converts a rational value tuple to a float.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple or None</code> <p>Rational value.</p> required <p>Returns:</p> Type Description <p>float or None: Converted value.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def convert_rational_value(value):\n    \"\"\"\n    Converts a rational value tuple to a float.\n\n    Args:\n        value (tuple or None): Rational value.\n\n    Returns:\n        float or None: Converted value.\n    \"\"\"\n    if value is not None and isinstance(value, tuple):\n        if value[0] == value[1]:\n            value = value[0]\n        else:\n            value = value[0] / value[1]\n    return value\n</code></pre>"},{"location":"references/#src.TiffSource.tags_to_dict","title":"<code>tags_to_dict(tags)</code>","text":"<p>Converts TIFF tags to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>tags</code> <p>TIFF tags object.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Tag name-value mapping.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def tags_to_dict(tags):\n    \"\"\"\n    Converts TIFF tags to a dictionary.\n\n    Args:\n        tags: TIFF tags object.\n\n    Returns:\n        dict: Tag name-value mapping.\n    \"\"\"\n    tag_dict = {}\n    for tag in tags.values():\n        tag_dict[tag.name] = tag.value\n    return tag_dict\n</code></pre>"},{"location":"references/#src.Timer","title":"<code>Timer</code>","text":""},{"location":"references/#src.Timer.Timer","title":"<code>Timer</code>","text":"<p>               Bases: <code>object</code></p> <p>Context manager for timing code execution and logging the elapsed time.</p> Source code in <code>src/Timer.py</code> <pre><code>class Timer(object):\n    \"\"\"\n    Context manager for timing code execution and logging the elapsed time.\n    \"\"\"\n\n    def __init__(self, title, auto_unit=True, verbose=True):\n        \"\"\"\n        Initialize the Timer.\n\n        Args:\n            title (str): Description for the timed block.\n            auto_unit (bool): Automatically select time unit (seconds/minutes/hours).\n            verbose (bool): If True, log the elapsed time.\n        \"\"\"\n        self.title = title\n        self.auto_unit = auto_unit\n        self.verbose = verbose\n\n    def __enter__(self):\n        \"\"\"\n        Start timing.\n        \"\"\"\n        self.ptime_start = time.process_time()\n        self.time_start = time.time()\n\n    def __exit__(self, type, value, traceback):\n        \"\"\"\n        Stop timing and log the elapsed time.\n\n        Args:\n            type: Exception type, if any.\n            value: Exception value, if any.\n            traceback: Exception traceback, if any.\n        \"\"\"\n        if self.verbose:\n            ptime_end = time.process_time()\n            time_end = time.time()\n            pelapsed = ptime_end - self.ptime_start\n            elapsed = time_end - self.time_start\n            unit = 'seconds'\n            if self.auto_unit and elapsed &gt;= 60:\n                pelapsed /= 60\n                elapsed /= 60\n                unit = 'minutes'\n                if elapsed &gt;= 60:\n                    pelapsed /= 60\n                    elapsed /= 60\n                    unit = 'hours'\n            logging.info(f'Time {self.title}: {elapsed:.1f} ({pelapsed:.1f}) {unit}')\n</code></pre>"},{"location":"references/#src.Timer.Timer.auto_unit","title":"<code>auto_unit = auto_unit</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.Timer.Timer.title","title":"<code>title = title</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.Timer.Timer.verbose","title":"<code>verbose = verbose</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.Timer.Timer.__enter__","title":"<code>__enter__()</code>","text":"<p>Start timing.</p> Source code in <code>src/Timer.py</code> <pre><code>def __enter__(self):\n    \"\"\"\n    Start timing.\n    \"\"\"\n    self.ptime_start = time.process_time()\n    self.time_start = time.time()\n</code></pre>"},{"location":"references/#src.Timer.Timer.__exit__","title":"<code>__exit__(type, value, traceback)</code>","text":"<p>Stop timing and log the elapsed time.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <p>Exception type, if any.</p> required <code>value</code> <p>Exception value, if any.</p> required <code>traceback</code> <p>Exception traceback, if any.</p> required Source code in <code>src/Timer.py</code> <pre><code>def __exit__(self, type, value, traceback):\n    \"\"\"\n    Stop timing and log the elapsed time.\n\n    Args:\n        type: Exception type, if any.\n        value: Exception value, if any.\n        traceback: Exception traceback, if any.\n    \"\"\"\n    if self.verbose:\n        ptime_end = time.process_time()\n        time_end = time.time()\n        pelapsed = ptime_end - self.ptime_start\n        elapsed = time_end - self.time_start\n        unit = 'seconds'\n        if self.auto_unit and elapsed &gt;= 60:\n            pelapsed /= 60\n            elapsed /= 60\n            unit = 'minutes'\n            if elapsed &gt;= 60:\n                pelapsed /= 60\n                elapsed /= 60\n                unit = 'hours'\n        logging.info(f'Time {self.title}: {elapsed:.1f} ({pelapsed:.1f}) {unit}')\n</code></pre>"},{"location":"references/#src.Timer.Timer.__init__","title":"<code>__init__(title, auto_unit=True, verbose=True)</code>","text":"<p>Initialize the Timer.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Description for the timed block.</p> required <code>auto_unit</code> <code>bool</code> <p>Automatically select time unit (seconds/minutes/hours).</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>If True, log the elapsed time.</p> <code>True</code> Source code in <code>src/Timer.py</code> <pre><code>def __init__(self, title, auto_unit=True, verbose=True):\n    \"\"\"\n    Initialize the Timer.\n\n    Args:\n        title (str): Description for the timed block.\n        auto_unit (bool): Automatically select time unit (seconds/minutes/hours).\n        verbose (bool): If True, log the elapsed time.\n    \"\"\"\n    self.title = title\n    self.auto_unit = auto_unit\n    self.verbose = verbose\n</code></pre>"},{"location":"references/#src.WindowScanner","title":"<code>WindowScanner</code>","text":""},{"location":"references/#src.WindowScanner.WindowScanner","title":"<code>WindowScanner</code>","text":"<p>Computes quantile-based min/max window for image channels.</p> Source code in <code>src/WindowScanner.py</code> <pre><code>class WindowScanner:\n    \"\"\"\n    Computes quantile-based min/max window for image channels.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize WindowScanner.\n        \"\"\"\n        self.mins = []\n        self.maxs = []\n\n    def process(self, data, dim_order, min_quantile=0.01, max_quantile=0.99):\n        \"\"\"\n        Processes image data to compute min/max quantiles for each channel.\n\n        Args:\n            data (ndarray): Image data.\n            dim_order (str): Dimension order string.\n            min_quantile (float): Lower quantile.\n            max_quantile (float): Upper quantile.\n        \"\"\"\n        axis = []\n        if 't' in dim_order:\n            axis += [dim_order.index('t')]\n        if 'z' in dim_order:\n            axis += [dim_order.index('z')]\n        axis += [dim_order.index('y'), dim_order.index('x')]\n        values = np.quantile(data, axis=axis, q=[min_quantile, max_quantile])\n        mins, maxs = values\n        if len(self.mins) == 0:\n            self.mins = mins\n            self.maxs = maxs\n        else:\n            self.mins = np.min([mins, self.mins], axis=0)\n            self.maxs = np.max([maxs, self.maxs], axis=0)\n\n    def get_window(self):\n        \"\"\"\n        Returns the computed min/max window for channels.\n\n        Returns:\n            tuple: (min dict, max dict)\n        \"\"\"\n        return np.array(self.mins).tolist(), np.array(self.maxs).tolist()\n</code></pre>"},{"location":"references/#src.WindowScanner.WindowScanner.maxs","title":"<code>maxs = []</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.WindowScanner.WindowScanner.mins","title":"<code>mins = []</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.WindowScanner.WindowScanner.__init__","title":"<code>__init__()</code>","text":"<p>Initialize WindowScanner.</p> Source code in <code>src/WindowScanner.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize WindowScanner.\n    \"\"\"\n    self.mins = []\n    self.maxs = []\n</code></pre>"},{"location":"references/#src.WindowScanner.WindowScanner.get_window","title":"<code>get_window()</code>","text":"<p>Returns the computed min/max window for channels.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(min dict, max dict)</p> Source code in <code>src/WindowScanner.py</code> <pre><code>def get_window(self):\n    \"\"\"\n    Returns the computed min/max window for channels.\n\n    Returns:\n        tuple: (min dict, max dict)\n    \"\"\"\n    return np.array(self.mins).tolist(), np.array(self.maxs).tolist()\n</code></pre>"},{"location":"references/#src.WindowScanner.WindowScanner.process","title":"<code>process(data, dim_order, min_quantile=0.01, max_quantile=0.99)</code>","text":"<p>Processes image data to compute min/max quantiles for each channel.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Image data.</p> required <code>dim_order</code> <code>str</code> <p>Dimension order string.</p> required <code>min_quantile</code> <code>float</code> <p>Lower quantile.</p> <code>0.01</code> <code>max_quantile</code> <code>float</code> <p>Upper quantile.</p> <code>0.99</code> Source code in <code>src/WindowScanner.py</code> <pre><code>def process(self, data, dim_order, min_quantile=0.01, max_quantile=0.99):\n    \"\"\"\n    Processes image data to compute min/max quantiles for each channel.\n\n    Args:\n        data (ndarray): Image data.\n        dim_order (str): Dimension order string.\n        min_quantile (float): Lower quantile.\n        max_quantile (float): Upper quantile.\n    \"\"\"\n    axis = []\n    if 't' in dim_order:\n        axis += [dim_order.index('t')]\n    if 'z' in dim_order:\n        axis += [dim_order.index('z')]\n    axis += [dim_order.index('y'), dim_order.index('x')]\n    values = np.quantile(data, axis=axis, q=[min_quantile, max_quantile])\n    mins, maxs = values\n    if len(self.mins) == 0:\n        self.mins = mins\n        self.maxs = maxs\n    else:\n        self.mins = np.min([mins, self.mins], axis=0)\n        self.maxs = np.max([maxs, self.maxs], axis=0)\n</code></pre>"},{"location":"references/#src.color_conversion","title":"<code>color_conversion</code>","text":""},{"location":"references/#src.color_conversion.hexrgb_to_rgba","title":"<code>hexrgb_to_rgba(hexrgb)</code>","text":"Source code in <code>src/color_conversion.py</code> <pre><code>def hexrgb_to_rgba(hexrgb: str) -&gt; list:\n    hexrgb = hexrgb.lstrip('#')\n    if len(hexrgb) == 6:\n        hexrgb += 'FF'  # add alpha\n    rgba = int_to_rgba(eval('0x' + hexrgb))\n    return rgba\n</code></pre>"},{"location":"references/#src.color_conversion.int_to_rgba","title":"<code>int_to_rgba(intrgba)</code>","text":"Source code in <code>src/color_conversion.py</code> <pre><code>def int_to_rgba(intrgba: int) -&gt; list:\n    signed = (intrgba &lt; 0)\n    rgba = [x / 255 for x in intrgba.to_bytes(4, signed=signed, byteorder=\"big\")]\n    if rgba[-1] == 0:\n        rgba[-1] = 1\n    return rgba\n</code></pre>"},{"location":"references/#src.color_conversion.rgba_to_hexrgb","title":"<code>rgba_to_hexrgb(rgba)</code>","text":"Source code in <code>src/color_conversion.py</code> <pre><code>def rgba_to_hexrgb(rgba: list) -&gt; str:\n    hexrgb = ''.join([hex(int(x * 255))[2:].upper().zfill(2) for x in rgba[:3]])\n    return hexrgb\n</code></pre>"},{"location":"references/#src.color_conversion.rgba_to_int","title":"<code>rgba_to_int(rgba)</code>","text":"Source code in <code>src/color_conversion.py</code> <pre><code>def rgba_to_int(rgba: list) -&gt; int:\n    intrgba = int.from_bytes([int(x * 255) for x in rgba], signed=True, byteorder=\"big\")\n    return intrgba\n</code></pre>"},{"location":"references/#src.helper","title":"<code>helper</code>","text":""},{"location":"references/#src.helper.create_incucyte_source","title":"<code>create_incucyte_source(filename, plate_id=None)</code>","text":"<p>Create an IncucyteSource object for a specific plate.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the Incucyte archive folder or .icarch file.</p> required <code>plate_id</code> <code>str</code> <p>Specific plate ID to process. If None,                      uses the first available plate if multiple                      plates exist.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>IncucyteSource</code> <p>Source object for the specified plate.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path is not a valid Incucyte archive.</p> Source code in <code>src/helper.py</code> <pre><code>def create_incucyte_source(filename, plate_id=None):\n    \"\"\"\n    Create an IncucyteSource object for a specific plate.\n\n    Args:\n        filename (str): Path to the Incucyte archive folder or .icarch file.\n        plate_id (str, optional): Specific plate ID to process. If None,\n                                 uses the first available plate if multiple\n                                 plates exist.\n\n    Returns:\n        IncucyteSource: Source object for the specified plate.\n\n    Raises:\n        ValueError: If the path is not a valid Incucyte archive.\n    \"\"\"\n    # If it's an .icarch file, use its parent folder\n    if os.path.isfile(filename) and filename.lower().endswith('.icarch'):\n        archive_folder = os.path.dirname(filename)\n    elif os.path.isdir(filename):\n        archive_folder = filename\n    else:\n        raise ValueError(\n            f'Invalid Incucyte archive path. Expected folder or .icarch '\n            f'file: {filename}'\n        )\n\n    from src.IncucyteSource import IncucyteSource\n    return IncucyteSource(archive_folder, plate_id=plate_id)\n</code></pre>"},{"location":"references/#src.helper.create_source","title":"<code>create_source(filename, **kwargs)</code>","text":"<p>Create an image source object based on the input file extension.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the input file or Incucyte .icarch file.</p> required <code>**kwargs</code> <p>Source-specific parameters (e.g., plate_id for Incucyte).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ImageSource</code> <p>Source object for the input file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file format is unsupported.</p> Source code in <code>src/helper.py</code> <pre><code>def create_source(filename, **kwargs):\n    \"\"\"\n    Create an image source object based on the input file extension.\n\n    Args:\n        filename (str): Path to the input file or Incucyte .icarch file.\n        **kwargs: Source-specific parameters (e.g., plate_id for Incucyte).\n\n    Returns:\n        ImageSource: Source object for the input file.\n\n    Raises:\n        ValueError: If the file format is unsupported.\n    \"\"\"\n    input_ext = os.path.splitext(filename)[1].lower()\n\n    if input_ext == '.db':\n        from src.ImageDbSource import ImageDbSource\n        source = ImageDbSource(filename)\n    elif input_ext == '.icarch':\n        # Incucyte archive file - use parent folder for source\n        if not os.path.isfile(filename):\n            raise ValueError(\n                f'Incucyte archive file not found: {filename}'\n            )\n        archive_folder = os.path.dirname(filename)\n        # Verify EssenFiles folder exists\n        essen_path = os.path.join(archive_folder, 'EssenFiles')\n        if not os.path.isdir(essen_path):\n            raise ValueError(\n                f'EssenFiles folder not found in: {archive_folder}. '\n                f'Expected Incucyte archive structure.'\n            )\n        from src.IncucyteSource import IncucyteSource\n        # Pass kwargs to IncucyteSource (e.g., plate_id)\n        source = IncucyteSource(archive_folder, **kwargs)\n    elif input_ext == '.isyntax':\n        from src.ISyntaxSource import ISyntaxSource\n        source = ISyntaxSource(filename)\n    elif 'zar' in input_ext:\n        from src.OmeZarrSource import OmeZarrSource\n        source = OmeZarrSource(filename)\n    elif 'tif' in input_ext or input_ext == '.ome':\n        from src.TiffSource import TiffSource\n        source = TiffSource(filename)\n    else:\n        raise ValueError(f'Unsupported input file format: {input_ext}')\n    return source\n</code></pre>"},{"location":"references/#src.helper.create_writer","title":"<code>create_writer(output_format, verbose=False)</code>","text":"<p>Create a writer object and output extension based on the output format.</p> <p>Parameters:</p> Name Type Description Default <code>output_format</code> <code>str</code> <p>Output format string.</p> required <code>verbose</code> <code>bool</code> <p>If True, enables verbose output.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(writer object, output file extension)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the output format is unsupported.</p> Source code in <code>src/helper.py</code> <pre><code>def create_writer(output_format, verbose=False):\n    \"\"\"\n    Create a writer object and output extension based on the output format.\n\n    Args:\n        output_format (str): Output format string.\n        verbose (bool): If True, enables verbose output.\n\n    Returns:\n        tuple: (writer object, output file extension)\n\n    Raises:\n        ValueError: If the output format is unsupported.\n    \"\"\"\n    if 'zar' in output_format:\n        if '3' in output_format:\n            zarr_version = 3\n            ome_version = '0.5'\n        else:\n            zarr_version = 2\n            ome_version = '0.4'\n        from src.OmeZarrWriter import OmeZarrWriter\n        writer = OmeZarrWriter(zarr_version=zarr_version, ome_version=ome_version, verbose=verbose)\n        ext = '.ome.zarr'\n    elif 'tif' in output_format:\n        from src.OmeTiffWriter import OmeTiffWriter\n        writer = OmeTiffWriter(verbose=verbose)\n        ext = '.ome.tiff'\n    else:\n        raise ValueError(f'Unsupported output format: {output_format}')\n    return writer, ext\n</code></pre>"},{"location":"references/#src.helper.get_incucyte_plates","title":"<code>get_incucyte_plates(filename)</code>","text":"<p>Get all available plate IDs from an Incucyte archive.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the Incucyte archive folder or .icarch file.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of plate IDs (strings) found in the archive.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path is not a valid Incucyte archive.</p> Source code in <code>src/helper.py</code> <pre><code>def get_incucyte_plates(filename):\n    \"\"\"\n    Get all available plate IDs from an Incucyte archive.\n\n    Args:\n        filename (str): Path to the Incucyte archive folder or .icarch file.\n\n    Returns:\n        list: List of plate IDs (strings) found in the archive.\n\n    Raises:\n        ValueError: If the path is not a valid Incucyte archive.\n    \"\"\"\n    # If it's an .icarch file, use its parent folder\n    if os.path.isfile(filename) and filename.lower().endswith('.icarch'):\n        archive_folder = os.path.dirname(filename)\n    elif os.path.isdir(filename):\n        archive_folder = filename\n    else:\n        raise ValueError(\n            f'Invalid Incucyte archive path. Expected folder or .icarch '\n            f'file: {filename}'\n        )\n\n    from src.IncucyteSource import IncucyteSource\n    return IncucyteSource.get_available_plates(archive_folder)\n</code></pre>"},{"location":"references/#src.ome_tiff_util","title":"<code>ome_tiff_util</code>","text":""},{"location":"references/#src.ome_tiff_util.create_binaryonly_metadata","title":"<code>create_binaryonly_metadata(metadata_filename, companion_uuid)</code>","text":"Source code in <code>src/ome_tiff_util.py</code> <pre><code>def create_binaryonly_metadata(metadata_filename, companion_uuid):\n    ome = OME()\n    ome.uuid = create_uuid()\n    ome.creator = f'nl.biomero.OmeTiffWriter {VERSION}'\n    ome.binary_only = OME.BinaryOnly(metadata_file=metadata_filename, uuid=companion_uuid)\n    return to_xml(ome), ome.uuid\n</code></pre>"},{"location":"references/#src.ome_tiff_util.create_col_row_label","title":"<code>create_col_row_label(index, naming_convention)</code>","text":"Source code in <code>src/ome_tiff_util.py</code> <pre><code>def create_col_row_label(index, naming_convention):\n    label = index + 1\n    if naming_convention.lower() == NamingConvention.LETTER.name.lower():\n        label = chr(ord('A') + index)\n    return str(label)\n</code></pre>"},{"location":"references/#src.ome_tiff_util.create_image_metadata","title":"<code>create_image_metadata(source, image_name, image_uuid=None, image_filename=None)</code>","text":"Source code in <code>src/ome_tiff_util.py</code> <pre><code>def create_image_metadata(source, image_name, image_uuid=None, image_filename=None):\n    dim_order = source.get_dim_order()\n    t, c, z, y, x = source.get_shape()\n    pixel_size = source.get_pixel_size_um()\n    channels = source.get_channels()\n    ome_channels = []\n    if len(channels) &lt; c:\n        if source.is_rgb():\n            ome_channels.append(Channel(name='rgb', samples_per_pixel=3))\n        else:\n            ome_channels = [Channel(name=f'{channeli}', samples_per_pixel=1) for channeli in range(c)]\n    else:\n        for channeli, channel in enumerate(channels):\n            ome_channel = Channel()\n            ome_channel.name = channel.get('label', channel.get('Name', f'{channeli}'))\n            ome_channel.samples_per_pixel = 1\n            color = channel.get('color', channel.get('Color'))\n            if color is not None:\n                ome_channel.color = Color(rgba_to_int(color))\n            ome_channels.append(ome_channel)\n\n    tiff_data = TiffData()\n    tiff_data.uuid = TiffData.UUID(value=image_uuid, file_name=image_filename)\n\n    pixels = Pixels(\n        dimension_order=Pixels_DimensionOrder(dim_order[::-1].upper()),\n        type=PixelType(str(source.get_dtype())),\n        channels=ome_channels,\n        size_t=t, size_c=c, size_z=z, size_y=y, size_x=x,\n        tiff_data_blocks=[tiff_data]\n    )\n    if 'x' in pixel_size:\n        pixels.physical_size_x = pixel_size['x']\n        pixels.physical_size_x_unit = UnitsLength.MICROMETER\n    if 'y' in pixel_size:\n        pixels.physical_size_y = pixel_size['y']\n        pixels.physical_size_y_unit = UnitsLength.MICROMETER\n    if 'z' in pixel_size:\n        pixels.physical_size_z = pixel_size['z']\n        pixels.physical_size_z_unit = UnitsLength.MICROMETER\n\n    image = Image(name=image_name, pixels=pixels)\n    index = pixels.id.split(':')[1]\n    for channeli, channel in enumerate(pixels.channels):\n        channel.id = f'Channel:{index}:{channeli}'\n    return image\n</code></pre>"},{"location":"references/#src.ome_tiff_util.create_metadata","title":"<code>create_metadata(source, uuid=None, image_uuids=None, image_filenames=None, wells=None)</code>","text":"Source code in <code>src/ome_tiff_util.py</code> <pre><code>def create_metadata(source, uuid=None, image_uuids=None, image_filenames=None, wells=None):\n    ome = OME()\n    if uuid is None:\n        uuid = create_uuid()\n    ome.uuid = uuid\n    ome.creator = f'nl.biomero.OmeTiffWriter {VERSION}'\n\n    if wells is None:\n        wells = source.get_wells()\n\n    if source.is_screen():\n        columns = source.get_columns()\n        rows = source.get_rows()\n\n        plate = Plate()\n        plate.name = source.get_name()\n        plate.columns = len(columns)\n        plate.rows = len(rows)\n        plate.row_naming_convention = get_col_row_type(rows)\n        plate.column_naming_convention = get_col_row_type(columns)\n\n        image_index = 0\n        for well_id in wells:\n            row, col = split_well_name(well_id)\n            col_index = columns.index(col)\n            row_index = rows.index(row)\n            well = Well(column=col_index, row=row_index)\n            well.id = f'Well:{col_index}:{row_index}'\n            for field in source.get_fields():\n                sample = WellSample(index=image_index)\n                sample.id = f'WellSample:{col_index}:{row_index}:{field}'\n                position = source.get_position_um(well_id)\n                if 'x' in position:\n                    sample.position_x = position['x']\n                    sample.position_x_unit = UnitsLength.MICROMETER\n                if 'y' in position:\n                    sample.position_y = position['y']\n                    sample.position_y_unit = UnitsLength.MICROMETER\n\n                image_name = f'Well {well_id}, Field #{int(field) + 1}'\n                image = create_image_metadata(source,\n                                              image_name,\n                                              image_uuids[image_index],\n                                              image_filenames[image_index])\n                ome.images.append(image)\n\n                image_ref = ImageRef(id=image.id)   # assign id at instantiation to avoid auto sequence increment\n                sample.image_ref = image_ref\n                well.well_samples.append(sample)\n\n                image_index += 1\n\n            plate.wells.append(well)\n\n        ome.plates = [plate]\n    else:\n        ome.images = [create_image_metadata(source, source.get_name(), ome.uuid, image_filenames[0])]\n\n    return to_xml(ome)\n</code></pre>"},{"location":"references/#src.ome_tiff_util.create_resolution_metadata","title":"<code>create_resolution_metadata(source)</code>","text":"Source code in <code>src/ome_tiff_util.py</code> <pre><code>def create_resolution_metadata(source):\n    pixel_size_um = source.get_pixel_size_um()\n    resolution_unit = 'CENTIMETER'\n    resolution = [1e4 / pixel_size_um[dim] for dim in 'xy']\n    return resolution, resolution_unit\n</code></pre>"},{"location":"references/#src.ome_tiff_util.create_uuid","title":"<code>create_uuid()</code>","text":"Source code in <code>src/ome_tiff_util.py</code> <pre><code>def create_uuid():\n    return f'urn:uuid:{uuid.uuid4()}'\n</code></pre>"},{"location":"references/#src.ome_tiff_util.get_col_row_type","title":"<code>get_col_row_type(labels)</code>","text":"Source code in <code>src/ome_tiff_util.py</code> <pre><code>def get_col_row_type(labels):\n    is_digits = [label.isdigit() for label in labels]\n    if np.all(is_digits):\n        naming_convention = NamingConvention.NUMBER\n    else:\n        naming_convention = NamingConvention.LETTER\n    return naming_convention\n</code></pre>"},{"location":"references/#src.ome_tiff_util.metadata_to_dict","title":"<code>metadata_to_dict(xml_metadata)</code>","text":"Source code in <code>src/ome_tiff_util.py</code> <pre><code>def metadata_to_dict(xml_metadata):\n    metadata = xml2dict(xml_metadata)\n    if 'OME' in metadata:\n        metadata = metadata['OME']\n    return metadata\n</code></pre>"},{"location":"references/#src.ome_zarr_util","title":"<code>ome_zarr_util</code>","text":""},{"location":"references/#src.ome_zarr_util.create_axes_metadata","title":"<code>create_axes_metadata(dimension_order)</code>","text":"<p>Create axes metadata for OME-Zarr from dimension order.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of axis metadata dictionaries.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_axes_metadata(dimension_order):\n    \"\"\"\n    Create axes metadata for OME-Zarr from dimension order.\n\n    Args:\n        dimension_order (str): String of dimension characters.\n\n    Returns:\n        list: List of axis metadata dictionaries.\n    \"\"\"\n    axes = []\n    for dimension in dimension_order:\n        unit1 = None\n        if dimension == 't':\n            type1 = 'time'\n            unit1 = 'millisecond'\n        elif dimension == 'c':\n            type1 = 'channel'\n        else:\n            type1 = 'space'\n            unit1 = 'micrometer'\n        axis = {'name': dimension, 'type': type1}\n        if unit1 is not None and unit1 != '':\n            axis['unit'] = unit1\n        axes.append(axis)\n    return axes\n</code></pre>"},{"location":"references/#src.ome_zarr_util.create_channel_metadata","title":"<code>create_channel_metadata(dtype, channels, nchannels, is_rgb, window, ome_version)</code>","text":"<p>Create channel metadata for OME-Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <p>Numpy dtype of image data.</p> required <code>channels</code> <code>list</code> <p>List of channel dicts.</p> required <code>nchannels</code> <code>int</code> <p>Number of channels.</p> required <code>window</code> <code>tuple</code> <p>Min/max window values.</p> required <code>ome_version</code> <code>str</code> <p>OME-Zarr version.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Channel metadata dictionary.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_channel_metadata(dtype, channels, nchannels, is_rgb, window, ome_version):\n    \"\"\"\n    Create channel metadata for OME-Zarr.\n\n    Args:\n        dtype: Numpy dtype of image data.\n        channels (list): List of channel dicts.\n        nchannels (int): Number of channels.\n        window (tuple): Min/max window values.\n        ome_version (str): OME-Zarr version.\n\n    Returns:\n        dict: Channel metadata dictionary.\n    \"\"\"\n    if len(channels) &lt; nchannels:\n        labels = []\n        colors = []\n        if is_rgb and nchannels in (3, 4):\n            labels = ['Red', 'Green', 'Blue']\n            colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n        if is_rgb and nchannels == 4:\n            labels += ['Alpha']\n            colors += [(1, 1, 1)]\n        channels = [{'label': label, 'color': color} for label, color in zip(labels, colors)]\n\n    omezarr_channels = []\n    starts, ends = window\n    for channeli, channel in enumerate(channels):\n        omezarr_channel = {'label': channel.get('label', channel.get('Name', f'{channeli}')), 'active': True}\n        color = channel.get('color', channel.get('Color'))\n        if color is not None:\n            omezarr_channel['color'] = rgba_to_hexrgb(color)\n        if dtype.kind == 'f':\n            min, max = 0, 1\n        else:\n            info = np.iinfo(dtype)\n            min, max = info.min, info.max\n        if starts and ends:\n            start, end = starts[channeli], ends[channeli]\n        else:\n            start, end = min, max\n        omezarr_channel['window'] = {'min': min, 'max': max, 'start': start, 'end': end}\n        omezarr_channels.append(omezarr_channel)\n\n    metadata = {\n        'version': ome_version,\n        'channels': omezarr_channels,\n    }\n    return metadata\n</code></pre>"},{"location":"references/#src.ome_zarr_util.create_transformation_metadata","title":"<code>create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um=None)</code>","text":"<p>Create transformation metadata (scale and translation) for OME-Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <code>pixel_size_um</code> <code>dict</code> <p>Pixel size in micrometers per dimension.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <code>translation_um</code> <code>dict</code> <p>Translation in micrometers per dimension.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>List of transformation metadata dictionaries.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um=None):\n    \"\"\"\n    Create transformation metadata (scale and translation) for OME-Zarr.\n\n    Args:\n        dimension_order (str): String of dimension characters.\n        pixel_size_um (dict): Pixel size in micrometers per dimension.\n        scale (float): Scaling factor.\n        translation_um (dict, optional): Translation in micrometers per dimension.\n\n    Returns:\n        list: List of transformation metadata dictionaries.\n    \"\"\"\n    metadata = []\n    pixel_size_scale = []\n    translation_scale = []\n    for dimension in dimension_order:\n        pixel_size_scale1 = pixel_size_um.get(dimension, 1)\n        if pixel_size_scale1 == 0:\n            pixel_size_scale1 = 1\n        if dimension in ['x', 'y']:\n            pixel_size_scale1 /= scale\n        pixel_size_scale.append(pixel_size_scale1)\n\n        if translation_um is not None:\n            translation1 = translation_um.get(dimension, 0)\n            if dimension in ['x', 'y']:\n                translation1 *= scale\n            translation_scale.append(translation1)\n\n    metadata.append({'type': 'scale', 'scale': pixel_size_scale})\n    if translation_um is not None:\n        metadata.append({'type': 'translation', 'translation': translation_scale})\n    return metadata\n</code></pre>"},{"location":"references/#src.ome_zarr_util.scale_dimensions_dict","title":"<code>scale_dimensions_dict(shape0, scale)</code>","text":"<p>Scale x and y dimensions in a shape dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>shape0</code> <code>dict</code> <p>Original shape dictionary.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Scaled shape dictionary.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def scale_dimensions_dict(shape0, scale):\n    \"\"\"\n    Scale x and y dimensions in a shape dictionary.\n\n    Args:\n        shape0 (dict): Original shape dictionary.\n        scale (float): Scaling factor.\n\n    Returns:\n        dict: Scaled shape dictionary.\n    \"\"\"\n    shape = {}\n    if scale == 1:\n        return shape0\n    for dimension, shape1 in shape0.items():\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape[dimension] = shape1\n    return shape\n</code></pre>"},{"location":"references/#src.ome_zarr_util.scale_dimensions_xy","title":"<code>scale_dimensions_xy(shape0, dimension_order, scale)</code>","text":"<p>Scale x and y dimensions in a shape tuple.</p> <p>Parameters:</p> Name Type Description Default <code>shape0</code> <code>tuple</code> <p>Original shape.</p> required <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Scaled shape.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def scale_dimensions_xy(shape0, dimension_order, scale):\n    \"\"\"\n    Scale x and y dimensions in a shape tuple.\n\n    Args:\n        shape0 (tuple): Original shape.\n        dimension_order (str): String of dimension characters.\n        scale (float): Scaling factor.\n\n    Returns:\n        list: Scaled shape.\n    \"\"\"\n    shape = []\n    if scale == 1:\n        return shape0\n    for shape1, dimension in zip(shape0, dimension_order):\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape.append(shape1)\n    return shape\n</code></pre>"},{"location":"references/#src.parameters","title":"<code>parameters</code>","text":""},{"location":"references/#src.parameters.CONVERSION_ATTEMPTS","title":"<code>CONVERSION_ATTEMPTS = 3</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.parameters.PYRAMID_DOWNSCALE","title":"<code>PYRAMID_DOWNSCALE = 2</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.parameters.PYRAMID_LEVELS","title":"<code>PYRAMID_LEVELS = 6</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.parameters.TIFF_COMPRESSION","title":"<code>TIFF_COMPRESSION = 'LZW'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.parameters.TILE_SIZE","title":"<code>TILE_SIZE = 1024</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.parameters.VERSION","title":"<code>VERSION = 'v0.1.2'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.parameters.ZARR_CHUNK_SIZE","title":"<code>ZARR_CHUNK_SIZE = TILE_SIZE</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.parameters.ZARR_SHARD_MULTIPLIER","title":"<code>ZARR_SHARD_MULTIPLIER = 10</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.util","title":"<code>util</code>","text":""},{"location":"references/#src.util.convert_dotnet_ticks_to_datetime","title":"<code>convert_dotnet_ticks_to_datetime(net_ticks)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def convert_dotnet_ticks_to_datetime(net_ticks):\n    return datetime(1, 1, 1) + timedelta(microseconds=net_ticks // 10)\n</code></pre>"},{"location":"references/#src.util.convert_to_um","title":"<code>convert_to_um(value, unit)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def convert_to_um(value, unit):\n    conversions = {\n        'nm': 1e-3,\n        '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'micron': 1,\n        'mm': 1e3, 'millimeter': 1e3,\n        'cm': 1e4, 'centimeter': 1e4,\n        'm': 1e6, 'meter': 1e6\n    }\n    return value * conversions.get(unit, 1)\n</code></pre>"},{"location":"references/#src.util.ensure_list","title":"<code>ensure_list(item)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def ensure_list(item):\n    if not isinstance(item, (list, tuple)):\n        item = [item]\n    return item\n</code></pre>"},{"location":"references/#src.util.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_filetitle(filename):\n    return os.path.basename(os.path.splitext(filename)[0])\n</code></pre>"},{"location":"references/#src.util.pad_leading_zero","title":"<code>pad_leading_zero(input_string, num_digits=2)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def pad_leading_zero(input_string, num_digits=2):\n    output = str(input_string)\n    is_well = not output[0].isdigit()\n    if is_well:\n        row, col = split_well_name(output, remove_leading_zeros=True)\n        output = str(col)\n    while len(output) &lt; num_digits:\n        output = '0' + output\n    if is_well:\n        output = row + output\n    return output\n</code></pre>"},{"location":"references/#src.util.print_dict","title":"<code>print_dict(value, tab=0, max_len=250, bullet=False)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def print_dict(value, tab=0, max_len=250, bullet=False):\n    s = ''\n    if isinstance(value, dict):\n        for key, subvalue in value.items():\n            s += '\\n'\n            if bullet:\n                s += '-'\n                bullet = False\n            s += '\\t' * tab + str(key) + ': '\n            if isinstance(subvalue, dict):\n                s += print_dict(subvalue, tab+1)\n            elif isinstance(subvalue, list):\n                for v in subvalue:\n                    s += print_dict(v, tab+1, bullet=True)\n            else:\n                subvalue = str(subvalue)\n                if len(subvalue) &gt; max_len:\n                    subvalue = subvalue[:max_len] + '...'\n                s += subvalue\n    else:\n        s += str(value) + ' '\n    return s\n</code></pre>"},{"location":"references/#src.util.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def print_hbytes(nbytes):\n    exps = ['', 'K', 'M', 'G', 'T', 'P', 'E']\n    div = 1024\n    exp = 0\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    if exp &lt; len(exps):\n        e = exps[exp]\n    else:\n        e = f'e{exp * 3}'\n    return f'{nbytes:.1f}{e}B'\n</code></pre>"},{"location":"references/#src.util.redimension_data","title":"<code>redimension_data(data, old_order, new_order, **indices)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def redimension_data(data, old_order, new_order, **indices):\n    # able to provide optional dimension values e.g. t=0, z=0\n    if new_order == old_order:\n        return data\n\n    new_data = data\n    order = old_order\n    # remove\n    for o in old_order:\n        if o not in new_order:\n            index = order.index(o)\n            dim_value = indices.get(o, 0)\n            new_data = np.take(new_data, indices=dim_value, axis=index)\n            order = order[:index] + order[index + 1:]\n    # add\n    for o in new_order:\n        if o not in order:\n            new_data = np.expand_dims(new_data, 0)\n            order = o + order\n    # move\n    old_indices = [order.index(o) for o in new_order]\n    new_indices = list(range(len(new_order)))\n    new_data = np.moveaxis(new_data, old_indices, new_indices)\n    return new_data\n</code></pre>"},{"location":"references/#src.util.split_well_name","title":"<code>split_well_name(well_name, remove_leading_zeros=True, col_as_int=False)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def split_well_name(well_name, remove_leading_zeros=True, col_as_int=False):\n    matches = re.findall(r'(\\D+)(\\d+)', well_name)\n    if len(matches) &gt; 0:\n        row, col = matches[0]\n        if col_as_int or remove_leading_zeros:\n            try:\n                col = int(col)\n            except ValueError:\n                pass\n        if not col_as_int:\n            col = str(col)\n        return row, col\n    else:\n        raise ValueError(f\"Invalid well name format: {well_name}. Expected format like 'A1', 'B2', etc.\")\n</code></pre>"},{"location":"references/#src.util.splitall","title":"<code>splitall(path)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def splitall(path):\n    allparts = []\n    while True:\n        parts = os.path.split(path)\n        if parts[0] == path:  # sentinel for absolute paths\n            allparts.insert(0, parts[0])\n            break\n        elif parts[1] == path: # sentinel for relative paths\n            allparts.insert(0, parts[1])\n            break\n        else:\n            path = parts[0]\n            allparts.insert(0, parts[1])\n    return allparts\n</code></pre>"},{"location":"references/#src.util.strip_leading_zeros","title":"<code>strip_leading_zeros(well_name)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def strip_leading_zeros(well_name):\n    row, col = split_well_name(well_name, remove_leading_zeros=True)\n    return f'{row}{col}'\n</code></pre>"},{"location":"references/#src.util.xml_content_to_dict","title":"<code>xml_content_to_dict(element)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def xml_content_to_dict(element):\n    key = element.tag\n    children = list(element)\n    if key == 'Array':\n        res = [xml_content_to_dict(child) for child in children]\n        return res\n    if len(children) &gt; 0:\n        if children[0].tag == 'Array':\n            value = []\n        else:\n            value = {}\n        for child in children:\n            child_value = xml_content_to_dict(child)\n            if isinstance(child_value, list):\n                value.extend(child_value)\n            else:\n                value |= child_value\n    else:\n        value = element.text\n        if value is not None:\n            if '\"' in value:\n                value = value.replace('\"', '')\n            else:\n                for t in (float, int, bool):\n                    try:\n                        if t == bool:\n                            if value.lower() == 'true':\n                                value = True\n                            if value.lower() == 'false':\n                                value = False\n                        else:\n                            value = t(value)\n                        break\n                    except (TypeError, ValueError):\n                        pass\n\n    if key == 'DataObject':\n        key = element.attrib['ObjectType']\n    if key == 'Attribute':\n        key = element.attrib['Name']\n    return {key: value}\n</code></pre>"}]}
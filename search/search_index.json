{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"biomero-converter","text":"<p>Conversion from various formats to Ome-tiff and Ome-zarr </p>"},{"location":"container/","title":"General container requirements","text":""},{"location":"container/#input-arguments","title":"Input arguments","text":"<ul> <li>--inputfile (required): Path to the input file</li> <li>--outputfolder (required): Output directory for converted files</li> <li>--altoutputfolder (optional): Alternative output directory</li> <li>--show_progress (optional): Show progress bar during conversion (boolean value)</li> </ul>"},{"location":"container/#output-format","title":"Output format","text":"<p>The container should return the following output as JSON string</p> <p>A list containing a dictionary of: * name: base name of the created or relevant file (without extension) * full_path: absolute path to the output file * alt_path: absolute path to the file in altoutputfolder (if used and file exists), else null * keyvalues (optional): a list with a dictionary containing per-channel intensity stats and optional metadata</p>"},{"location":"container/#keyvalues-example","title":"keyvalues example","text":"<pre><code>\"keyvalues\":\n[\n  {\n    \"channel_mins\": [1097, 2257, 335, 175],\n    \"channel_maxs\": [7423, 5907, 10261, 3716],\n    \"channel_display_black_values\": [1179, 2357, 372, 202],\n    \"channel_display_white_values\": [6798, 5641, 7002, 2969]\n  }\n]\n</code></pre>"},{"location":"convert/","title":"converter.convert() Usage","text":"<p>The <code>convert()</code> function in <code>converter.py</code> is used to convert an input file to OME format and write the result to one or more output folders.</p>"},{"location":"convert/#example-usage","title":"Example Usage","text":"<pre><code>from converter import convert\n\ninput_filename = \"path/to/input_file\"\noutput_folder = \"path/to/output_folder\"\nalt_output_folder = \"path/to/alternative_output_folder\"\n\nresult_json = convert(\n    input_filename,\n    output_folder,\n    alt_output_folder,\n    output_format=\"omezarr2\",\n    show_progress=False,\n    verbose=False\n)\n\nprint(result_json)\n</code></pre>"},{"location":"convert/#arguments","title":"Arguments","text":"<ul> <li><code>input_filename</code> (str): Path to the input file.</li> <li><code>output_folder</code> (str): Output folder path.</li> <li><code>alt_output_folder</code> (str, optional): Alternative output folder path.</li> <li><code>output_format</code> (str): Output format string (default: <code>'omezarr2'</code>).</li> <li><code>show_progress</code> (bool): If <code>True</code>, prints progress.</li> <li><code>verbose</code> (bool): If <code>True</code>, enables verbose logging.</li> </ul>"},{"location":"convert/#returns","title":"Returns","text":"<p>A JSON string containing an array with conversion result info, e.g.:</p> <pre><code>[\n  {\n    \"name\": \"experiment_name\",\n    \"full_path\": \"path/to/output_folder/experiment_name.ome.zarr\",\n    \"alt_path\": \"path/to/alternative_output_folder/experiment_name.ome.zarr\"\n  }\n]\n</code></pre>"},{"location":"main/","title":"Using Docker to Run the Main Script","text":"<p>You can use Docker to run the conversion process by mounting your input and output folders and passing the required arguments.</p>"},{"location":"main/#example","title":"Example","text":"<pre><code>docker run --rm \\\n  -v /local/input_folder:/data/input \\\n  -v /local/output_folder:/data/output \\\n  biomero-converter:latest \\\n    --inputfile /data/input/input_file.tiff \\\n    --outputfolder /data/output \\\n    --outputformat omezarr2 \\\n    --show_progress \\\n    --verbose\n</code></pre> <p>Replace <code>/local/input_folder</code> and <code>/local/output_folder</code> with your actual local paths. Adjust the image name (<code>biomero-converter:latest</code>) as needed.</p>"},{"location":"main/#arguments","title":"Arguments","text":"<p>Refer to the main script for all available arguments:</p> <ul> <li><code>--inputfile</code>: Path to the input file (required)</li> <li><code>--outputfolder</code>: Path to the output folder (required)</li> <li><code>--altoutputfolder</code>: Alternative output folder (optional)</li> <li><code>--outputformat</code>: Output format version (default: <code>omezarr2</code>)</li> <li><code>--show_progress</code>: Show progress bar (flag)</li> <li><code>--verbose</code>: Enable verbose logging (flag)</li> </ul>"},{"location":"overview/","title":"Converter Overview","text":"<p>This project provides a converter that transforms source image data into OME-Tiff or OME-Zarr format. When creating a github release, a Docker image is built and published to Docker Hub with corresponding version tags here.</p>"},{"location":"overview/#architecture","title":"Architecture","text":"<p>The converter workflow consists of:</p> <ul> <li>Creating a Source reader to access image data and metadata.</li> <li>Creating a Writer to generate OME output.</li> <li>The Writer queries the Source for metadata and data, then writes the output.</li> </ul> <pre><code>classDiagram\n    class Converter:::main {\n        convert(source path, output path, format)\n    }\n\n    class Source[\"*Source*\"]:::abstract_source {\n        get_data()*\n        get_pixel_size()*\n        ...()*\n    }\n\n    class TiffSource:::source {\n        ...\n        get_data()\n        get_pixel_size()\n        ...()\n    }\n\n    class CustomSource[\"...Source\"]:::source {\n        ...\n        get_data()\n        get_pixel_size()\n        ...()\n    }\n\n    class Writer[\"*Writer*\"]:::abstract_writer {\n        write(output path, Source, ...)*\n    }\n\n    class OmeTiffWriter:::writer {\n        write(output path, Source, ...)\n    }\n\n    class OmeZarrWriter:::writer {\n        write(output path, Source, ...)\n    }\n\n    Source &lt;|-- TiffSource\n    Source &lt;|-- CustomSource\n    Writer &lt;|-- OmeTiffWriter\n    Writer &lt;|-- OmeZarrWriter\n    Source &lt;.. Writer\n    Converter ..&gt; Writer\n\n    classDef main fill:#ffeecc,stroke:#775500\n    classDef source fill:#e8f5e9,stroke:#1b5e20\n    classDef abstract_source fill:#ffffff\n    classDef writer fill:#e0f7fa,stroke:#006064\n    classDef abstract_writer fill:#ffffff</code></pre>"},{"location":"references/","title":"References","text":""},{"location":"references/#converter.convert","title":"<code>convert(input_filename, output_folder, alt_output_folder=None, output_format=None, show_progress=False, verbose=False, max_attempts=RETRY_ATTEMPTS, **kwargs)</code>","text":"Source code in <code>converter.py</code> <pre><code>def convert(input_filename, output_folder, alt_output_folder=None,\n            output_format=None, show_progress=False, verbose=False, max_attempts=RETRY_ATTEMPTS, **kwargs):\n    attempts = 0\n    while True:\n        try:\n            return _convert(input_filename, output_folder, alt_output_folder=alt_output_folder,\n                            output_format=output_format, show_progress=show_progress, verbose=verbose,\n                            **kwargs)\n        except Exception as e:\n            if attempts &gt;= max_attempts - 1:\n                logging.error(e)\n                raise Exception(f'Conversion failed after {RETRY_ATTEMPTS} attempts: {input_filename}')\n        attempts += 1\n</code></pre>"},{"location":"references/#converter.init_logging","title":"<code>init_logging(log_filename, verbose=False)</code>","text":"<p>Initialize logging to file and optionally to console.</p> <p>Parameters:</p> Name Type Description Default <code>log_filename</code> <code>str</code> <p>Path to the log file.</p> required <code>verbose</code> <code>bool</code> <p>If True, also log to console.</p> <code>False</code> Source code in <code>converter.py</code> <pre><code>def init_logging(log_filename, verbose=False):\n    \"\"\"\n    Initialize logging to file and optionally to console.\n\n    Args:\n        log_filename (str): Path to the log file.\n        verbose (bool): If True, also log to console.\n    \"\"\"\n    basepath = os.path.dirname(log_filename)\n    if basepath and not os.path.exists(basepath):\n        os.makedirs(basepath)\n    handlers = [logging.FileHandler(log_filename, encoding='utf-8')]\n    if verbose:\n        handlers += [logging.StreamHandler()]\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s: %(message)s',\n                        handlers=handlers,\n                        encoding='utf-8')\n\n    logging.getLogger('ome_zarr').setLevel(logging.WARNING)     # mute verbose ome_zarr logging\n</code></pre>"},{"location":"references/#src.DbReader","title":"<code>DbReader</code>","text":""},{"location":"references/#src.DbReader.DbReader","title":"<code>DbReader</code>","text":"<p>Reads and queries a SQLite database, returning results as dictionaries.</p> Source code in <code>src/DbReader.py</code> <pre><code>class DbReader:\n    \"\"\"\n    Reads and queries a SQLite database, returning results as dictionaries.\n    \"\"\"\n\n    def __init__(self, db_file):\n        \"\"\"\n        Initialize DBReader with a database file.\n\n        Args:\n            db_file (str): Path to the SQLite database file.\n        \"\"\"\n        self.conn = sqlite3.connect(db_file)\n        self.conn.row_factory = DbReader.dict_factory\n\n    @staticmethod\n    def dict_factory(cursor, row):\n        \"\"\"\n        Converts a database row to a dictionary.\n\n        Args:\n            cursor: SQLite cursor object.\n            row: Row data.\n\n        Returns:\n            dict: Mapping column names to values.\n        \"\"\"\n        dct = {}\n        for index, column in enumerate(cursor.description):\n            dct[column[0]] = row[index]\n        return dct\n\n    def fetch_all(self, query, params=[], return_dicts=True):\n        \"\"\"\n        Executes a query and fetches all results.\n\n        Args:\n            query (str): SQL query string.\n            params (list): Query parameters.\n            return_dicts (bool): If True, returns list of dicts; else, returns first column values.\n\n        Returns:\n            list: Query results.\n        \"\"\"\n        cursor = self.conn.cursor()\n        cursor.execute(query, params)\n        dct = cursor.fetchall()\n        if return_dicts:\n            values = dct\n        else:\n            values = [list(row.values())[0] for row in dct]\n        return values\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        self.conn.close()\n</code></pre>"},{"location":"references/#src.DbReader.DbReader.conn","title":"<code>conn = sqlite3.connect(db_file)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.DbReader.DbReader.__init__","title":"<code>__init__(db_file)</code>","text":"<p>Initialize DBReader with a database file.</p> <p>Parameters:</p> Name Type Description Default <code>db_file</code> <code>str</code> <p>Path to the SQLite database file.</p> required Source code in <code>src/DbReader.py</code> <pre><code>def __init__(self, db_file):\n    \"\"\"\n    Initialize DBReader with a database file.\n\n    Args:\n        db_file (str): Path to the SQLite database file.\n    \"\"\"\n    self.conn = sqlite3.connect(db_file)\n    self.conn.row_factory = DbReader.dict_factory\n</code></pre>"},{"location":"references/#src.DbReader.DbReader.close","title":"<code>close()</code>","text":"<p>Closes the database connection.</p> Source code in <code>src/DbReader.py</code> <pre><code>def close(self):\n    \"\"\"\n    Closes the database connection.\n    \"\"\"\n    self.conn.close()\n</code></pre>"},{"location":"references/#src.DbReader.DbReader.dict_factory","title":"<code>dict_factory(cursor, row)</code>  <code>staticmethod</code>","text":"<p>Converts a database row to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <p>SQLite cursor object.</p> required <code>row</code> <p>Row data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Mapping column names to values.</p> Source code in <code>src/DbReader.py</code> <pre><code>@staticmethod\ndef dict_factory(cursor, row):\n    \"\"\"\n    Converts a database row to a dictionary.\n\n    Args:\n        cursor: SQLite cursor object.\n        row: Row data.\n\n    Returns:\n        dict: Mapping column names to values.\n    \"\"\"\n    dct = {}\n    for index, column in enumerate(cursor.description):\n        dct[column[0]] = row[index]\n    return dct\n</code></pre>"},{"location":"references/#src.DbReader.DbReader.fetch_all","title":"<code>fetch_all(query, params=[], return_dicts=True)</code>","text":"<p>Executes a query and fetches all results.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>SQL query string.</p> required <code>params</code> <code>list</code> <p>Query parameters.</p> <code>[]</code> <code>return_dicts</code> <code>bool</code> <p>If True, returns list of dicts; else, returns first column values.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>list</code> <p>Query results.</p> Source code in <code>src/DbReader.py</code> <pre><code>def fetch_all(self, query, params=[], return_dicts=True):\n    \"\"\"\n    Executes a query and fetches all results.\n\n    Args:\n        query (str): SQL query string.\n        params (list): Query parameters.\n        return_dicts (bool): If True, returns list of dicts; else, returns first column values.\n\n    Returns:\n        list: Query results.\n    \"\"\"\n    cursor = self.conn.cursor()\n    cursor.execute(query, params)\n    dct = cursor.fetchall()\n    if return_dicts:\n        values = dct\n    else:\n        values = [list(row.values())[0] for row in dct]\n    return values\n</code></pre>"},{"location":"references/#src.DicomSource","title":"<code>DicomSource</code>","text":""},{"location":"references/#src.DicomSource.DicomSource","title":"<code>DicomSource</code>","text":"<p>               Bases: <code>ImageSource</code></p> <p>ImageSource subclass for reading DICOM files using pydicom.</p> Source code in <code>src/DicomSource.py</code> <pre><code>class DicomSource(ImageSource):\n    \"\"\"\n    ImageSource subclass for reading DICOM files using pydicom.\n    \"\"\"\n\n    def __init__(self, uri, metadata={}):\n        super().__init__(uri, metadata)\n        if os.path.isfile(uri):\n            self.filenames = [uri]\n        else:\n            self.filenames = [os.path.join(uri, filename) for filename in sorted(os.listdir(uri))]\n            uri = self.filenames[0]\n        self.dicom = dcmread(uri)\n\n    def walk_dicom(self):\n        def callback(dataset, data_element):\n            print(f'{data_element.name}: {data_element.value}')\n\n        self.dicom.walk(callback)\n\n    def walk_fileset(self):\n        fileset = FileSet(self.dicom)\n        for fileinstance in fileset:\n            ds = fileinstance.load()\n            print(ds.get('filename'), ds.get('StudyDescription'), ds.get('PixelSpacing'))\n\n    def walk_series(self):\n        series = self.fileset.find_values(\"SeriesInstanceUID\")\n        for serie_id in series:\n            fileinstances = self.fileset.find(SeriesInstanceUID=serie_id)\n            path = os.path.dirname(fileinstances[0].path)\n            data = pixel_array(path)\n\n    def init_metadata(self):\n        metadata = {elem.keyword: elem.value for elem in self.dicom.iterall() if elem.keyword}\n\n        self.metadata = metadata\n        pixel_array = self.dicom.pixel_array\n        shape = list(pixel_array.shape)\n        self.is_rgb_type = (metadata.get('PhotometricInterpretation').lower() == 'rgb')\n        dim_order = 'yx'\n        nchannels = 1\n        if self.is_rgb_type:\n            if shape[-1] &lt; shape[0]:\n                nchannels = shape[-1]\n                dim_order = dim_order + 'c'\n            else:\n                nchannels = shape[0]\n                dim_order = 'c' + dim_order\n        self.dtype = pixel_array.dtype\n        self.pixel_size = {dim:value for dim, value in zip('xy', metadata.get('PixelSpacing', (1, 1)))}\n        nz = len(self.filenames)\n        if nz &gt; 1:\n            dim_order = 'z' + dim_order\n            shape = [nz] + shape\n            self.pixel_size['z'] = metadata.get('SliceThickness', 1)\n        self.shape = shape\n        self.nchannels = nchannels\n        self.dim_order = dim_order\n        self.shapes = [self.shape]\n        self.scales = [1]\n        if 'ImagePositionPatient' in metadata:\n            self.position = {dim: size for dim, size in zip(self.dim_order, metadata['ImagePositionPatient'])}\n        else:\n            self.position = None\n        date_time = metadata.get('AcquisitionDate', '') + metadata.get('AcquisitionTime', '')\n        if not date_time:\n            date_time = metadata.get('SeriesDate', '') + metadata.get('SeriesTime', '')\n        if not date_time:\n            date_time = metadata.get('StudyDate', '') + metadata.get('StudyTime', '')\n        self.acquisition_datetime = datetime.strptime(date_time, '%Y%m%d%H%M%S')\n        self.bits_per_pixel = self.metadata.get('BitsStored', self.dtype.itemsize * 8)\n\n        name = self.metadata.get('SeriesDescription')\n        if not name:\n            name = self.metadata.get('StudyDescription')\n        if not name:\n            name = get_filetitle(self.uri)\n        self.name = name\n\n        return self.metadata\n\n    def is_screen(self):\n        # DICOM files are not multi-well screens\n        return False\n\n    def is_rgb(self):\n        return self.is_rgb_type\n\n    def get_name(self):\n        return self.name\n\n    def get_shape(self):\n        return self.shape\n\n    def get_shapes(self):\n        return self.shapes\n\n    def get_dtype(self):\n        return self.dtype\n\n    def get_scales(self):\n        return self.scales\n\n    def get_dim_order(self):\n        return self.dim_order\n\n    def get_channels(self):\n        if self.is_rgb():\n            labels = ['Red', 'Green', 'Blue']\n            colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n            return [{'label': label, 'color': color} for label, color in zip(labels, colors)]\n        else:\n            return [{'label': f'Channel {index}', 'color': [1, 1, 1, 1]} for index in range(self.nchannels)]\n\n    def get_nchannels(self):\n        return self.nchannels\n\n    def get_pixel_size_um(self):\n        return {dim: size * 1e3 for dim, size in self.pixel_size.items()}\n\n    def get_position_um(self, well_id=None):\n        if self.position:\n            return {dim: size * 1e3 for dim, size in self.position.items()}\n        else:\n            return None\n\n    def get_data(self, dim_order, level=0, well_id=None, field_id=None, **kwargs):\n        # https://pydicom.github.io/pydicom/stable/auto_examples/image_processing/reslice.html#sphx-glr-auto-examples-image-processing-reslice-py\n        if 'z' in self.dim_order:\n            data = np.zeros(self.shape)\n            for index, filename in enumerate(self.filenames):\n                data[index] = dcmread(filename).pixel_array\n        else:\n            data = self.dicom.pixel_array\n        return redimension_data(data, self.dim_order, dim_order)\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.dicom","title":"<code>dicom = dcmread(uri)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.DicomSource.DicomSource.filenames","title":"<code>filenames = [uri]</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.DicomSource.DicomSource.__init__","title":"<code>__init__(uri, metadata={})</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def __init__(self, uri, metadata={}):\n    super().__init__(uri, metadata)\n    if os.path.isfile(uri):\n        self.filenames = [uri]\n    else:\n        self.filenames = [os.path.join(uri, filename) for filename in sorted(os.listdir(uri))]\n        uri = self.filenames[0]\n    self.dicom = dcmread(uri)\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.get_channels","title":"<code>get_channels()</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def get_channels(self):\n    if self.is_rgb():\n        labels = ['Red', 'Green', 'Blue']\n        colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n        return [{'label': label, 'color': color} for label, color in zip(labels, colors)]\n    else:\n        return [{'label': f'Channel {index}', 'color': [1, 1, 1, 1]} for index in range(self.nchannels)]\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.get_data","title":"<code>get_data(dim_order, level=0, well_id=None, field_id=None, **kwargs)</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def get_data(self, dim_order, level=0, well_id=None, field_id=None, **kwargs):\n    # https://pydicom.github.io/pydicom/stable/auto_examples/image_processing/reslice.html#sphx-glr-auto-examples-image-processing-reslice-py\n    if 'z' in self.dim_order:\n        data = np.zeros(self.shape)\n        for index, filename in enumerate(self.filenames):\n            data[index] = dcmread(filename).pixel_array\n    else:\n        data = self.dicom.pixel_array\n    return redimension_data(data, self.dim_order, dim_order)\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def get_dim_order(self):\n    return self.dim_order\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.get_dtype","title":"<code>get_dtype()</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def get_dtype(self):\n    return self.dtype\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.get_name","title":"<code>get_name()</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def get_name(self):\n    return self.name\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def get_nchannels(self):\n    return self.nchannels\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def get_pixel_size_um(self):\n    return {dim: size * 1e3 for dim, size in self.pixel_size.items()}\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.get_position_um","title":"<code>get_position_um(well_id=None)</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def get_position_um(self, well_id=None):\n    if self.position:\n        return {dim: size * 1e3 for dim, size in self.position.items()}\n    else:\n        return None\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.get_scales","title":"<code>get_scales()</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def get_scales(self):\n    return self.scales\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.get_shape","title":"<code>get_shape()</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def get_shape(self):\n    return self.shape\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.get_shapes","title":"<code>get_shapes()</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def get_shapes(self):\n    return self.shapes\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.init_metadata","title":"<code>init_metadata()</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def init_metadata(self):\n    metadata = {elem.keyword: elem.value for elem in self.dicom.iterall() if elem.keyword}\n\n    self.metadata = metadata\n    pixel_array = self.dicom.pixel_array\n    shape = list(pixel_array.shape)\n    self.is_rgb_type = (metadata.get('PhotometricInterpretation').lower() == 'rgb')\n    dim_order = 'yx'\n    nchannels = 1\n    if self.is_rgb_type:\n        if shape[-1] &lt; shape[0]:\n            nchannels = shape[-1]\n            dim_order = dim_order + 'c'\n        else:\n            nchannels = shape[0]\n            dim_order = 'c' + dim_order\n    self.dtype = pixel_array.dtype\n    self.pixel_size = {dim:value for dim, value in zip('xy', metadata.get('PixelSpacing', (1, 1)))}\n    nz = len(self.filenames)\n    if nz &gt; 1:\n        dim_order = 'z' + dim_order\n        shape = [nz] + shape\n        self.pixel_size['z'] = metadata.get('SliceThickness', 1)\n    self.shape = shape\n    self.nchannels = nchannels\n    self.dim_order = dim_order\n    self.shapes = [self.shape]\n    self.scales = [1]\n    if 'ImagePositionPatient' in metadata:\n        self.position = {dim: size for dim, size in zip(self.dim_order, metadata['ImagePositionPatient'])}\n    else:\n        self.position = None\n    date_time = metadata.get('AcquisitionDate', '') + metadata.get('AcquisitionTime', '')\n    if not date_time:\n        date_time = metadata.get('SeriesDate', '') + metadata.get('SeriesTime', '')\n    if not date_time:\n        date_time = metadata.get('StudyDate', '') + metadata.get('StudyTime', '')\n    self.acquisition_datetime = datetime.strptime(date_time, '%Y%m%d%H%M%S')\n    self.bits_per_pixel = self.metadata.get('BitsStored', self.dtype.itemsize * 8)\n\n    name = self.metadata.get('SeriesDescription')\n    if not name:\n        name = self.metadata.get('StudyDescription')\n    if not name:\n        name = get_filetitle(self.uri)\n    self.name = name\n\n    return self.metadata\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.is_rgb","title":"<code>is_rgb()</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def is_rgb(self):\n    return self.is_rgb_type\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.is_screen","title":"<code>is_screen()</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def is_screen(self):\n    # DICOM files are not multi-well screens\n    return False\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.walk_dicom","title":"<code>walk_dicom()</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def walk_dicom(self):\n    def callback(dataset, data_element):\n        print(f'{data_element.name}: {data_element.value}')\n\n    self.dicom.walk(callback)\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.walk_fileset","title":"<code>walk_fileset()</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def walk_fileset(self):\n    fileset = FileSet(self.dicom)\n    for fileinstance in fileset:\n        ds = fileinstance.load()\n        print(ds.get('filename'), ds.get('StudyDescription'), ds.get('PixelSpacing'))\n</code></pre>"},{"location":"references/#src.DicomSource.DicomSource.walk_series","title":"<code>walk_series()</code>","text":"Source code in <code>src/DicomSource.py</code> <pre><code>def walk_series(self):\n    series = self.fileset.find_values(\"SeriesInstanceUID\")\n    for serie_id in series:\n        fileinstances = self.fileset.find(SeriesInstanceUID=serie_id)\n        path = os.path.dirname(fileinstances[0].path)\n        data = pixel_array(path)\n</code></pre>"},{"location":"references/#src.GenericSource","title":"<code>GenericSource</code>","text":""},{"location":"references/#src.GenericSource.GenericSource","title":"<code>GenericSource</code>","text":"<p>               Bases: <code>ImageSource</code></p> Source code in <code>src/GenericSource.py</code> <pre><code>class GenericSource(ImageSource):\n    def __init__(self, uri, **kwargs):\n        super().__init__(uri, **kwargs)\n        self.format = os.path.splitext(uri)[1].lower().lstrip('.')\n        self.metadata = None\n        im = None\n        try:\n            im = iio.imopen(uri, 'r')\n            self.metadata = im.metadata()\n            self.data_func = im.read\n        except OSError as error:\n            error = str(error)\n            match = re.search(r\"plugin='\\w+'\", error)\n            if match:\n                parts = match.group().split('=')\n                if len(parts) == 2:\n                    self.format = parts[1].strip(\"'\").lower()\n        except Exception:\n            if im:\n                if hasattr(im, 'legacy_get_reader'):\n                    reader = im.legacy_get_reader()\n                    self.format = reader.format.name.lower()\n                    self.metadata = reader.get_meta_data()\n                    self.data_func = reader.get_data\n\n    def init_metadata(self):\n        return self.metadata\n\n    def get_data(self, **kwargs):\n        return self.data_func(**kwargs)\n</code></pre>"},{"location":"references/#src.GenericSource.GenericSource.data_func","title":"<code>data_func = im.read</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.GenericSource.GenericSource.format","title":"<code>format = os.path.splitext(uri)[1].lower().lstrip('.')</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.GenericSource.GenericSource.metadata","title":"<code>metadata = im.metadata()</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.GenericSource.GenericSource.__init__","title":"<code>__init__(uri, **kwargs)</code>","text":"Source code in <code>src/GenericSource.py</code> <pre><code>def __init__(self, uri, **kwargs):\n    super().__init__(uri, **kwargs)\n    self.format = os.path.splitext(uri)[1].lower().lstrip('.')\n    self.metadata = None\n    im = None\n    try:\n        im = iio.imopen(uri, 'r')\n        self.metadata = im.metadata()\n        self.data_func = im.read\n    except OSError as error:\n        error = str(error)\n        match = re.search(r\"plugin='\\w+'\", error)\n        if match:\n            parts = match.group().split('=')\n            if len(parts) == 2:\n                self.format = parts[1].strip(\"'\").lower()\n    except Exception:\n        if im:\n            if hasattr(im, 'legacy_get_reader'):\n                reader = im.legacy_get_reader()\n                self.format = reader.format.name.lower()\n                self.metadata = reader.get_meta_data()\n                self.data_func = reader.get_data\n</code></pre>"},{"location":"references/#src.GenericSource.GenericSource.get_data","title":"<code>get_data(**kwargs)</code>","text":"Source code in <code>src/GenericSource.py</code> <pre><code>def get_data(self, **kwargs):\n    return self.data_func(**kwargs)\n</code></pre>"},{"location":"references/#src.GenericSource.GenericSource.init_metadata","title":"<code>init_metadata()</code>","text":"Source code in <code>src/GenericSource.py</code> <pre><code>def init_metadata(self):\n    return self.metadata\n</code></pre>"},{"location":"references/#src.ISyntaxSource","title":"<code>ISyntaxSource</code>","text":""},{"location":"references/#src.ISyntaxSource.PYRAMID_DOWNSCALE","title":"<code>PYRAMID_DOWNSCALE = 2</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.ISyntaxSource.PYRAMID_LEVELS","title":"<code>PYRAMID_LEVELS = 6</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.ISyntaxSource.RETRY_ATTEMPTS","title":"<code>RETRY_ATTEMPTS = 3</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.ISyntaxSource.TIFF_COMPRESSION","title":"<code>TIFF_COMPRESSION = 'LZW'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.ISyntaxSource.TILE_SIZE","title":"<code>TILE_SIZE = 1024</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.ISyntaxSource.VERSION","title":"<code>VERSION = 'v0.1.18'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.ISyntaxSource.ZARR_CHUNK_SIZE","title":"<code>ZARR_CHUNK_SIZE = TILE_SIZE</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.ISyntaxSource.ZARR_SHARD_MULTIPLIER","title":"<code>ZARR_SHARD_MULTIPLIER = 10</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.ISyntaxSource.ISyntaxSource","title":"<code>ISyntaxSource</code>","text":"<p>               Bases: <code>ImageSource</code></p> <p>Loads image and metadata from ISyntax format files.</p> Source code in <code>src/ISyntaxSource.py</code> <pre><code>class ISyntaxSource(ImageSource):\n    \"\"\"\n    Loads image and metadata from ISyntax format files.\n    \"\"\"\n    def init_metadata(self):\n        # read XML metadata header\n        data = b''\n        block_size = 1024 * 1024\n        end_char = b'\\x04'   # EOT character\n        with open(self.uri, mode='rb') as file:\n            done = False\n            while not done:\n                data_block = file.read(block_size)\n                if end_char in data_block:\n                    index = data_block.index(end_char)\n                    data_block = data_block[:index]\n                    done = True\n                data += data_block\n\n        self.metadata = xml_content_to_dict(ElementTree.XML(data.decode()))\n        if 'DPUfsImport' in self.metadata:\n            self.metadata = self.metadata['DPUfsImport']\n\n        image = None\n        image_type = ''\n        for image0 in self.metadata.get('PIM_DP_SCANNED_IMAGES', []):\n            image = image0.get('DPScannedImage', {})\n            image_type = image.get('PIM_DP_IMAGE_TYPE').lower()\n            if image_type in ['wsi']:\n                break\n\n        if image is not None:\n            self.image_type = image_type\n            nbits = image.get('UFS_IMAGE_BLOCK_HEADER_TEMPLATES', [{}])[0].get('UFSImageBlockHeaderTemplate', {}).get('DICOM_BITS_STORED', 16)\n        else:\n            self.image_type = ''\n            nbits = 16\n\n        self.is_plate = 'screen' in self.image_type or 'plate' in self.image_type or 'wells' in self.image_type\n\n        self.isyntax = ISyntax.open(self.uri)\n        self.dimensions = self.isyntax.level_dimensions\n        self.widths = [width for width, height in self.isyntax.level_dimensions]\n        self.heights = [height for width, height in self.isyntax.level_dimensions]\n        self.scales = [1 / downsample for downsample in self.isyntax.level_downsamples]\n\n        # original color channels get converted in pyisyntax package to 8-bit RGBA; convert to RGB\n        nbits = 8\n        self.nchannels = 3\n        self.shapes = [(height, width, self.nchannels) for (width, height) in self.dimensions]\n        self.shape = self.shapes[0]\n        self.dim_order = 'yxc'\n        self.is_rgb_channels = True\n        self.dtype = get_bits_type(nbits)\n        self.pixel_size = {'x': self.isyntax.mpp_x, 'y': self.isyntax.mpp_y}\n        self.bits_per_pixel = nbits\n\n        self.name = get_filetitle(self.uri)\n        self.acquisition_datetime = datetime.strptime(str(self.metadata.get('DICOM_ACQUISITION_DATETIME')),'%Y%m%d%H%M%S.%f')\n        return self.metadata\n\n    def is_screen(self):\n        return self.is_plate\n\n    def get_shape(self):\n        return self.shape\n\n    def get_shapes(self):\n        return self.shapes\n\n    def get_scales(self):\n        return self.scales\n\n    def read_array(self, x, y, width, height, level=0):\n        rgba = self.isyntax.read_region(x, y, width, height, level)\n        alpha = np.atleast_3d(rgba[..., 3] / np.float32(255))\n        rgb = (rgba[..., :3] * alpha).astype(np.uint8)\n        return rgb\n\n    def get_data(self, dim_order, level=0, well_id=None, field_id=None, **kwargs):\n        data = self.read_array(0, 0, self.widths[level], self.heights[level], level=level)\n        return redimension_data(data, self.dim_order, dim_order)\n\n    def get_data_as_dask(self, dim_order, level=0, **kwargs):\n        dask.config.set(scheduler='single-threaded')\n\n        def get_lazy_tile(x, y, width, height, level=0):\n            lazy_array = dask.delayed(self.read_array)(x, y, width, height, level)\n            return da.from_delayed(lazy_array, shape=(height, width, self.nchannels), dtype=self.dtype)\n\n        y_chunks, x_chunks = da.core.normalize_chunks(TILE_SIZE, self.shapes[level][:2], dtype=self.dtype)\n        y_pos = np.cumsum([0] + list(y_chunks)[:-1])\n        x_pos = np.cumsum([0] + list(x_chunks)[:-1])\n        data = da.concatenate(\n            [da.concatenate(\n                [get_lazy_tile(x, y, width, height, level=level)\n                 for x, width in zip(x_pos, x_chunks)], axis=1)\n             for y, height in zip(y_pos, y_chunks)], axis=0)\n        return redimension_data(data, self.dim_order, dim_order)\n\n    def get_data_as_generator(self, dim_order, **kwargs):\n        def data_generator(scale=1):\n            level, rescale = get_level_from_scale(self.scales, scale)\n            read_size = int(TILE_SIZE / rescale)\n            for y in range(0, self.heights[level], read_size):\n                for x in range(0, self.widths[level], read_size):\n                    data = self.read_array(x, y, read_size, read_size, level)\n                    if rescale != 1:\n                        shape = np.multiply(data.shape[:2], rescale).astype(int)\n                        data = sk_transform.resize(data, shape, preserve_range=True).astype(data.dtype)\n                    yield redimension_data(data, self.dim_order, dim_order)\n        return data_generator\n\n    def get_name(self):\n        return self.name\n\n    def get_dim_order(self):\n        return self.dim_order\n\n    def get_pixel_size_um(self):\n        return self.pixel_size\n\n    def get_dtype(self):\n        return self.dtype\n\n    def get_position_um(self, well_id=None):\n        return {'x': self.isyntax.offset_x, 'y': self.isyntax.offset_y}\n\n    def get_channels(self):\n        # Mirax is RGB, return NGFF-style channel metadata\n        return [\n            {\"name\": \"Red\", \"color\": [1, 0, 0, 1]},\n            {\"name\": \"Green\", \"color\": [0, 1, 0, 1]},\n            {\"name\": \"Blue\", \"color\": [0, 0, 1, 1]},\n            #{\"name\": \"Alpha\", \"color\": [1, 1, 1, 1]}\n        ]\n\n    def get_nchannels(self):\n        return self.nchannels\n\n    def is_rgb(self):\n        return self.is_rgb_channels\n\n    def get_rows(self):\n        return []\n\n    def get_columns(self):\n        return []\n\n    def get_wells(self):\n        return []\n\n    def get_time_points(self):\n        return []\n\n    def get_fields(self):\n        return []\n\n    def get_acquisitions(self):\n        return []\n\n    def get_acquisition_datetime(self):\n        return self.acquisition_datetime\n\n    def get_significant_bits(self):\n        return self.bits_per_pixel\n\n    def close(self):\n        self.isyntax.close()\n        dask.config.set(scheduler='threads')\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.close","title":"<code>close()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def close(self):\n    self.isyntax.close()\n    dask.config.set(scheduler='threads')\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_acquisition_datetime","title":"<code>get_acquisition_datetime()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_acquisition_datetime(self):\n    return self.acquisition_datetime\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_acquisitions","title":"<code>get_acquisitions()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_acquisitions(self):\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_channels","title":"<code>get_channels()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_channels(self):\n    # Mirax is RGB, return NGFF-style channel metadata\n    return [\n        {\"name\": \"Red\", \"color\": [1, 0, 0, 1]},\n        {\"name\": \"Green\", \"color\": [0, 1, 0, 1]},\n        {\"name\": \"Blue\", \"color\": [0, 0, 1, 1]},\n        #{\"name\": \"Alpha\", \"color\": [1, 1, 1, 1]}\n    ]\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_columns","title":"<code>get_columns()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_columns(self):\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_data","title":"<code>get_data(dim_order, level=0, well_id=None, field_id=None, **kwargs)</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_data(self, dim_order, level=0, well_id=None, field_id=None, **kwargs):\n    data = self.read_array(0, 0, self.widths[level], self.heights[level], level=level)\n    return redimension_data(data, self.dim_order, dim_order)\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_data_as_dask","title":"<code>get_data_as_dask(dim_order, level=0, **kwargs)</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_data_as_dask(self, dim_order, level=0, **kwargs):\n    dask.config.set(scheduler='single-threaded')\n\n    def get_lazy_tile(x, y, width, height, level=0):\n        lazy_array = dask.delayed(self.read_array)(x, y, width, height, level)\n        return da.from_delayed(lazy_array, shape=(height, width, self.nchannels), dtype=self.dtype)\n\n    y_chunks, x_chunks = da.core.normalize_chunks(TILE_SIZE, self.shapes[level][:2], dtype=self.dtype)\n    y_pos = np.cumsum([0] + list(y_chunks)[:-1])\n    x_pos = np.cumsum([0] + list(x_chunks)[:-1])\n    data = da.concatenate(\n        [da.concatenate(\n            [get_lazy_tile(x, y, width, height, level=level)\n             for x, width in zip(x_pos, x_chunks)], axis=1)\n         for y, height in zip(y_pos, y_chunks)], axis=0)\n    return redimension_data(data, self.dim_order, dim_order)\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_data_as_generator","title":"<code>get_data_as_generator(dim_order, **kwargs)</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_data_as_generator(self, dim_order, **kwargs):\n    def data_generator(scale=1):\n        level, rescale = get_level_from_scale(self.scales, scale)\n        read_size = int(TILE_SIZE / rescale)\n        for y in range(0, self.heights[level], read_size):\n            for x in range(0, self.widths[level], read_size):\n                data = self.read_array(x, y, read_size, read_size, level)\n                if rescale != 1:\n                    shape = np.multiply(data.shape[:2], rescale).astype(int)\n                    data = sk_transform.resize(data, shape, preserve_range=True).astype(data.dtype)\n                yield redimension_data(data, self.dim_order, dim_order)\n    return data_generator\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_dim_order(self):\n    return self.dim_order\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_dtype","title":"<code>get_dtype()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_dtype(self):\n    return self.dtype\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_fields","title":"<code>get_fields()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_fields(self):\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_name","title":"<code>get_name()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_name(self):\n    return self.name\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_nchannels(self):\n    return self.nchannels\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_pixel_size_um(self):\n    return self.pixel_size\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_position_um","title":"<code>get_position_um(well_id=None)</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_position_um(self, well_id=None):\n    return {'x': self.isyntax.offset_x, 'y': self.isyntax.offset_y}\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_rows","title":"<code>get_rows()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_rows(self):\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_scales","title":"<code>get_scales()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_scales(self):\n    return self.scales\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_shape","title":"<code>get_shape()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_shape(self):\n    return self.shape\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_shapes","title":"<code>get_shapes()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_shapes(self):\n    return self.shapes\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_significant_bits","title":"<code>get_significant_bits()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_significant_bits(self):\n    return self.bits_per_pixel\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_time_points","title":"<code>get_time_points()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_time_points(self):\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.get_wells","title":"<code>get_wells()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def get_wells(self):\n    return []\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.init_metadata","title":"<code>init_metadata()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def init_metadata(self):\n    # read XML metadata header\n    data = b''\n    block_size = 1024 * 1024\n    end_char = b'\\x04'   # EOT character\n    with open(self.uri, mode='rb') as file:\n        done = False\n        while not done:\n            data_block = file.read(block_size)\n            if end_char in data_block:\n                index = data_block.index(end_char)\n                data_block = data_block[:index]\n                done = True\n            data += data_block\n\n    self.metadata = xml_content_to_dict(ElementTree.XML(data.decode()))\n    if 'DPUfsImport' in self.metadata:\n        self.metadata = self.metadata['DPUfsImport']\n\n    image = None\n    image_type = ''\n    for image0 in self.metadata.get('PIM_DP_SCANNED_IMAGES', []):\n        image = image0.get('DPScannedImage', {})\n        image_type = image.get('PIM_DP_IMAGE_TYPE').lower()\n        if image_type in ['wsi']:\n            break\n\n    if image is not None:\n        self.image_type = image_type\n        nbits = image.get('UFS_IMAGE_BLOCK_HEADER_TEMPLATES', [{}])[0].get('UFSImageBlockHeaderTemplate', {}).get('DICOM_BITS_STORED', 16)\n    else:\n        self.image_type = ''\n        nbits = 16\n\n    self.is_plate = 'screen' in self.image_type or 'plate' in self.image_type or 'wells' in self.image_type\n\n    self.isyntax = ISyntax.open(self.uri)\n    self.dimensions = self.isyntax.level_dimensions\n    self.widths = [width for width, height in self.isyntax.level_dimensions]\n    self.heights = [height for width, height in self.isyntax.level_dimensions]\n    self.scales = [1 / downsample for downsample in self.isyntax.level_downsamples]\n\n    # original color channels get converted in pyisyntax package to 8-bit RGBA; convert to RGB\n    nbits = 8\n    self.nchannels = 3\n    self.shapes = [(height, width, self.nchannels) for (width, height) in self.dimensions]\n    self.shape = self.shapes[0]\n    self.dim_order = 'yxc'\n    self.is_rgb_channels = True\n    self.dtype = get_bits_type(nbits)\n    self.pixel_size = {'x': self.isyntax.mpp_x, 'y': self.isyntax.mpp_y}\n    self.bits_per_pixel = nbits\n\n    self.name = get_filetitle(self.uri)\n    self.acquisition_datetime = datetime.strptime(str(self.metadata.get('DICOM_ACQUISITION_DATETIME')),'%Y%m%d%H%M%S.%f')\n    return self.metadata\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.is_rgb","title":"<code>is_rgb()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def is_rgb(self):\n    return self.is_rgb_channels\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.is_screen","title":"<code>is_screen()</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def is_screen(self):\n    return self.is_plate\n</code></pre>"},{"location":"references/#src.ISyntaxSource.ISyntaxSource.read_array","title":"<code>read_array(x, y, width, height, level=0)</code>","text":"Source code in <code>src/ISyntaxSource.py</code> <pre><code>def read_array(self, x, y, width, height, level=0):\n    rgba = self.isyntax.read_region(x, y, width, height, level)\n    alpha = np.atleast_3d(rgba[..., 3] / np.float32(255))\n    rgb = (rgba[..., :3] * alpha).astype(np.uint8)\n    return rgb\n</code></pre>"},{"location":"references/#src.ImageDbSource","title":"<code>ImageDbSource</code>","text":""},{"location":"references/#src.ImageDbSource.ImageDbSource","title":"<code>ImageDbSource</code>","text":"<p>               Bases: <code>ImageSource</code></p> <p>Loads image and metadata from a database source for high-content screening.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>class ImageDbSource(ImageSource):\n    \"\"\"\n    Loads image and metadata from a database source for high-content screening.\n    \"\"\"\n    def __init__(self, uri, metadata={}):\n        super().__init__(uri, metadata)\n        self.db = DbReader(self.uri)\n        self.data = None\n        self.data_well_id = None\n        self.data_level = None\n        self.dim_order = 'tczyx'\n\n    def init_metadata(self):\n        self._get_time_series_info()\n        self._get_experiment_metadata()\n        self._get_well_info()\n        self._get_image_info()\n        self._get_sizes()\n        return self.metadata\n\n    def get_shape(self):\n        return self.shape\n\n    def get_shapes(self):\n        return self.shapes\n\n    def get_scales(self):\n        return self.scales\n\n    def _get_time_series_info(self):\n        \"\"\"\n        Loads time series and image file info into metadata.\n        \"\"\"\n        time_series_ids = sorted(self.db.fetch_all('SELECT DISTINCT TimeSeriesElementId FROM SourceImageBase', return_dicts=False))\n        self.time_points = time_series_ids\n\n        level_ids = sorted(self.db.fetch_all('SELECT DISTINCT level FROM SourceImageBase', return_dicts=False))\n        self.levels = level_ids\n\n        image_files = {time_series_id: os.path.join(os.path.dirname(self.uri), f'images-{time_series_id}.db')\n                       for time_series_id in time_series_ids}\n        self.image_files = image_files\n\n    def _get_experiment_metadata(self):\n        \"\"\"\n        Loads experiment metadata and acquisition info into metadata.\n        \"\"\"\n        creation_info = self.db.fetch_all('SELECT DateCreated, Creator, Name FROM ExperimentBase')[0]\n        creation_info['DateCreated'] = convert_dotnet_ticks_to_datetime(creation_info['DateCreated'])\n        self.metadata.update(creation_info)\n\n        acquisitions = self.db.fetch_all('SELECT Name, Description, DateCreated, DateModified FROM AcquisitionExp')\n        for acquisition in acquisitions:\n            acquisition['DateCreated'] = convert_dotnet_ticks_to_datetime(acquisition['DateCreated'])\n            acquisition['DateModified'] = convert_dotnet_ticks_to_datetime(acquisition['DateModified'])\n        self.acquisitions = acquisitions\n\n    def _get_well_info(self):\n        \"\"\"\n        Loads well and channel information into metadata.\n        \"\"\"\n        well_info = self.db.fetch_all('''\n            SELECT SensorSizeYPixels, SensorSizeXPixels, Objective, PixelSizeUm, SensorBitness, SitesX, SitesY\n            FROM AcquisitionExp, AutomaticZonesParametersExp\n        ''')[0]\n\n        # Filter multiple duplicate channel entries\n        channel_infos = self.db.fetch_all('''\n            SELECT DISTINCT ChannelNumber, Emission, Excitation, Dye, Color\n            FROM ImagechannelExp\n            ORDER BY ChannelNumber\n        ''')\n        self.channels = channel_infos\n        self.nchannels = len(channel_infos)\n\n        wells = self.db.fetch_all('SELECT DISTINCT Name FROM Well')\n        zone_names = [well['Name'] for well in wells]\n        rows = set()\n        cols = set()\n        for zone_name in zone_names:\n            row, col = split_well_name(zone_name)\n            rows.add(row)\n            cols.add(col)\n        self.rows = sorted(list(rows))\n        self.columns = sorted(list(cols), key=lambda x: int(x))\n        nfields = well_info['SitesX'] * well_info['SitesY'] * well_info.get('SitesZ', 1)\n        self.fields = list(range(nfields))\n        self.well_info = well_info\n        self.metadata['well_info'] = well_info\n\n        image_wells = self.db.fetch_all('SELECT Name, ZoneIndex, CoordX, CoordY FROM Well WHERE HasImages = 1')\n        self.wells = dict(sorted({well['Name']: well for well in image_wells}.items(),\n                                             key=lambda x: split_well_name(x[0], col_as_int=True)))\n        self.metadata['wells'] = self.wells\n        self.pixel_size = well_info.get('PixelSizeUm', 1)\n\n    def _get_image_info(self):\n        \"\"\"\n        Loads image bit depth and dtype info into metadata.\n        \"\"\"\n        bits_per_pixel = self.db.fetch_all('SELECT DISTINCT BitsPerPixel FROM SourceImageBase', return_dicts=False)[0]\n        self.bits_per_pixel = bits_per_pixel\n        self.dtype = get_bits_type(bits_per_pixel)\n\n    def _get_sizes(self):\n        \"\"\"\n        Calculates and stores image shape and estimated data size.\n        \"\"\"\n        shapes = []\n        scales = []\n        widths = []\n        heights = []\n        width0, height0 = self.well_info['SensorSizeXPixels'], self.well_info['SensorSizeYPixels']\n        sizex0, sizey0 = None, None\n        # Iterate through levels to get level size factor (SourceImageBase contains field-composite images)\n        for level in self.levels:\n            level_info = self.db.fetch_all(\n                'SELECT MAX(CoordX + SizeX) as width, MAX(CoordY + SizeY) as height FROM SourceImageBase WHERE level = ?',\n                [level])\n            sizex, sizey = level_info[0]['width'], level_info[0]['height']\n            if level == 0:\n                sizex0, sizey0 = sizex, sizey\n            width, height = width0 * sizex // sizex0, height0 * sizey // sizey0\n            widths.append(width)\n            heights.append(height)\n            shape = len(self.time_points), self.nchannels, 1, height, width\n            scale = np.mean([width / widths[0], height / heights[0]])\n            shapes.append(shape)\n            scales.append(scale)\n        self.widths = widths\n        self.heights = heights\n        self.shape = shapes[0]\n        self.shapes = shapes\n        self.scales = scales\n\n    def _read_well_info(self, well_id, channel=None, time_point=None, level=0):\n        \"\"\"\n        Reads image info for a specific well, optionally filtered by channel and time point.\n\n        Args:\n            well_id (str): Well identifier.\n            channel (int, optional): Channel ID.\n            time_point (int, optional): Time point ID.\n            level (int, optional): Image level index.\n\n        Returns:\n            list: Well image info dictionaries.\n        \"\"\"\n        well_id = strip_leading_zeros(well_id)\n        well_ids = self.wells\n\n        if well_id not in well_ids:\n            raise ValueError(f'Invalid Well: {well_id}. Available values: {well_ids}')\n\n        zone_index = well_ids[well_id]['ZoneIndex']\n        well_info = self.db.fetch_all('''\n            SELECT *\n            FROM SourceImageBase\n            WHERE ZoneIndex = ? AND level = ?\n            ORDER BY CoordX ASC, CoordY ASC\n        ''', [zone_index, level])\n\n        if channel is not None:\n             well_info = [info for info in well_info if info['ChannelId'] == channel]\n        if time_point is not None:\n             well_info = [info for info in well_info if info['TimeSeriesElementId'] == time_point]\n        if not well_info:\n            raise ValueError(f'No data found for well {well_id}')\n        return well_info\n\n    def _assemble_image_data(self, well_info):\n        \"\"\"\n        Assembles image data array using well info.\n\n        Args:\n            well_info (list): List of well image info dicts.\n        \"\"\"\n        well_info = np.asarray(well_info)\n        xmax = np.max([info['CoordX'] + info['SizeX'] for info in well_info])\n        ymax = np.max([info['CoordY'] + info['SizeY'] for info in well_info])\n        zmax = np.max([info.get('CoordZ', 0) + info.get('SizeZ', 1) for info in well_info])\n        nc = len(set([info['ChannelId'] for info in well_info]))\n        nt = len(set([info['TimeSeriesElementId'] for info in well_info]))\n        data = np.zeros((nt, nc, zmax, ymax, xmax), dtype=self.dtype)\n\n        for timei, time_id in enumerate(self.time_points):\n            image_file = self.image_files[time_id]\n            with open(image_file, 'rb') as fid:\n                for info in well_info:\n                    if info['TimeSeriesElementId'] == time_id:\n                        fid.seek(info['ImageIndex'])\n                        coordx, coordy, coordz = info['CoordX'], info['CoordY'], info.get('CoordZ', 0)\n                        sizex, sizey, sizez = info['SizeX'], info['SizeY'], info.get('SizeZ', 1)\n                        channeli = info['ChannelId']\n                        tile = np.fromfile(fid, dtype=self.dtype, count=sizez * sizey * sizex)\n                        data[timei, channeli, coordz:coordz + sizez, coordy:coordy + sizey, coordx:coordx + sizex] = tile.reshape((sizez, sizey, sizex))\n\n        self.data = data\n\n    def _extract_site(self, site_id=None):\n        \"\"\"\n        Extracts image data for a specific site or all sites.\n\n        Args:\n            site_id (int, optional): Site index. If None, returns all data.\n\n        Returns:\n            ndarray or list: Image data for the site(s).\n        \"\"\"\n        well_info = self.well_info\n        sitesx = well_info['SitesX']\n        sitesy = well_info['SitesY']\n        sitesz = well_info.get('SitesZ', 1)\n        nfields = len(self.fields)\n        sizex = well_info['SensorSizeXPixels']\n        sizey = well_info['SensorSizeYPixels']\n        sizez = well_info.get('SensorSizeZPixels', 1)\n\n        if site_id is None:\n            # Return full image data\n            return self.data\n\n        site_id = int(site_id)\n        if site_id &lt; 0:\n            # Return list of all fields\n            data = []\n            for zi in range(sitesz):\n                for yi in range(sitesy):\n                    for xi in range(sitesx):\n                        startx = xi * sizex\n                        starty = yi * sizey\n                        startz = zi * sizez\n                        data.append(self.data[..., startz:startz + sizez, starty:starty + sizey, startx:startx + sizex])\n            return data\n        elif 0 &lt;= site_id &lt; nfields:\n            # Return specific site\n            xi = site_id % sitesx\n            yi = (site_id // sitesx) % sitesy\n            zi = site_id // sitesx // sitesy\n            startx = xi * sizex\n            starty = yi * sizey\n            startz = zi * sizez\n            return self.data[..., startz:startz + sizez, starty:starty + sizey, startx:startx + sizex]\n        else:\n            raise ValueError(f'Invalid site: {site_id}')\n\n    def is_screen(self):\n        return len(self.wells) &gt; 0\n\n    def get_data(self, dim_order, level=0, well_id=None, field_id=None, **kwargs):\n        if not (well_id == self.data_well_id and level == self.data_level):\n            self._assemble_image_data(self._read_well_info(well_id, level=level))\n            self.data_well_id = well_id\n            self.data_level = level\n        return redimension_data(self._extract_site(field_id), self.dim_order, dim_order)\n\n    def get_name(self):\n        name = self.metadata.get('Name')\n        if not name:\n            name = splitall(os.path.splitext(self.uri)[0])[-2]\n        return name\n\n    def get_rows(self):\n        return self.rows\n\n    def get_columns(self):\n        return self.columns\n\n    def get_wells(self):\n        return list(self.wells)\n\n    def get_time_points(self):\n        return self.time_points\n\n    def get_fields(self):\n        return self.fields\n\n    def get_dim_order(self):\n        return self.dim_order\n\n    def get_dtype(self):\n        return self.dtype\n\n    def get_pixel_size_um(self):\n        return {'x': self.pixel_size, 'y': self.pixel_size}\n\n    def get_position_um(self, well_id=None, level=0):\n        well = self.wells[well_id]\n        x = well.get('CoordX', 0) * self.widths[level] * self.pixel_size\n        y = well.get('CoordY', 0) * self.heights[level] * self.pixel_size\n        return {'x': x, 'y': y}\n\n    def get_channels(self):\n        channels = []\n        for channel0 in self.channels:\n            channel = {}\n            if 'Dye' in channel0 and channel0['Dye']:\n                channel['label'] = channel0['Dye']\n            if 'Color' in channel0:\n                channel['color'] = hexrgb_to_rgba(channel0['Color'].lstrip('#'))\n            channels.append(channel)\n        return channels\n\n    def get_nchannels(self):\n        return max(self.nchannels, 1)\n\n    def is_rgb(self):\n        return False\n\n    def get_acquisitions(self):\n        acquisitions = []\n        for index, acq in enumerate(self.acquisitions):\n            acquisitions.append({\n                'id': index,\n                'name': acq['Name'],\n                'description': acq['Description'],\n                'date_created': acq['DateCreated'].isoformat(),\n                'date_modified': acq['DateModified'].isoformat()\n            })\n        return acquisitions\n\n    def get_acquisition_datetime(self):\n        return self.metadata.get('DateCreated')\n\n    def get_significant_bits(self):\n        return self.bits_per_pixel\n\n    def print_timepoint_well_matrix(self):\n        s = ''\n\n        time_points = self.time_points\n        wells = [well for well in self.wells]\n\n        well_matrix = []\n        for timepoint in time_points:\n            wells_at_timepoint = self.db.fetch_all('''\n                SELECT DISTINCT Well.Name FROM SourceImageBase\n                JOIN Well ON SourceImageBase.ZoneIndex = Well.ZoneIndex\n                WHERE TimeSeriesElementId = ?\n            ''', [timepoint], return_dicts=False)\n\n            row = ['+' if well in wells_at_timepoint else ' ' for well in wells]\n            well_matrix.append(row)\n\n        header = ' '.join([pad_leading_zero(well) for well in wells])\n        s += 'Timepoint ' + header + '\\n'\n        for idx, row in enumerate(well_matrix):\n            s += f'{time_points[idx]:9}  ' + '   '.join(row) + '\\n'\n        return s\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        self.db.close()\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.data","title":"<code>data = None</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageDbSource.ImageDbSource.data_level","title":"<code>data_level = None</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageDbSource.ImageDbSource.data_well_id","title":"<code>data_well_id = None</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageDbSource.ImageDbSource.db","title":"<code>db = DbReader(self.uri)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageDbSource.ImageDbSource.dim_order","title":"<code>dim_order = 'tczyx'</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageDbSource.ImageDbSource.__init__","title":"<code>__init__(uri, metadata={})</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def __init__(self, uri, metadata={}):\n    super().__init__(uri, metadata)\n    self.db = DbReader(self.uri)\n    self.data = None\n    self.data_well_id = None\n    self.data_level = None\n    self.dim_order = 'tczyx'\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.close","title":"<code>close()</code>","text":"<p>Closes the database connection.</p> Source code in <code>src/ImageDbSource.py</code> <pre><code>def close(self):\n    \"\"\"\n    Closes the database connection.\n    \"\"\"\n    self.db.close()\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_acquisition_datetime","title":"<code>get_acquisition_datetime()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_acquisition_datetime(self):\n    return self.metadata.get('DateCreated')\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_acquisitions","title":"<code>get_acquisitions()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_acquisitions(self):\n    acquisitions = []\n    for index, acq in enumerate(self.acquisitions):\n        acquisitions.append({\n            'id': index,\n            'name': acq['Name'],\n            'description': acq['Description'],\n            'date_created': acq['DateCreated'].isoformat(),\n            'date_modified': acq['DateModified'].isoformat()\n        })\n    return acquisitions\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_channels","title":"<code>get_channels()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_channels(self):\n    channels = []\n    for channel0 in self.channels:\n        channel = {}\n        if 'Dye' in channel0 and channel0['Dye']:\n            channel['label'] = channel0['Dye']\n        if 'Color' in channel0:\n            channel['color'] = hexrgb_to_rgba(channel0['Color'].lstrip('#'))\n        channels.append(channel)\n    return channels\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_columns","title":"<code>get_columns()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_columns(self):\n    return self.columns\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_data","title":"<code>get_data(dim_order, level=0, well_id=None, field_id=None, **kwargs)</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_data(self, dim_order, level=0, well_id=None, field_id=None, **kwargs):\n    if not (well_id == self.data_well_id and level == self.data_level):\n        self._assemble_image_data(self._read_well_info(well_id, level=level))\n        self.data_well_id = well_id\n        self.data_level = level\n    return redimension_data(self._extract_site(field_id), self.dim_order, dim_order)\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_dim_order(self):\n    return self.dim_order\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_dtype","title":"<code>get_dtype()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_dtype(self):\n    return self.dtype\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_fields","title":"<code>get_fields()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_fields(self):\n    return self.fields\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_name","title":"<code>get_name()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_name(self):\n    name = self.metadata.get('Name')\n    if not name:\n        name = splitall(os.path.splitext(self.uri)[0])[-2]\n    return name\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_nchannels(self):\n    return max(self.nchannels, 1)\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_pixel_size_um(self):\n    return {'x': self.pixel_size, 'y': self.pixel_size}\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_position_um","title":"<code>get_position_um(well_id=None, level=0)</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_position_um(self, well_id=None, level=0):\n    well = self.wells[well_id]\n    x = well.get('CoordX', 0) * self.widths[level] * self.pixel_size\n    y = well.get('CoordY', 0) * self.heights[level] * self.pixel_size\n    return {'x': x, 'y': y}\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_rows","title":"<code>get_rows()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_rows(self):\n    return self.rows\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_scales","title":"<code>get_scales()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_scales(self):\n    return self.scales\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_shape","title":"<code>get_shape()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_shape(self):\n    return self.shape\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_shapes","title":"<code>get_shapes()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_shapes(self):\n    return self.shapes\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_significant_bits","title":"<code>get_significant_bits()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_significant_bits(self):\n    return self.bits_per_pixel\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_time_points","title":"<code>get_time_points()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_time_points(self):\n    return self.time_points\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.get_wells","title":"<code>get_wells()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def get_wells(self):\n    return list(self.wells)\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.init_metadata","title":"<code>init_metadata()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def init_metadata(self):\n    self._get_time_series_info()\n    self._get_experiment_metadata()\n    self._get_well_info()\n    self._get_image_info()\n    self._get_sizes()\n    return self.metadata\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.is_rgb","title":"<code>is_rgb()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def is_rgb(self):\n    return False\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.is_screen","title":"<code>is_screen()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def is_screen(self):\n    return len(self.wells) &gt; 0\n</code></pre>"},{"location":"references/#src.ImageDbSource.ImageDbSource.print_timepoint_well_matrix","title":"<code>print_timepoint_well_matrix()</code>","text":"Source code in <code>src/ImageDbSource.py</code> <pre><code>def print_timepoint_well_matrix(self):\n    s = ''\n\n    time_points = self.time_points\n    wells = [well for well in self.wells]\n\n    well_matrix = []\n    for timepoint in time_points:\n        wells_at_timepoint = self.db.fetch_all('''\n            SELECT DISTINCT Well.Name FROM SourceImageBase\n            JOIN Well ON SourceImageBase.ZoneIndex = Well.ZoneIndex\n            WHERE TimeSeriesElementId = ?\n        ''', [timepoint], return_dicts=False)\n\n        row = ['+' if well in wells_at_timepoint else ' ' for well in wells]\n        well_matrix.append(row)\n\n    header = ' '.join([pad_leading_zero(well) for well in wells])\n    s += 'Timepoint ' + header + '\\n'\n    for idx, row in enumerate(well_matrix):\n        s += f'{time_points[idx]:9}  ' + '   '.join(row) + '\\n'\n    return s\n</code></pre>"},{"location":"references/#src.ImageDbSource.convert_dotnet_ticks_to_datetime","title":"<code>convert_dotnet_ticks_to_datetime(net_ticks)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def convert_dotnet_ticks_to_datetime(net_ticks):\n    return datetime(1, 1, 1) + timedelta(microseconds=net_ticks // 10)\n</code></pre>"},{"location":"references/#src.ImageDbSource.convert_to_um","title":"<code>convert_to_um(value, unit)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def convert_to_um(value, unit):\n    conversions = {\n        'nm': 1e-3,\n        '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'micron': 1,\n        'mm': 1e3, 'millimeter': 1e3,\n        'cm': 1e4, 'centimeter': 1e4,\n        'm': 1e6, 'meter': 1e6\n    }\n    return value * conversions.get(unit, 1)\n</code></pre>"},{"location":"references/#src.ImageDbSource.ensure_list","title":"<code>ensure_list(item)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def ensure_list(item):\n    if not isinstance(item, (list, tuple)):\n        item = [item]\n    return item\n</code></pre>"},{"location":"references/#src.ImageDbSource.get_bits_type","title":"<code>get_bits_type(nbits)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_bits_type(nbits):\n    if nbits &lt;= 8:\n        dtype = np.uint8\n    elif nbits &lt;= 16:\n        dtype = np.uint16\n    elif nbits &lt;= 32:\n        dtype = np.uint32\n    else:\n        dtype = np.uint64\n    return np.dtype(dtype)\n</code></pre>"},{"location":"references/#src.ImageDbSource.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_filetitle(filename):\n    return os.path.basename(os.path.splitext(filename)[0])\n</code></pre>"},{"location":"references/#src.ImageDbSource.get_level_from_scale","title":"<code>get_level_from_scale(source_scales, target_scale=1)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_level_from_scale(source_scales, target_scale=1):\n    best_level_scale = 0, target_scale\n    for level, scale in enumerate(source_scales):\n        if np.isclose(scale, target_scale, rtol=1e-4):\n            return level, 1\n        if scale &lt;= target_scale:\n            best_level_scale = level, target_scale / scale\n    return best_level_scale\n</code></pre>"},{"location":"references/#src.ImageDbSource.get_numpy_data","title":"<code>get_numpy_data(data, dim_order, t, c, z, y, x, y_size, x_size)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_numpy_data(data, dim_order, t, c, z, y, x, y_size, x_size):\n    x_index = dim_order.index('x')\n    y_index = dim_order.index('y')\n    slices = [slice(None)] * len(dim_order)\n    if 't' in dim_order:\n        slices[dim_order.index('t')] = t\n    if 'c' in dim_order:\n        slices[dim_order.index('c')] = c\n    if 'z' in dim_order:\n        slices[dim_order.index('z')] = z\n    slices[y_index] = slice(y, y + y_size)\n    slices[x_index] = slice(x, x + x_size)\n    return data[tuple(slices)]\n</code></pre>"},{"location":"references/#src.ImageDbSource.get_rows_cols_plate","title":"<code>get_rows_cols_plate(nwells)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_rows_cols_plate(nwells):\n    nrows_cols = {\n        6: (2, 3),\n        12: (3, 4),\n        24: (4, 6),\n        48: (6, 8),\n        96: (8, 12),\n        384: (16, 24)\n    }\n    nrows, ncols = nrows_cols[nwells]\n    rows = [chr(ord('A') + i) for i in range(nrows)]\n    cols = [str(i + 1) for i in range(ncols)]\n    return rows, cols\n</code></pre>"},{"location":"references/#src.ImageDbSource.pad_leading_zero","title":"<code>pad_leading_zero(input_string, num_digits=2)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def pad_leading_zero(input_string, num_digits=2):\n    output = str(input_string)\n    is_well = not output[0].isdigit()\n    if is_well:\n        row, col = split_well_name(output, remove_leading_zeros=True)\n        output = str(col)\n    while len(output) &lt; num_digits:\n        output = '0' + output\n    if is_well:\n        output = row + output\n    return output\n</code></pre>"},{"location":"references/#src.ImageDbSource.print_dict","title":"<code>print_dict(value, tab=0, max_len=250, bullet=False)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def print_dict(value, tab=0, max_len=250, bullet=False):\n    s = ''\n    if isinstance(value, dict):\n        for key, subvalue in value.items():\n            s += '\\n'\n            if bullet:\n                s += '-'\n                bullet = False\n            s += '\\t' * tab + str(key) + ': '\n            if isinstance(subvalue, dict):\n                s += print_dict(subvalue, tab+1)\n            elif isinstance(subvalue, list):\n                for v in subvalue:\n                    s += print_dict(v, tab+1, bullet=True)\n            else:\n                subvalue = str(subvalue)\n                if len(subvalue) &gt; max_len:\n                    subvalue = subvalue[:max_len] + '...'\n                s += subvalue\n    else:\n        s += str(value) + ' '\n    return s\n</code></pre>"},{"location":"references/#src.ImageDbSource.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def print_hbytes(nbytes):\n    exps = ['', 'K', 'M', 'G', 'T', 'P', 'E']\n    div = 1024\n    exp = 0\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    if exp &lt; len(exps):\n        e = exps[exp]\n    else:\n        e = f'e{exp * 3}'\n    return f'{nbytes:.1f}{e}B'\n</code></pre>"},{"location":"references/#src.ImageDbSource.redimension_data","title":"<code>redimension_data(data, old_order, new_order, **indices)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def redimension_data(data, old_order, new_order, **indices):\n    # able to provide optional dimension values e.g. t=0, z=0\n    if new_order == old_order:\n        return data\n\n    new_data = data\n    order = old_order\n    # remove\n    for o in old_order:\n        if o not in new_order:\n            index = order.index(o)\n            dim_value = indices.get(o, 0)\n            new_data = np.take(new_data, indices=dim_value, axis=index)\n            order = order[:index] + order[index + 1:]\n    # add\n    for o in new_order:\n        if o not in order:\n            new_data = np.expand_dims(new_data, 0)\n            order = o + order\n    # move\n    old_indices = [order.index(o) for o in new_order]\n    new_indices = list(range(len(new_order)))\n    new_data = np.moveaxis(new_data, old_indices, new_indices)\n    return new_data\n</code></pre>"},{"location":"references/#src.ImageDbSource.split_well_name","title":"<code>split_well_name(well_name, remove_leading_zeros=True, col_as_int=False)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def split_well_name(well_name, remove_leading_zeros=True, col_as_int=False):\n    matches = re.findall(r'(\\D+)(\\d+)', well_name)\n    if len(matches) &gt; 0:\n        row, col = matches[0]\n        if col_as_int or remove_leading_zeros:\n            try:\n                col = int(col)\n            except ValueError:\n                pass\n        if not col_as_int:\n            col = str(col)\n        return row, col\n    else:\n        raise ValueError(f\"Invalid well name format: {well_name}. Expected format like 'A1', 'B2', etc.\")\n</code></pre>"},{"location":"references/#src.ImageDbSource.splitall","title":"<code>splitall(path)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def splitall(path):\n    allparts = []\n    while True:\n        parts = os.path.split(path)\n        if parts[0] == path:  # sentinel for absolute paths\n            allparts.insert(0, parts[0])\n            break\n        elif parts[1] == path: # sentinel for relative paths\n            allparts.insert(0, parts[1])\n            break\n        else:\n            path = parts[0]\n            allparts.insert(0, parts[1])\n    return allparts\n</code></pre>"},{"location":"references/#src.ImageDbSource.strip_leading_zeros","title":"<code>strip_leading_zeros(well_name)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def strip_leading_zeros(well_name):\n    row, col = split_well_name(well_name, remove_leading_zeros=True)\n    return f'{row}{col}'\n</code></pre>"},{"location":"references/#src.ImageDbSource.validate_filename","title":"<code>validate_filename(filename)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def validate_filename(filename):\n    return re.sub(r'[^\\w_.)(-]', '_', filename)\n</code></pre>"},{"location":"references/#src.ImageDbSource.xml_content_to_dict","title":"<code>xml_content_to_dict(element)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def xml_content_to_dict(element):\n    key = element.tag\n    children = list(element)\n    if key == 'Array':\n        res = [xml_content_to_dict(child) for child in children]\n        return res\n    if len(children) &gt; 0:\n        if children[0].tag == 'Array':\n            value = []\n        else:\n            value = {}\n        for child in children:\n            child_value = xml_content_to_dict(child)\n            if isinstance(child_value, list):\n                value.extend(child_value)\n            else:\n                value |= child_value\n    else:\n        value = element.text\n        if value is not None:\n            if '\"' in value:\n                value = value.replace('\"', '')\n            else:\n                for t in (float, int, bool):\n                    try:\n                        if t == bool:\n                            if value.lower() == 'true':\n                                value = True\n                            if value.lower() == 'false':\n                                value = False\n                        else:\n                            value = t(value)\n                        break\n                    except (TypeError, ValueError):\n                        pass\n\n    if key == 'DataObject':\n        key = element.attrib['ObjectType']\n    if key == 'Attribute':\n        key = element.attrib['Name']\n    return {key: value}\n</code></pre>"},{"location":"references/#src.ImageSource","title":"<code>ImageSource</code>","text":""},{"location":"references/#src.ImageSource.ImageSource","title":"<code>ImageSource</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for image sources.</p> Source code in <code>src/ImageSource.py</code> <pre><code>class ImageSource(ABC):\n    \"\"\"\n    Abstract base class for image sources.\n    \"\"\"\n\n    def __init__(self, uri, metadata={}):\n        \"\"\"\n        Initialize ImageSource.\n\n        Args:\n            uri (str): Path to the image source.\n            metadata (dict): Optional metadata dictionary.\n        \"\"\"\n        self.uri = uri\n        self.metadata = metadata\n\n    def init_metadata(self):\n        \"\"\"\n        Initialize and load metadata.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'init_metadata' method must be implemented by subclasses.\")\n\n    def is_screen(self):\n        \"\"\"\n        Check if the source is a screen (multi-well).\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'is_screen' method must be implemented by subclasses.\")\n\n    def get_shape(self):\n        \"\"\"\n        Get the shape of the image data.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_shape' method must be implemented by subclasses.\")\n\n    def get_shapes(self):\n        \"\"\"\n        Get a list of shapes corresponding to the image data levels.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_shapes' method must be implemented by subclasses.\")\n\n    def get_scales(self):\n        \"\"\"\n        Get the list of image scales.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_scales' method must be implemented by subclasses.\")\n\n    def get_data(self, dim_order, level=0, well_id=None, field_id=None, **kwargs):\n        \"\"\"\n        Get image data for a well and field.\n\n        Args:\n            dim_order: Dimension order of data\n            level (int, optional): Image resolution level\n            well_id (str, optional): Well identifier\n            field_id (int, optional): Field identifier\n            kwargs (optional): Format specific keyword arguments.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_data' method must be implemented by subclasses.\")\n\n    def get_data_as_dask(self, dim_order, level=0, **kwargs):\n        \"\"\"\n        Get image data (WSI) as dask array.\n\n        Args:\n            dim_order: Dimension order of data\n            level (int, optional): Image resolution level\n            kwargs (optional): Format specific keyword arguments.\n        \"\"\"\n        return self.get_data(dim_order, level=level, **kwargs)\n\n    def get_data_as_generator(self, dim_order, **kwargs):\n        \"\"\"\n        Get image data (WSI) as generator.\n\n        Args:\n            dim_order: Dimension order of data\n            kwargs (optional): Format specific keyword arguments.\n        \"\"\"\n        return self.get_data(dim_order, **kwargs)\n\n    def get_image_window(self, window_scanner, well_id=None, field_id=None, data=None):\n        \"\"\"\n        Get image value range window (for a well &amp; field or from provided data).\n\n        Args:\n            window_scanner (WindowScanner): WindowScanner object to compute window.\n            well_id (str, optional): Well identifier\n            field_id (int, optional): Field identifier\n            data (ndarray, optional): Image data to compute window from.\n        \"\"\"\n        # For RGB(A) uint8 images don't change color value range\n        if self.get_dtype() != np.uint8:\n            if data is None:\n                for level, shape in enumerate(self.get_shapes()):\n                    if np.prod(shape) * self.get_dtype().itemsize &lt; 1e8:  # less than 100 MB\n                        data = self.get_data(self.get_dim_order(), well_id=well_id, field_id=field_id, level=level)\n                        break\n            if data is not None:\n                window_scanner.process(data, self.get_dim_order())\n        return window_scanner.get_window()\n\n    def get_name(self):\n        \"\"\"\n        Get the name of the image source.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_name' method must be implemented by subclasses.\")\n\n    def get_dim_order(self):\n        \"\"\"\n        Get the dimension order string.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_dim_order' method must be implemented by subclasses.\")\n\n    def get_dtype(self):\n        \"\"\"\n        Get the numpy dtype of the image data.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_dtype' method must be implemented by subclasses.\")\n\n    def get_pixel_size_um(self):\n        \"\"\"\n        Get the pixel size in micrometers.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_pixel_size_um' method must be implemented by subclasses.\")\n\n    def get_position_um(self, well_id=None):\n        \"\"\"\n        Get the position in micrometers for a well.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_position_um' method must be implemented by subclasses.\")\n\n    def get_channels(self):\n        \"\"\"\n        Get channel metadata in NGFF format, color provided as RGBA list with values between 0 and 1\n        e.g. white = [1, 1, 1, 1]\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_channels' method must be implemented by subclasses.\")\n\n    def get_nchannels(self):\n        \"\"\"\n        Get the number of channels.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_nchannels' method must be implemented by subclasses.\")\n\n    def is_rgb(self):\n        \"\"\"\n        Check if the source is a RGB(A) image.\n        \"\"\"\n        raise NotImplementedError(\"The 'is_rgb' method must be implemented by subclasses.\")\n\n    def get_rows(self):\n        \"\"\"\n        Get the list of row identifiers.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_rows' method must be implemented by subclasses.\")\n\n    def get_columns(self):\n        \"\"\"\n        Get the list of column identifiers.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_columns' method must be implemented by subclasses.\")\n\n    def get_wells(self):\n        \"\"\"\n        Get the list of well identifiers.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_wells' method must be implemented by subclasses.\")\n\n    def get_time_points(self):\n        \"\"\"\n        Get the list of time points.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_time_points' method must be implemented by subclasses.\")\n\n    def get_fields(self):\n        \"\"\"\n        Get the list of field indices.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_fields' method must be implemented by subclasses.\")\n\n    def get_acquisitions(self):\n        \"\"\"\n        Get acquisition metadata.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_acquisitions' method must be implemented by subclasses.\")\n\n    def get_acquisition_datetime(self):\n        \"\"\"\n        Get the acquisition datetime.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_acquisition_datetime' method must be implemented by subclasses.\")\n\n    def get_significant_bits(self):\n        \"\"\"\n        Get the number of significant bits in the image data.\n\n        Raises:\n            NotImplementedError: Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"The 'get_significant_bits' method must be implemented by subclasses.\")\n\n    def get_total_data_size(self):\n        \"\"\"\n        Get the estimated total data size.\n\n        Returns:\n            int: Total data size in bytes.\n        \"\"\"\n        image_size = np.prod(self.get_shape()) * np.dtype(self.get_dtype()).itemsize\n        if self.is_screen():\n            nwells = len(self.get_wells())\n            nfields = len(self.get_fields())\n            total_size = image_size * nwells * nfields\n        else:\n            total_size = image_size\n        return total_size\n\n    def close(self):\n        \"\"\"\n        Close the image source.\n        \"\"\"\n        pass\n\n\n    def print_well_matrix(self):\n        \"\"\"\n        Print a matrix representation of the well plate.\n        \"\"\"\n        s = ''\n\n        rows, cols = self.get_rows(), self.get_columns()\n        used_wells = [well for well in self.get_wells()]\n\n        well_matrix = []\n        for row_id in rows:\n            row = ''\n            for col_id in cols:\n                well_id = f'{row_id}{col_id}'\n                row += '+' if well_id in used_wells else ' '\n            well_matrix.append(row)\n\n        header = ' '.join([pad_leading_zero(col) for col in cols])\n        s += ' ' + header + '\\n'\n        for idx, row in enumerate(well_matrix):\n            s += f'{rows[idx]} ' + '  '.join(row) + '\\n'\n        return s\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.metadata","title":"<code>metadata = metadata</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageSource.ImageSource.uri","title":"<code>uri = uri</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.ImageSource.ImageSource.__init__","title":"<code>__init__(uri, metadata={})</code>","text":"<p>Initialize ImageSource.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>Path to the image source.</p> required <code>metadata</code> <code>dict</code> <p>Optional metadata dictionary.</p> <code>{}</code> Source code in <code>src/ImageSource.py</code> <pre><code>def __init__(self, uri, metadata={}):\n    \"\"\"\n    Initialize ImageSource.\n\n    Args:\n        uri (str): Path to the image source.\n        metadata (dict): Optional metadata dictionary.\n    \"\"\"\n    self.uri = uri\n    self.metadata = metadata\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.close","title":"<code>close()</code>","text":"<p>Close the image source.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def close(self):\n    \"\"\"\n    Close the image source.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_acquisition_datetime","title":"<code>get_acquisition_datetime()</code>","text":"<p>Get the acquisition datetime.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_acquisition_datetime(self):\n    \"\"\"\n    Get the acquisition datetime.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_acquisition_datetime' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_acquisitions","title":"<code>get_acquisitions()</code>","text":"<p>Get acquisition metadata.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_acquisitions(self):\n    \"\"\"\n    Get acquisition metadata.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_acquisitions' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_channels","title":"<code>get_channels()</code>","text":"<p>Get channel metadata in NGFF format, color provided as RGBA list with values between 0 and 1 e.g. white = [1, 1, 1, 1]</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_channels(self):\n    \"\"\"\n    Get channel metadata in NGFF format, color provided as RGBA list with values between 0 and 1\n    e.g. white = [1, 1, 1, 1]\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_channels' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_columns","title":"<code>get_columns()</code>","text":"<p>Get the list of column identifiers.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_columns(self):\n    \"\"\"\n    Get the list of column identifiers.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_columns' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_data","title":"<code>get_data(dim_order, level=0, well_id=None, field_id=None, **kwargs)</code>","text":"<p>Get image data for a well and field.</p> <p>Parameters:</p> Name Type Description Default <code>dim_order</code> <p>Dimension order of data</p> required <code>level</code> <code>int</code> <p>Image resolution level</p> <code>0</code> <code>well_id</code> <code>str</code> <p>Well identifier</p> <code>None</code> <code>field_id</code> <code>int</code> <p>Field identifier</p> <code>None</code> <code>kwargs</code> <code>optional</code> <p>Format specific keyword arguments.</p> <code>{}</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_data(self, dim_order, level=0, well_id=None, field_id=None, **kwargs):\n    \"\"\"\n    Get image data for a well and field.\n\n    Args:\n        dim_order: Dimension order of data\n        level (int, optional): Image resolution level\n        well_id (str, optional): Well identifier\n        field_id (int, optional): Field identifier\n        kwargs (optional): Format specific keyword arguments.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_data' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_data_as_dask","title":"<code>get_data_as_dask(dim_order, level=0, **kwargs)</code>","text":"<p>Get image data (WSI) as dask array.</p> <p>Parameters:</p> Name Type Description Default <code>dim_order</code> <p>Dimension order of data</p> required <code>level</code> <code>int</code> <p>Image resolution level</p> <code>0</code> <code>kwargs</code> <code>optional</code> <p>Format specific keyword arguments.</p> <code>{}</code> Source code in <code>src/ImageSource.py</code> <pre><code>def get_data_as_dask(self, dim_order, level=0, **kwargs):\n    \"\"\"\n    Get image data (WSI) as dask array.\n\n    Args:\n        dim_order: Dimension order of data\n        level (int, optional): Image resolution level\n        kwargs (optional): Format specific keyword arguments.\n    \"\"\"\n    return self.get_data(dim_order, level=level, **kwargs)\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_data_as_generator","title":"<code>get_data_as_generator(dim_order, **kwargs)</code>","text":"<p>Get image data (WSI) as generator.</p> <p>Parameters:</p> Name Type Description Default <code>dim_order</code> <p>Dimension order of data</p> required <code>kwargs</code> <code>optional</code> <p>Format specific keyword arguments.</p> <code>{}</code> Source code in <code>src/ImageSource.py</code> <pre><code>def get_data_as_generator(self, dim_order, **kwargs):\n    \"\"\"\n    Get image data (WSI) as generator.\n\n    Args:\n        dim_order: Dimension order of data\n        kwargs (optional): Format specific keyword arguments.\n    \"\"\"\n    return self.get_data(dim_order, **kwargs)\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"<p>Get the dimension order string.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_dim_order(self):\n    \"\"\"\n    Get the dimension order string.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_dim_order' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_dtype","title":"<code>get_dtype()</code>","text":"<p>Get the numpy dtype of the image data.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_dtype(self):\n    \"\"\"\n    Get the numpy dtype of the image data.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_dtype' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_fields","title":"<code>get_fields()</code>","text":"<p>Get the list of field indices.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_fields(self):\n    \"\"\"\n    Get the list of field indices.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_fields' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_image_window","title":"<code>get_image_window(window_scanner, well_id=None, field_id=None, data=None)</code>","text":"<p>Get image value range window (for a well &amp; field or from provided data).</p> <p>Parameters:</p> Name Type Description Default <code>window_scanner</code> <code>WindowScanner</code> <p>WindowScanner object to compute window.</p> required <code>well_id</code> <code>str</code> <p>Well identifier</p> <code>None</code> <code>field_id</code> <code>int</code> <p>Field identifier</p> <code>None</code> <code>data</code> <code>ndarray</code> <p>Image data to compute window from.</p> <code>None</code> Source code in <code>src/ImageSource.py</code> <pre><code>def get_image_window(self, window_scanner, well_id=None, field_id=None, data=None):\n    \"\"\"\n    Get image value range window (for a well &amp; field or from provided data).\n\n    Args:\n        window_scanner (WindowScanner): WindowScanner object to compute window.\n        well_id (str, optional): Well identifier\n        field_id (int, optional): Field identifier\n        data (ndarray, optional): Image data to compute window from.\n    \"\"\"\n    # For RGB(A) uint8 images don't change color value range\n    if self.get_dtype() != np.uint8:\n        if data is None:\n            for level, shape in enumerate(self.get_shapes()):\n                if np.prod(shape) * self.get_dtype().itemsize &lt; 1e8:  # less than 100 MB\n                    data = self.get_data(self.get_dim_order(), well_id=well_id, field_id=field_id, level=level)\n                    break\n        if data is not None:\n            window_scanner.process(data, self.get_dim_order())\n    return window_scanner.get_window()\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_name","title":"<code>get_name()</code>","text":"<p>Get the name of the image source.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_name(self):\n    \"\"\"\n    Get the name of the image source.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_name' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"<p>Get the number of channels.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_nchannels(self):\n    \"\"\"\n    Get the number of channels.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_nchannels' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"<p>Get the pixel size in micrometers.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_pixel_size_um(self):\n    \"\"\"\n    Get the pixel size in micrometers.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_pixel_size_um' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_position_um","title":"<code>get_position_um(well_id=None)</code>","text":"<p>Get the position in micrometers for a well.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_position_um(self, well_id=None):\n    \"\"\"\n    Get the position in micrometers for a well.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_position_um' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_rows","title":"<code>get_rows()</code>","text":"<p>Get the list of row identifiers.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_rows(self):\n    \"\"\"\n    Get the list of row identifiers.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_rows' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_scales","title":"<code>get_scales()</code>","text":"<p>Get the list of image scales.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_scales(self):\n    \"\"\"\n    Get the list of image scales.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_scales' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_shape","title":"<code>get_shape()</code>","text":"<p>Get the shape of the image data.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_shape(self):\n    \"\"\"\n    Get the shape of the image data.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_shape' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_shapes","title":"<code>get_shapes()</code>","text":"<p>Get a list of shapes corresponding to the image data levels.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_shapes(self):\n    \"\"\"\n    Get a list of shapes corresponding to the image data levels.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_shapes' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_significant_bits","title":"<code>get_significant_bits()</code>","text":"<p>Get the number of significant bits in the image data.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_significant_bits(self):\n    \"\"\"\n    Get the number of significant bits in the image data.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_significant_bits' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_time_points","title":"<code>get_time_points()</code>","text":"<p>Get the list of time points.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_time_points(self):\n    \"\"\"\n    Get the list of time points.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_time_points' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_total_data_size","title":"<code>get_total_data_size()</code>","text":"<p>Get the estimated total data size.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Total data size in bytes.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_total_data_size(self):\n    \"\"\"\n    Get the estimated total data size.\n\n    Returns:\n        int: Total data size in bytes.\n    \"\"\"\n    image_size = np.prod(self.get_shape()) * np.dtype(self.get_dtype()).itemsize\n    if self.is_screen():\n        nwells = len(self.get_wells())\n        nfields = len(self.get_fields())\n        total_size = image_size * nwells * nfields\n    else:\n        total_size = image_size\n    return total_size\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.get_wells","title":"<code>get_wells()</code>","text":"<p>Get the list of well identifiers.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def get_wells(self):\n    \"\"\"\n    Get the list of well identifiers.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'get_wells' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.init_metadata","title":"<code>init_metadata()</code>","text":"<p>Initialize and load metadata.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def init_metadata(self):\n    \"\"\"\n    Initialize and load metadata.\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'init_metadata' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.is_rgb","title":"<code>is_rgb()</code>","text":"<p>Check if the source is a RGB(A) image.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def is_rgb(self):\n    \"\"\"\n    Check if the source is a RGB(A) image.\n    \"\"\"\n    raise NotImplementedError(\"The 'is_rgb' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.is_screen","title":"<code>is_screen()</code>","text":"<p>Check if the source is a screen (multi-well).</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def is_screen(self):\n    \"\"\"\n    Check if the source is a screen (multi-well).\n\n    Raises:\n        NotImplementedError: Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"The 'is_screen' method must be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.ImageSource.ImageSource.print_well_matrix","title":"<code>print_well_matrix()</code>","text":"<p>Print a matrix representation of the well plate.</p> Source code in <code>src/ImageSource.py</code> <pre><code>def print_well_matrix(self):\n    \"\"\"\n    Print a matrix representation of the well plate.\n    \"\"\"\n    s = ''\n\n    rows, cols = self.get_rows(), self.get_columns()\n    used_wells = [well for well in self.get_wells()]\n\n    well_matrix = []\n    for row_id in rows:\n        row = ''\n        for col_id in cols:\n            well_id = f'{row_id}{col_id}'\n            row += '+' if well_id in used_wells else ' '\n        well_matrix.append(row)\n\n    header = ' '.join([pad_leading_zero(col) for col in cols])\n    s += ' ' + header + '\\n'\n    for idx, row in enumerate(well_matrix):\n        s += f'{rows[idx]} ' + '  '.join(row) + '\\n'\n    return s\n</code></pre>"},{"location":"references/#src.IncucyteSource","title":"<code>IncucyteSource</code>","text":""},{"location":"references/#src.IncucyteSource.IncucyteSource","title":"<code>IncucyteSource</code>","text":"<p>               Bases: <code>ImageSource</code></p> <p>ImageSource implementation for Incucyte data</p> <p>Handles the specific directory structure: EssenFiles/ScanData/YYMM/DD/HHMM/XXXX/*.tif</p> <p>Filenames follow pattern: WELL-FIELD-CHANNEL.tif e.g., A1-1-C1.tif, B2-1-Ph.tif</p> <p>Note: Multiple plates can exist in the same archive, identified by the XXXX folder. Use plate_id parameter to select a specific plate, or use get_available_plates()  to discover all plates in the archive.</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>class IncucyteSource(ImageSource):\n    \"\"\"\n    ImageSource implementation for Incucyte data\n\n    Handles the specific directory structure:\n    EssenFiles/ScanData/YYMM/DD/HHMM/XXXX/*.tif\n\n    Filenames follow pattern: WELL-FIELD-CHANNEL.tif\n    e.g., A1-1-C1.tif, B2-1-Ph.tif\n\n    Note: Multiple plates can exist in the same archive, identified by the XXXX folder.\n    Use plate_id parameter to select a specific plate, or use get_available_plates() \n    to discover all plates in the archive.\n    \"\"\"\n\n    DIAG_ZIP_FILENAME = \"Diag.zip\"\n    DIAG_LOG_FILENAME = \"Diag.log\"\n\n    def __init__(self, uri, metadata={}, plate_id=None):\n        \"\"\"\n        Initialize IncucyteSource.\n\n        Args:\n            uri (str): Path to the Incucyte archive folder\n            metadata (dict): Optional metadata dictionary\n            plate_id (str, optional): Specific plate ID to process (e.g., '700', '701').\n                                     If None, will use the first available plate or all \n                                     if only one exists.\n        \"\"\"\n        super().__init__(uri, metadata)\n        self.plate_id = plate_id\n        self.base_path = Path(self.uri)\n        self.scan_data_path = self.base_path / \"EssenFiles\" / \"ScanData\"\n        self._file_cache = {}\n        self._file_caching = False\n        # Default to True for filling missing images\n        self.fill_missing_images = True\n\n    @staticmethod\n    def get_available_plates(uri):\n        \"\"\"\n        Discover all available plate IDs in an Incucyte archive.\n\n        Args:\n            uri (str): Path to the Incucyte archive folder\n\n        Returns:\n            list: List of plate IDs (strings) found in the archive\n        \"\"\"\n        base_path = Path(uri)\n        scan_data_path = base_path / \"EssenFiles\" / \"ScanData\"\n\n        if not scan_data_path.exists():\n            raise ValueError(f\"Scan data path not found: {scan_data_path}\")\n\n        plate_ids = set()\n\n        # Navigate through the directory structure to find all plate IDs\n        for year_month in scan_data_path.iterdir():\n            if not year_month.is_dir():\n                continue\n            for day in year_month.iterdir():\n                if not day.is_dir():\n                    continue\n                for time_dir in day.iterdir():\n                    if not time_dir.is_dir():\n                        continue\n                    for plate_dir in time_dir.iterdir():\n                        if plate_dir.is_dir():\n                            plate_ids.add(plate_dir.name)\n\n        return sorted(list(plate_ids))\n\n    def enable_file_caching(self, file_caching=True):\n        \"\"\"\n        Enable or disable file caching for image data.\n\n        Args:\n            file_caching (bool): If True, enable file caching; if False, disable it.\n        \"\"\"\n        self._file_caching = file_caching\n        if not file_caching:\n            self._file_cache.clear()\n\n    def _find_and_parse_diag_log(self):\n        \"\"\"\n        Find the first Diag.zip in the scan data and parse it.\n\n        Returns:\n            dict: Parsed diag metadata or None if not found\n        \"\"\"\n        # Look for first Diag.zip in the scan data\n        diag_zip_files = list(self.scan_data_path.rglob(self.DIAG_ZIP_FILENAME))\n\n        if diag_zip_files:\n            results = self._parse_diag_log(diag_zip_files[0])\n        else:\n            results = None\n\n        return results\n\n    def _parse_diag_log(self, diag_zip_path):\n        \"\"\"\n        Parse Diag.log from a Diag.zip file to extract imaging metadata.\n\n        Args:\n            diag_zip_path (Path): Path to Diag.zip file\n\n        Returns:\n            dict: Dictionary with 'pixel_sizes' (dict of mag-&gt;size),\n                  'experiments' (dict of expid-&gt;metadata), or None if failed\n        \"\"\"\n        try:\n            with zipfile.ZipFile(diag_zip_path) as zip_ref:\n                if self.DIAG_LOG_FILENAME not in zip_ref.namelist():\n                    return None\n\n                raw = zip_ref.read(self.DIAG_LOG_FILENAME)\n                detection = chardet.detect(raw)\n                content = raw.decode(detection['encoding'], errors='ignore')\n\n                # Parse imaging specifications\n                pixel_sizes = {}\n                mag_pattern = r'(\\d+)x:\\s+.*?Image Resolution:\\s+([\\d.]+)\\s+microns/pixel'\n                for match in re.finditer(mag_pattern, content, re.DOTALL):\n                    mag = match.group(1) + 'x'\n                    pixel_size = float(match.group(2))\n                    pixel_sizes[mag] = pixel_size\n\n                # Parse experiment entries\n                experiments = {}\n                # Match ExpID and capture next 2 lines for Lmp info\n                exp_pattern = r'ExpID=(\\d+)[^\\n]*Mag=(\\d+x)[^\\n]*(?:\\n[^\\n]*)?'\n                for match in re.finditer(exp_pattern, content):\n                    exp_id = match.group(1)\n                    mag = match.group(2)\n\n                    # Extract all exposure times from matched section\n                    exp_section = match.group(0)\n                    acq_times = re.findall(r'AcqTime=(\\d+)', exp_section)\n\n                    experiments[exp_id] = {\n                        'magnification': mag,\n                        'exposure_times_ms': [int(t) for t in acq_times] if acq_times else None,\n                        'pixel_size_um': pixel_sizes.get(mag)\n                    }\n\n                results = {\n                    'experiments': experiments,\n                }\n\n                nwell_raw = re.findall(r'(\\d+)-well', content)\n                if nwell_raw:\n                    results['nwell_plate'] = int(Counter(nwell_raw).most_common(1)[0][0])\n\n                return results\n        except Exception as e:\n            print(f\"Warning: Could not parse {self.DIAG_LOG_FILENAME} from {diag_zip_path}: {e}\")\n            return None\n\n    def init_metadata(self):\n        \"\"\"Initialize all metadata from Incucyte structure\"\"\"\n        self._scan_timepoints()  # Must be first to set plate_id\n        self._get_experiment_metadata()  # Uses plate_id in name\n        self._get_sample_image_info()\n        self._get_well_info()\n        self._get_channel_info()\n        self._get_image_info()\n\n        # Initialize properties like TiffSource does\n        self.name = self.metadata.get(\"Name\", \"Incucyte_Experiment\")\n        self.dim_order = self.metadata.get(\"dim_order\", \"tczyx\")\n        self.dtype = self.metadata.get(\"dtype\", np.uint16)\n        self.pixel_size = self._get_pixel_size_dict()\n        self.channels = self._format_channels_for_interface()\n        self.is_plate = len(self.metadata.get(\"wells\", {})) &gt; 0\n        self.wells = list(self.metadata.get(\"wells\", {}).keys())\n        self.rows = self.metadata.get(\"well_info\", {}).get(\"rows\", [])\n        self.columns = self.metadata.get(\"well_info\", {}).get(\"columns\", [])\n\n        nt = len(self.metadata[\"time_points\"])\n        nc = self.metadata[\"num_channels\"]\n        nz = 1  # Incucyte is typically 2D\n        self.shape = nt, nc, nz, self.height, self.width\n        self.shapes = [(nt, nc, nz, height, width) for height, width in zip(self.heights, self.widths)]\n        self.scales = [np.mean([width / self.width, height / self.height]) for width, height in zip(self.widths, self.heights)]\n\n        return self.metadata\n\n    def _get_experiment_metadata(self):\n        \"\"\"Extract experiment metadata from folder structure\"\"\"\n        experiment_name = self.base_path.name\n\n        # Add plate ID to name (plate_id is set by _scan_timepoints)\n        if self.plate_id:\n            experiment_name = f\"{experiment_name}_plate{self.plate_id}\"\n\n        self.metadata.update(\n            {\n                \"Name\": experiment_name,\n                \"Creator\": \"Incucyte\",\n                \"DateCreated\": datetime.now(),\n                \"dim_order\": \"tczyx\",\n            }\n        )\n\n    def _scan_timepoints(self):\n        \"\"\"Scan the Incucyte directory structure for timepoints\"\"\"\n        timepoints = []\n        wells = set()\n        fields = set()\n        channels = set()\n        found_plate_ids = set()\n\n        print(f\"Scanning directory: {self.scan_data_path}\")\n\n        if not self.scan_data_path.exists():\n            raise ValueError(\n                f\"Scan data path not found: {self.scan_data_path}\"\n            )\n\n        # Navigate through year/month directories (YYMM)\n        for year_month in self.scan_data_path.iterdir():\n            if not year_month.is_dir():\n                continue\n            # Navigate through day directories (DD)\n            for day in year_month.iterdir():\n                if not day.is_dir():\n                    continue\n                # Navigate through time directories (HHMM)\n                for time_dir in day.iterdir():\n                    if not time_dir.is_dir():\n                        continue\n                    # Navigate through plate ID directories (XXXX)\n                    for plate_dir in time_dir.iterdir():\n                        if not plate_dir.is_dir():\n                            continue\n\n                        current_plate_id = plate_dir.name\n                        found_plate_ids.add(current_plate_id)\n\n                        # Filter by plate_id if specified\n                        if self.plate_id is not None:\n                            if current_plate_id != self.plate_id:\n                                continue\n\n                        timepoint_path = plate_dir\n                        timestamp = (\n                            f\"{year_month.name}_{day.name}_{time_dir.name}\"\n                        )\n\n                        # Parse timestamp to datetime\n                        try:\n                            dt = datetime.strptime(timestamp, \"%y%m_%d_%H%M\")\n                            if dt.year &lt; 2000:\n                                dt = dt.replace(year=dt.year + 2000)\n                        except ValueError:\n                            dt = None\n\n                        timepoint_info = {\n                            \"path\": timepoint_path,\n                            \"timestamp\": timestamp,\n                            \"datetime\": dt,\n                            \"index\": len(timepoints),\n                            \"plate_id\": current_plate_id,\n                        }\n                        timepoints.append(timepoint_info)\n\n                        # Scan TIFF files in this timepoint\n                        for tiff_file in timepoint_path.glob(\"*.tif\"):\n                            well, field, channel = self._parse_filename(tiff_file.name)\n                            if well and field is not None and channel:\n                                wells.add(well)\n                                fields.add(field)\n                                channels.add(channel)\n\n        # Handle plate selection\n        if self.plate_id is None:\n            # Auto-select plate\n            if len(found_plate_ids) == 0:\n                raise ValueError(\"No plates found in the archive\")\n            elif len(found_plate_ids) == 1:\n                # Single plate - use it automatically\n                self.plate_id = list(found_plate_ids)[0]\n            else:\n                # Multiple plates - use first with warning\n                plate_list = \", \".join(sorted(found_plate_ids))\n                print(\n                    f\"Warning: Multiple plates found ({plate_list}). \"\n                    f\"Using first plate: {sorted(found_plate_ids)[0]}\"\n                )\n                print(\n                    \"To process a specific plate, use: \"\n                    \"IncucyteSource(uri, plate_id='XXX')\"\n                )\n                print(\n                    \"To process all plates, call get_available_plates() \"\n                    \"and create separate sources\"\n                )\n                self.plate_id = sorted(found_plate_ids)[0]\n\n            # Filter timepoints to selected plate\n            timepoints = [\n                tp for tp in timepoints if tp[\"plate_id\"] == self.plate_id\n            ]\n        else:\n            # Validate specified plate_id\n            if self.plate_id not in found_plate_ids:\n                raise ValueError(\n                    f\"Plate ID '{self.plate_id}' not found. \"\n                    f\"Available plates: {', '.join(sorted(found_plate_ids))}\"\n                )\n            # Filter timepoints to specified plate\n            timepoints = [\n                tp for tp in timepoints if tp[\"plate_id\"] == self.plate_id\n            ]\n\n        # Store found plate IDs in metadata\n        self.metadata[\"available_plates\"] = sorted(found_plate_ids)\n        self.metadata[\"selected_plate\"] = self.plate_id\n\n        # Sort timepoints by datetime if available, otherwise by timestamp\n        timepoints.sort(\n            key=lambda x: x[\"datetime\"] if x[\"datetime\"] else x[\"timestamp\"]\n        )\n\n        # Update indices after sorting\n        for i, tp in enumerate(timepoints):\n            tp[\"index\"] = i\n\n        self.metadata.update(\n            {\n                \"timepoints\": timepoints,\n                \"time_points\": [tp[\"index\"] for tp in timepoints],\n                \"wells_raw\": sorted(wells),\n                \"fields_raw\": sorted(fields),\n                \"channels_raw\": sorted(channels),\n            }\n        )\n\n        plate_info = (\n            f\" (plate: {self.plate_id})\" if self.plate_id else \"\"\n        )\n        print(\n            f\"Found{plate_info}: {len(timepoints)} timepoints, \"\n            f\"{len(wells)} wells, {len(fields)} fields, \"\n            f\"{len(channels)} channels\"\n        )\n\n    def _parse_filename(self, filename):\n        \"\"\"\n        Parse Incucyte filename format: WELL-FIELD-CHANNEL.tif\n        Examples: A1-1-C1.tif, B2-1-Ph.tif\n        Returns: (well, field, channel)\n        \"\"\"\n        pattern = r\"([A-Z]\\d+)-(\\d+)-(.+)\\.tif\"\n        match = re.match(pattern, filename)\n        if match:\n            well = match.group(1)\n            field = int(match.group(2)) - 1  # Convert to 0-based indexing\n            channel = match.group(3)\n            return well, field, channel\n        return None, None, None\n\n    def _get_well_info(self):\n        \"\"\"Process well information and determine plate layout\"\"\"\n        wells_raw = self.metadata[\"wells_raw\"]\n\n        if not wells_raw:\n            raise ValueError(\"No wells found in data\")\n\n        # Parse well positions\n        rows = set()\n        cols = set()\n        wells_dict = {}\n\n        for well_index, well_name in enumerate(wells_raw):\n            row, col = split_well_name(well_name, col_as_int=True)\n\n            rows.add(row)\n            cols.add(col)\n\n            wells_dict[well_name] = {\n                \"Name\": well_name,\n                \"row\": ord(row) - ord(\"A\"),\n                \"column\": col - 1,\n                \"ZoneIndex\": well_index,\n            }\n\n        nwell_plate = self.sample_image_info.get(\"nwell_plate\")\n        if nwell_plate:\n            rows, cols = get_rows_cols_plate(nwell_plate)\n        else:\n            rows = sorted(rows)\n            cols = [str(col) for col in sorted(cols)]\n\n        # Get image dimensions from first available image\n        sample_image_info = self.sample_image_info\n\n        well_info = {\n            \"rows\": rows,\n            \"columns\": cols,\n            \"SensorSizeXPixels\": sample_image_info[\"width\"],\n            \"SensorSizeYPixels\": sample_image_info[\"height\"],\n            \"SitesX\": 1,\n            \"SitesY\": 1,\n            \"num_sites\": len(self.metadata[\"fields_raw\"]),\n            \"fields\": [str(f) for f in self.metadata[\"fields_raw\"]],\n            \"PixelSizeUm\": sample_image_info[\"pixel_x\"],\n            \"SensorBitness\": sample_image_info[\"bits\"],\n            \"max_sizex_um\": sample_image_info[\"width\"] * sample_image_info[\"pixel_x\"],\n            \"max_sizey_um\": sample_image_info[\"height\"] * sample_image_info[\"pixel_y\"],\n        }\n\n        # Add optional imaging metadata if available\n        if \"magnification\" in sample_image_info:\n            well_info[\"Magnification\"] = sample_image_info[\"magnification\"]\n        if \"exposure_times_ms\" in sample_image_info:\n            well_info[\"ExposureTimes_ms\"] = sample_image_info[\"exposure_times_ms\"]\n\n        self.metadata.update({\"wells\": wells_dict, \"well_info\": well_info})\n\n    def _get_sample_image_info(self):\n        \"\"\"Get image dimensions and bit depth from first available TIFF.\n        Attempts to get accurate pixel size from Diag.log if available.\"\"\"\n\n        pixel_size_from_diag = None\n        magnification = None\n        exposure_time = None\n        nwell_plate = None\n\n        if self.plate_id:\n            # Try to get calibrated pixel size from Diag.log\n            diag_metadata = self._find_and_parse_diag_log()\n            if diag_metadata and 'experiments' in diag_metadata:\n                exp_info = diag_metadata['experiments'].get(self.plate_id)\n                if exp_info:\n                    pixel_size_from_diag = exp_info.get('pixel_size_um')\n                    magnification = exp_info.get('magnification')\n                    exposure_times = exp_info.get('exposure_times_ms')\n                    # Use the exposure times list if available\n                    exposure_time = exposure_times\n                    if pixel_size_from_diag:\n                        print(f\"Found calibrated pixel size from {self.DIAG_LOG_FILENAME}: \"\n                              f\"{pixel_size_from_diag} \u00b5m/pixel \"\n                              f\"(Magnification: {magnification})\")\n                nwell_plate = diag_metadata.get('nwell_plate')\n\n        for timepoint in self.metadata[\"timepoints\"]:\n            for tiff_file in timepoint[\"path\"].glob(\"*.tif\"):\n                try:\n                    # Get actual image dimensions from the file\n                    with tifffile.TiffFile(str(tiff_file)) as tif:\n                        page = tif.pages.first\n                        width = page.sizes[\"width\"]\n                        height = page.sizes[\"height\"]\n                        dtype = page.dtype\n                        bits = dtype.itemsize * 8\n                        if tif.series:\n                            series_page = tif.series[0]\n                            if hasattr(series_page, 'levels'):\n                                level_pages = series_page.levels\n                                widths = [level_page.sizes[\"width\"] for level_page in level_pages]\n                                heights = [level_page.sizes[\"height\"] for level_page in level_pages]\n\n                    # Use calibrated pixel size from Diag.log if available\n                    if pixel_size_from_diag:\n                        pixel_x = pixel_size_from_diag\n                        pixel_y = pixel_size_from_diag\n                    else:\n                        # Fallback to TIFF metadata\n                        temp_tiff_source = TiffSource(str(tiff_file))\n                        temp_tiff_source.init_metadata()\n                        pixel_size = temp_tiff_source.get_pixel_size_um()\n                        temp_tiff_source.close()\n                        pixel_x = pixel_size.get(\"x\")\n                        pixel_y = pixel_size.get(\"y\")\n\n                    self.sample_image_info = {\n                        \"width\": width,\n                        \"height\": height,\n                        \"bits\": bits,\n                        \"dtype\": dtype,\n                        \"pixel_x\": pixel_x,\n                        \"pixel_y\": pixel_y,\n                    }\n                    self.width = width\n                    self.height = height\n                    self.widths = widths\n                    self.heights = heights\n\n                    # Add optional metadata if available\n                    if magnification:\n                        self.sample_image_info[\"magnification\"] = magnification\n                    if exposure_time:\n                        self.sample_image_info[\"exposure_times_ms\"] = exposure_time\n                    if nwell_plate:\n                        self.sample_image_info[\"nwell_plate\"] = nwell_plate\n\n                    return\n\n                except Exception as e:\n                    print(f\"Could not read sample image {tiff_file}: {e}\")\n                    continue\n\n        # If no valid TIFF files found\n        raise ValueError(\n            f\"No valid TIFF files found in experiment directory: \"\n            f\"{self.scan_data_path}\"\n        )\n\n    def _get_channel_info(self):\n        \"\"\"Process channel information\"\"\"\n        channels_raw = self.metadata[\"channels_raw\"]\n        channels = []\n\n        channel_mapping = {\n            \"C1\": {\"label\": \"Green\", \"color\": \"00FF00\"},\n            \"C2\": {\"label\": \"Red\", \"color\": \"FF0000\"},\n            \"Ph\": {\"label\": \"Phase_Contrast\", \"color\": \"FFFFFF\"},\n            \"P\": {\"label\": \"Phase_Contrast\", \"color\": \"FFFFFF\"},\n        }\n\n        for i, channel_code in enumerate(channels_raw):\n            channel_info = channel_mapping.get(\n                channel_code, {\"label\": channel_code, \"color\": \"FFFFFF\"}\n            )\n\n            channels.append(\n                {\n                    \"ChannelNumber\": i,\n                    \"Dye\": channel_info[\"label\"],\n                    \"Color\": f\"#{channel_info['color']}\",\n                    \"Emission\": None,\n                    \"Excitation\": None,\n                    \"code\": channel_code,\n                }\n            )\n\n        self.metadata.update({\"channels\": channels, \"num_channels\": len(channels)})\n\n    def _get_image_info(self):\n        \"\"\"Get image-related metadata\"\"\"\n        well_info = self.metadata[\"well_info\"]\n        max_data_size = (\n            well_info[\"SensorSizeXPixels\"]\n            * well_info[\"SensorSizeYPixels\"]\n            * len(self.metadata[\"wells\"])\n            * well_info[\"num_sites\"]\n            * self.metadata[\"num_channels\"]\n            * len(self.metadata[\"time_points\"])\n            * (self.sample_image_info[\"bits\"] // 8)\n        )\n\n        self.metadata.update(\n            {\n                \"bits_per_pixel\": self.sample_image_info[\"bits\"],\n                \"dtype\": self.sample_image_info[\"dtype\"],\n                \"max_data_size\": max_data_size,\n            }\n        )\n\n    def _get_pixel_size_dict(self):\n        \"\"\"Get pixel size in TiffSource format\"\"\"\n        well_info = self.metadata.get(\"well_info\", {})\n        pixel_size = well_info.get(\"PixelSizeUm\", 1.0)\n        return {\"x\": pixel_size, \"y\": pixel_size}\n\n    def _format_channels_for_interface(self):\n        \"\"\"Format channels for interface compatibility\"\"\"\n        channels = self.metadata.get(\"channels\", [])\n        return [\n            {\"label\": channel[\"Dye\"], \"color\": hexrgb_to_rgba(channel[\"Color\"].lstrip(\"#\"))} for channel in channels\n        ]\n\n    def _load_image_data(self, well_id, field_id, channel_id, timepoint_id, level=0):\n        \"\"\"Load specific image data\"\"\"\n        cache_key = (well_id, field_id, channel_id, timepoint_id, level)\n        if cache_key in self._file_cache:\n            return self._file_cache[cache_key]\n\n        data = None\n\n        # Find the file for this combination\n        timepoint_info = self.metadata[\"timepoints\"][timepoint_id]\n        channel_code = self.metadata[\"channels_raw\"][channel_id]\n\n        filename = f\"{well_id}-{field_id + 1}-{channel_code}.tif\"\n        file_path = timepoint_info[\"path\"] / filename\n\n        message = \"\"\n        # Check if file exists\n        if not file_path.exists():\n            if self.fill_missing_images:\n                message = f\"Warning: Missing image file {file_path}, filled with black image\"\n            else:\n                raise FileNotFoundError(f\"Image file not found: {file_path}\")\n\n        try:\n            # Let TiffFile handle the file reading errors naturally\n            with tifffile.TiffFile(str(file_path)) as tif:\n                data = tif.asarray(level=level)\n        except Exception as e:\n            if self.fill_missing_images:\n                message = f\"Warning: Could not read image file {file_path}: {e}, filled with black image\"\n            else:\n                raise e\n\n        if data is None and self.fill_missing_images:\n            # Create a black image with the same dimensions as other images\n            data = np.zeros((self.sample_image_info[\"height\"], self.sample_image_info[\"width\"]),\n                            dtype=self.sample_image_info[\"dtype\"])\n            print(message)\n\n        if self._file_caching:\n            self._file_cache[cache_key] = data\n        return data\n\n    # ImageSource interface methods\n    def is_screen(self):\n        return self.is_plate\n\n    def get_data(self, dim_order, level=0, well_id=None, field_id=None, **kwargs):\n        \"\"\"Get data for a specific well and field\"\"\"\n        well_id = strip_leading_zeros(well_id)\n\n        if well_id not in self.metadata[\"wells\"]:\n            raise ValueError(\n                f\"Invalid Well: {well_id}. Available: {list(self.metadata['wells'].keys())}\"\n            )\n\n        field_id = int(field_id)\n        if field_id not in self.metadata[\"fields_raw\"]:\n            raise ValueError(\n                f\"Invalid Field: {field_id}. Available: {self.metadata['fields_raw']}\"\n            )\n\n        # Build 5D array: (t, c, z, y, x)\n        nt = len(self.metadata[\"time_points\"])\n        nc = self.metadata[\"num_channels\"]\n\n        data = np.zeros(self.shape, dtype=self.sample_image_info[\"dtype\"])\n\n        for t in range(nt):\n            for c in range(nc):\n                image_data = self._load_image_data(well_id, field_id, c, t, level=level)\n                # Handle different image shapes\n                if image_data.ndim &gt; 2:\n                    # assume data [z, y, x] - TODO: for 3D support _load_image_data() needs to handle z properly\n                    data[t, c, :, :, :] = image_data\n                else:\n                    data[t, c, 0, :, :] = image_data\n\n        return redimension_data(data, self.dim_order, dim_order)\n\n    def get_shape(self):\n        return self.shape\n\n    def get_scales(self):\n        return self.scales\n\n    def get_name(self):\n        return self.name\n\n    def get_dim_order(self):\n        return self.dim_order\n\n    def get_dtype(self):\n        return self.dtype\n\n    def get_pixel_size_um(self):\n        return self.pixel_size\n\n    def get_position_um(self, well_id=None):\n        well = self.metadata[\"wells\"].get(well_id, {})\n        well_info = self.metadata[\"well_info\"]\n        x = well.get(\"CoordX\", 0) * well_info.get(\"max_sizex_um\", 0)\n        y = well.get(\"CoordY\", 0) * well_info.get(\"max_sizey_um\", 0)\n        return {\"x\": x, \"y\": y}\n\n    def get_channels(self):\n        return self.channels\n\n    def get_nchannels(self):\n        return max(self.metadata.get(\"num_channels\", 1), 1)\n\n    def get_rows(self):\n        return self.rows\n\n    def get_columns(self):\n        return self.columns\n\n    def get_wells(self):\n        return self.wells\n\n    def get_time_points(self):\n        return self.metadata.get(\"time_points\", [])\n\n    def get_fields(self):\n        return self.metadata.get(\"well_info\", {}).get(\"fields\", [])\n\n    def get_well_coords_um(self, well_id):\n        \"\"\"Get well coordinates (placeholder - Incucyte doesn't typically have stage coordinates)\"\"\"\n        return {\"x\": 0.0, \"y\": 0.0}\n\n    def get_acquisitions(self):\n        \"\"\"Return acquisition information based on timepoints\"\"\"\n        acquisitions = []\n        for i, tp in enumerate(self.metadata.get(\"timepoints\", [])):\n            acq = {\n                \"id\": i,\n                \"name\": f\"Timepoint_{tp['timestamp']}\",\n                \"description\": f\"Incucyte acquisition at {tp['timestamp']}\",\n                \"date_created\": tp[\"datetime\"].isoformat()\n                if tp[\"datetime\"]\n                else tp[\"timestamp\"],\n                \"date_modified\": tp[\"datetime\"].isoformat()\n                if tp[\"datetime\"]\n                else tp[\"timestamp\"],\n            }\n            acquisitions.append(acq)\n        return acquisitions\n\n    def get_acquisition_datetime(self):\n        timepoints = self.metadata.get(\"timepoints\", [])\n        if timepoints and timepoints[0][\"datetime\"]:\n            return timepoints[0][\"datetime\"]\n        return None\n\n    def get_significant_bits(self):\n        return self.metadata.get(\"bits_per_pixel\")\n\n    def get_total_data_size(self):\n        return self.metadata.get(\"max_data_size\", 0)\n\n    def print_well_matrix(self):\n        \"\"\"Print a visual representation of the plate layout\"\"\"\n        s = \"\"\n        well_info = self.metadata.get(\"well_info\", {})\n        rows = well_info.get(\"rows\", [])\n        cols = [int(c) for c in well_info.get(\"columns\", [])]\n        used_wells = set(self.metadata.get(\"wells\", {}).keys())\n\n        # Header with column numbers\n        header = \"   \" + \"  \".join(f\"{col:2d}\" for col in cols)\n        s += header + \"\\n\"\n\n        # Each row\n        for row_letter in rows:\n            row_line = f\"{row_letter}  \"\n            for col_num in cols:\n                well_id = f\"{row_letter}{col_num}\"\n                row_line += \" + \" if well_id in used_wells else \"   \"\n            s += row_line + \"\\n\"\n\n        return s\n\n    def print_timepoint_well_matrix(self):\n        \"\"\"Print timepoint vs well matrix\"\"\"\n        s = \"\"\n        timepoints = self.metadata.get(\"timepoints\", [])\n        wells = list(self.metadata.get(\"wells\", {}).keys())\n\n        # Header\n        header = \"Timepoint   \" + \"  \".join(f\"{well:&gt;3}\" for well in wells)\n        s += header + \"\\n\"\n\n        # Check which wells have data at each timepoint\n        for tp in timepoints:\n            line = f\"{tp['timestamp']:&gt;9}   \"\n            for well in wells:\n                # Check if any files exist for this well at this timepoint\n                has_data = any(\n                    (tp[\"path\"] / f\"{well}-{field + 1}-{channel}.tif\").exists()\n                    for field in self.metadata.get(\"fields_raw\", [])\n                    for channel in self.metadata.get(\"channels_raw\", [])\n                )\n                line += \" + \" if has_data else \"   \"\n            s += line + \"\\n\"\n\n        return s\n\n    def is_rgb(self):\n        \"\"\"\n        Check if the source is a RGB(A) image.\n        Incucyte data stores channels separately, not as RGB.\n        \"\"\"\n        return False\n\n    def close(self):\n        \"\"\"Clean up resources\"\"\"\n        self._file_cache.clear()\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.DIAG_LOG_FILENAME","title":"<code>DIAG_LOG_FILENAME = 'Diag.log'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/#src.IncucyteSource.IncucyteSource.DIAG_ZIP_FILENAME","title":"<code>DIAG_ZIP_FILENAME = 'Diag.zip'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/#src.IncucyteSource.IncucyteSource.base_path","title":"<code>base_path = Path(self.uri)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.IncucyteSource.IncucyteSource.fill_missing_images","title":"<code>fill_missing_images = True</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.IncucyteSource.IncucyteSource.plate_id","title":"<code>plate_id = plate_id</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.IncucyteSource.IncucyteSource.scan_data_path","title":"<code>scan_data_path = self.base_path / 'EssenFiles' / 'ScanData'</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.IncucyteSource.IncucyteSource.__init__","title":"<code>__init__(uri, metadata={}, plate_id=None)</code>","text":"<p>Initialize IncucyteSource.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>Path to the Incucyte archive folder</p> required <code>metadata</code> <code>dict</code> <p>Optional metadata dictionary</p> <code>{}</code> <code>plate_id</code> <code>str</code> <p>Specific plate ID to process (e.g., '700', '701').                      If None, will use the first available plate or all                       if only one exists.</p> <code>None</code> Source code in <code>src/IncucyteSource.py</code> <pre><code>def __init__(self, uri, metadata={}, plate_id=None):\n    \"\"\"\n    Initialize IncucyteSource.\n\n    Args:\n        uri (str): Path to the Incucyte archive folder\n        metadata (dict): Optional metadata dictionary\n        plate_id (str, optional): Specific plate ID to process (e.g., '700', '701').\n                                 If None, will use the first available plate or all \n                                 if only one exists.\n    \"\"\"\n    super().__init__(uri, metadata)\n    self.plate_id = plate_id\n    self.base_path = Path(self.uri)\n    self.scan_data_path = self.base_path / \"EssenFiles\" / \"ScanData\"\n    self._file_cache = {}\n    self._file_caching = False\n    # Default to True for filling missing images\n    self.fill_missing_images = True\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.close","title":"<code>close()</code>","text":"<p>Clean up resources</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>def close(self):\n    \"\"\"Clean up resources\"\"\"\n    self._file_cache.clear()\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.enable_file_caching","title":"<code>enable_file_caching(file_caching=True)</code>","text":"<p>Enable or disable file caching for image data.</p> <p>Parameters:</p> Name Type Description Default <code>file_caching</code> <code>bool</code> <p>If True, enable file caching; if False, disable it.</p> <code>True</code> Source code in <code>src/IncucyteSource.py</code> <pre><code>def enable_file_caching(self, file_caching=True):\n    \"\"\"\n    Enable or disable file caching for image data.\n\n    Args:\n        file_caching (bool): If True, enable file caching; if False, disable it.\n    \"\"\"\n    self._file_caching = file_caching\n    if not file_caching:\n        self._file_cache.clear()\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_acquisition_datetime","title":"<code>get_acquisition_datetime()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_acquisition_datetime(self):\n    timepoints = self.metadata.get(\"timepoints\", [])\n    if timepoints and timepoints[0][\"datetime\"]:\n        return timepoints[0][\"datetime\"]\n    return None\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_acquisitions","title":"<code>get_acquisitions()</code>","text":"<p>Return acquisition information based on timepoints</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_acquisitions(self):\n    \"\"\"Return acquisition information based on timepoints\"\"\"\n    acquisitions = []\n    for i, tp in enumerate(self.metadata.get(\"timepoints\", [])):\n        acq = {\n            \"id\": i,\n            \"name\": f\"Timepoint_{tp['timestamp']}\",\n            \"description\": f\"Incucyte acquisition at {tp['timestamp']}\",\n            \"date_created\": tp[\"datetime\"].isoformat()\n            if tp[\"datetime\"]\n            else tp[\"timestamp\"],\n            \"date_modified\": tp[\"datetime\"].isoformat()\n            if tp[\"datetime\"]\n            else tp[\"timestamp\"],\n        }\n        acquisitions.append(acq)\n    return acquisitions\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_available_plates","title":"<code>get_available_plates(uri)</code>  <code>staticmethod</code>","text":"<p>Discover all available plate IDs in an Incucyte archive.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>Path to the Incucyte archive folder</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of plate IDs (strings) found in the archive</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>@staticmethod\ndef get_available_plates(uri):\n    \"\"\"\n    Discover all available plate IDs in an Incucyte archive.\n\n    Args:\n        uri (str): Path to the Incucyte archive folder\n\n    Returns:\n        list: List of plate IDs (strings) found in the archive\n    \"\"\"\n    base_path = Path(uri)\n    scan_data_path = base_path / \"EssenFiles\" / \"ScanData\"\n\n    if not scan_data_path.exists():\n        raise ValueError(f\"Scan data path not found: {scan_data_path}\")\n\n    plate_ids = set()\n\n    # Navigate through the directory structure to find all plate IDs\n    for year_month in scan_data_path.iterdir():\n        if not year_month.is_dir():\n            continue\n        for day in year_month.iterdir():\n            if not day.is_dir():\n                continue\n            for time_dir in day.iterdir():\n                if not time_dir.is_dir():\n                    continue\n                for plate_dir in time_dir.iterdir():\n                    if plate_dir.is_dir():\n                        plate_ids.add(plate_dir.name)\n\n    return sorted(list(plate_ids))\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_channels","title":"<code>get_channels()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_channels(self):\n    return self.channels\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_columns","title":"<code>get_columns()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_columns(self):\n    return self.columns\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_data","title":"<code>get_data(dim_order, level=0, well_id=None, field_id=None, **kwargs)</code>","text":"<p>Get data for a specific well and field</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_data(self, dim_order, level=0, well_id=None, field_id=None, **kwargs):\n    \"\"\"Get data for a specific well and field\"\"\"\n    well_id = strip_leading_zeros(well_id)\n\n    if well_id not in self.metadata[\"wells\"]:\n        raise ValueError(\n            f\"Invalid Well: {well_id}. Available: {list(self.metadata['wells'].keys())}\"\n        )\n\n    field_id = int(field_id)\n    if field_id not in self.metadata[\"fields_raw\"]:\n        raise ValueError(\n            f\"Invalid Field: {field_id}. Available: {self.metadata['fields_raw']}\"\n        )\n\n    # Build 5D array: (t, c, z, y, x)\n    nt = len(self.metadata[\"time_points\"])\n    nc = self.metadata[\"num_channels\"]\n\n    data = np.zeros(self.shape, dtype=self.sample_image_info[\"dtype\"])\n\n    for t in range(nt):\n        for c in range(nc):\n            image_data = self._load_image_data(well_id, field_id, c, t, level=level)\n            # Handle different image shapes\n            if image_data.ndim &gt; 2:\n                # assume data [z, y, x] - TODO: for 3D support _load_image_data() needs to handle z properly\n                data[t, c, :, :, :] = image_data\n            else:\n                data[t, c, 0, :, :] = image_data\n\n    return redimension_data(data, self.dim_order, dim_order)\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_dim_order(self):\n    return self.dim_order\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_dtype","title":"<code>get_dtype()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_dtype(self):\n    return self.dtype\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_fields","title":"<code>get_fields()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_fields(self):\n    return self.metadata.get(\"well_info\", {}).get(\"fields\", [])\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_name","title":"<code>get_name()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_name(self):\n    return self.name\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_nchannels(self):\n    return max(self.metadata.get(\"num_channels\", 1), 1)\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_pixel_size_um(self):\n    return self.pixel_size\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_position_um","title":"<code>get_position_um(well_id=None)</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_position_um(self, well_id=None):\n    well = self.metadata[\"wells\"].get(well_id, {})\n    well_info = self.metadata[\"well_info\"]\n    x = well.get(\"CoordX\", 0) * well_info.get(\"max_sizex_um\", 0)\n    y = well.get(\"CoordY\", 0) * well_info.get(\"max_sizey_um\", 0)\n    return {\"x\": x, \"y\": y}\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_rows","title":"<code>get_rows()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_rows(self):\n    return self.rows\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_scales","title":"<code>get_scales()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_scales(self):\n    return self.scales\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_shape","title":"<code>get_shape()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_shape(self):\n    return self.shape\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_significant_bits","title":"<code>get_significant_bits()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_significant_bits(self):\n    return self.metadata.get(\"bits_per_pixel\")\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_time_points","title":"<code>get_time_points()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_time_points(self):\n    return self.metadata.get(\"time_points\", [])\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_total_data_size","title":"<code>get_total_data_size()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_total_data_size(self):\n    return self.metadata.get(\"max_data_size\", 0)\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_well_coords_um","title":"<code>get_well_coords_um(well_id)</code>","text":"<p>Get well coordinates (placeholder - Incucyte doesn't typically have stage coordinates)</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_well_coords_um(self, well_id):\n    \"\"\"Get well coordinates (placeholder - Incucyte doesn't typically have stage coordinates)\"\"\"\n    return {\"x\": 0.0, \"y\": 0.0}\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.get_wells","title":"<code>get_wells()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def get_wells(self):\n    return self.wells\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.init_metadata","title":"<code>init_metadata()</code>","text":"<p>Initialize all metadata from Incucyte structure</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>def init_metadata(self):\n    \"\"\"Initialize all metadata from Incucyte structure\"\"\"\n    self._scan_timepoints()  # Must be first to set plate_id\n    self._get_experiment_metadata()  # Uses plate_id in name\n    self._get_sample_image_info()\n    self._get_well_info()\n    self._get_channel_info()\n    self._get_image_info()\n\n    # Initialize properties like TiffSource does\n    self.name = self.metadata.get(\"Name\", \"Incucyte_Experiment\")\n    self.dim_order = self.metadata.get(\"dim_order\", \"tczyx\")\n    self.dtype = self.metadata.get(\"dtype\", np.uint16)\n    self.pixel_size = self._get_pixel_size_dict()\n    self.channels = self._format_channels_for_interface()\n    self.is_plate = len(self.metadata.get(\"wells\", {})) &gt; 0\n    self.wells = list(self.metadata.get(\"wells\", {}).keys())\n    self.rows = self.metadata.get(\"well_info\", {}).get(\"rows\", [])\n    self.columns = self.metadata.get(\"well_info\", {}).get(\"columns\", [])\n\n    nt = len(self.metadata[\"time_points\"])\n    nc = self.metadata[\"num_channels\"]\n    nz = 1  # Incucyte is typically 2D\n    self.shape = nt, nc, nz, self.height, self.width\n    self.shapes = [(nt, nc, nz, height, width) for height, width in zip(self.heights, self.widths)]\n    self.scales = [np.mean([width / self.width, height / self.height]) for width, height in zip(self.widths, self.heights)]\n\n    return self.metadata\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.is_rgb","title":"<code>is_rgb()</code>","text":"<p>Check if the source is a RGB(A) image. Incucyte data stores channels separately, not as RGB.</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>def is_rgb(self):\n    \"\"\"\n    Check if the source is a RGB(A) image.\n    Incucyte data stores channels separately, not as RGB.\n    \"\"\"\n    return False\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.is_screen","title":"<code>is_screen()</code>","text":"Source code in <code>src/IncucyteSource.py</code> <pre><code>def is_screen(self):\n    return self.is_plate\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.print_timepoint_well_matrix","title":"<code>print_timepoint_well_matrix()</code>","text":"<p>Print timepoint vs well matrix</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>def print_timepoint_well_matrix(self):\n    \"\"\"Print timepoint vs well matrix\"\"\"\n    s = \"\"\n    timepoints = self.metadata.get(\"timepoints\", [])\n    wells = list(self.metadata.get(\"wells\", {}).keys())\n\n    # Header\n    header = \"Timepoint   \" + \"  \".join(f\"{well:&gt;3}\" for well in wells)\n    s += header + \"\\n\"\n\n    # Check which wells have data at each timepoint\n    for tp in timepoints:\n        line = f\"{tp['timestamp']:&gt;9}   \"\n        for well in wells:\n            # Check if any files exist for this well at this timepoint\n            has_data = any(\n                (tp[\"path\"] / f\"{well}-{field + 1}-{channel}.tif\").exists()\n                for field in self.metadata.get(\"fields_raw\", [])\n                for channel in self.metadata.get(\"channels_raw\", [])\n            )\n            line += \" + \" if has_data else \"   \"\n        s += line + \"\\n\"\n\n    return s\n</code></pre>"},{"location":"references/#src.IncucyteSource.IncucyteSource.print_well_matrix","title":"<code>print_well_matrix()</code>","text":"<p>Print a visual representation of the plate layout</p> Source code in <code>src/IncucyteSource.py</code> <pre><code>def print_well_matrix(self):\n    \"\"\"Print a visual representation of the plate layout\"\"\"\n    s = \"\"\n    well_info = self.metadata.get(\"well_info\", {})\n    rows = well_info.get(\"rows\", [])\n    cols = [int(c) for c in well_info.get(\"columns\", [])]\n    used_wells = set(self.metadata.get(\"wells\", {}).keys())\n\n    # Header with column numbers\n    header = \"   \" + \"  \".join(f\"{col:2d}\" for col in cols)\n    s += header + \"\\n\"\n\n    # Each row\n    for row_letter in rows:\n        row_line = f\"{row_letter}  \"\n        for col_num in cols:\n            well_id = f\"{row_letter}{col_num}\"\n            row_line += \" + \" if well_id in used_wells else \"   \"\n        s += row_line + \"\\n\"\n\n    return s\n</code></pre>"},{"location":"references/#src.MiraxSource","title":"<code>MiraxSource</code>","text":""},{"location":"references/#src.MiraxSource.PYRAMID_DOWNSCALE","title":"<code>PYRAMID_DOWNSCALE = 2</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.MiraxSource.PYRAMID_LEVELS","title":"<code>PYRAMID_LEVELS = 6</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.MiraxSource.RETRY_ATTEMPTS","title":"<code>RETRY_ATTEMPTS = 3</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.MiraxSource.TIFF_COMPRESSION","title":"<code>TIFF_COMPRESSION = 'LZW'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.MiraxSource.TILE_SIZE","title":"<code>TILE_SIZE = 1024</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.MiraxSource.VERSION","title":"<code>VERSION = 'v0.1.18'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.MiraxSource.ZARR_CHUNK_SIZE","title":"<code>ZARR_CHUNK_SIZE = TILE_SIZE</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.MiraxSource.ZARR_SHARD_MULTIPLIER","title":"<code>ZARR_SHARD_MULTIPLIER = 10</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.MiraxSource.MiraxSource","title":"<code>MiraxSource</code>","text":"<p>               Bases: <code>ImageSource</code></p> <p>ImageSource subclass for reading Mirax files using OpenSlide.</p> Source code in <code>src/MiraxSource.py</code> <pre><code>class MiraxSource(ImageSource):\n    \"\"\"\n    ImageSource subclass for reading Mirax files using OpenSlide.\n    \"\"\"\n\n    def __init__(self, uri, metadata={}):\n        super().__init__(uri, metadata)\n        self.slide = openslide.open_slide(uri)\n\n    def init_metadata(self):\n        self.metadata = {key.lower(): value for key, value in dict(self.slide.properties).items()}\n\n        self.dimensions = self.slide.level_dimensions\n        self.widths = [width for width, height in self.slide.level_dimensions]\n        self.heights = [height for width, height in self.slide.level_dimensions]\n        self.level_downsamples = self.slide.level_downsamples\n        self.scales = [1 / downsample for downsample in self.level_downsamples]\n        self.nchannels = 3      # Mirax is RGBA; convert to RGB\n        self.shapes = [(height, width, self.nchannels) for (width, height) in self.dimensions]\n        self.shape = self.shapes[0]\n        self.dim_order = 'yxc'\n        self.is_rgb_channels = True\n\n        name = None\n        nbits = 8\n        acquisition_datetime = None\n        for key, value in self.metadata.items():\n            if 'slide_name' in key:\n                name = value\n            if 'slide_bitdepth' in key:\n                nbits = int(value)\n            if 'slide_creationdatetime' in key:\n                acquisition_datetime = datetime.strptime(value,'%d/%m/%Y %H:%M:%S')\n        self.dtype = get_bits_type(nbits)\n\n        # OpenSlide stores microns per pixel in properties\n        mpp_x = float(self.metadata.get(openslide.PROPERTY_NAME_MPP_X, 1))\n        mpp_y = float(self.metadata.get(openslide.PROPERTY_NAME_MPP_Y, 1))\n        self.pixel_size = {'x': mpp_x, 'y': mpp_y}\n        background_float = hexrgb_to_rgba(self.metadata.get(openslide.PROPERTY_NAME_BACKGROUND_COLOR, '000000'))[:3]\n        self.background = [np.uint8(value * 255) for value in background_float]\n\n        if not name:\n            name = get_filetitle(self.uri)\n        self.name = name\n        self.acquisition_datetime = acquisition_datetime\n        self.bits_per_pixel = nbits\n        return self.metadata\n\n    def is_screen(self):\n        # Mirax files are not multi-well screens\n        return False\n\n    def get_shape(self):\n        return self.shape\n\n    def get_shapes(self):\n        return self.shapes\n\n    def get_scales(self):\n        return self.scales\n\n    # TODO: check (x/y) source data is read in order first to last (currently last to first) using dask, or use generator/stream to dask?\n    # read_tile_array(50000, 180000, 1000, 1000, 0)\n\n    def read_array(self, x, y, width, height, level=0):\n        # OpenSlide uses (x, y) coordinates in level 0 reference size\n        x0 = int(x * self.level_downsamples[level])\n        y0 = int(y * self.level_downsamples[level])\n        #return np.array(self.slide.read_region((x0, y0), level, (width, height)).convert('RGB'))   # discard alpha\n        rgba = np.array(self.slide.read_region((x0, y0), level, (width, height)))\n        alpha = np.atleast_3d(rgba[..., 3] / np.float32(255))\n        rgb = (rgba[..., :3] * alpha + self.background * (1 - alpha)).astype(np.uint8)\n        return rgb\n\n    def get_data(self, dim_order, level=0, well_id=None, field_id=None, **kwargs):\n        data = self.read_array(0, 0, self.widths[level], self.heights[level], level=level)\n        return redimension_data(data, self.dim_order, dim_order)\n\n    def get_data_as_dask(self, dim_order, level=0, **kwargs):\n        dask.config.set(scheduler='single-threaded')\n\n        def get_lazy_tile(x, y, width, height, level=0):\n            lazy_array = dask.delayed(self.read_array)(x, y, width, height, level)\n            return da.from_delayed(lazy_array, shape=(height, width, self.nchannels), dtype=self.dtype)\n\n        y_chunks, x_chunks = da.core.normalize_chunks(TILE_SIZE, self.shapes[level][:2], dtype=self.dtype)\n        y_pos = np.cumsum([0] + list(y_chunks)[:-1])\n        x_pos = np.cumsum([0] + list(x_chunks)[:-1])\n        data = da.concatenate(\n            [da.concatenate(\n                [get_lazy_tile(x, y, width, height, level=level)\n                 for x, width in zip(x_pos, x_chunks)], axis=1)\n             for y, height in zip(y_pos, y_chunks)], axis=0)\n        return redimension_data(data, self.dim_order, dim_order)\n\n    def get_data_as_generator(self, dim_order, **kwargs):\n        def data_generator(scale=1):\n            level, rescale = get_level_from_scale(self.scales, scale)\n            read_size = int(TILE_SIZE / rescale)\n            for y in range(0, self.heights[level], read_size):\n                for x in range(0, self.widths[level], read_size):\n                    data = self.read_array(x, y, read_size, read_size, level)\n                    if rescale != 1:\n                        shape = np.multiply(data.shape[:2], rescale).astype(int)\n                        data = sk_transform.resize(data, shape, preserve_range=True).astype(data.dtype)\n                    yield redimension_data(data, self.dim_order, dim_order)\n        return data_generator\n\n    def get_name(self):\n        return self.name\n\n    def get_dim_order(self):\n        return self.dim_order\n\n    def get_dtype(self):\n        return self.dtype\n\n    def get_pixel_size_um(self):\n        return self.pixel_size\n\n    def get_position_um(self, well_id=None):\n        # Not applicable for Mirax\n        return {'x': 0, 'y': 0}\n\n    def get_channels(self):\n        # Mirax is RGB, return NGFF-style channel metadata\n        return [\n            {\"name\": \"Red\", \"color\": [1, 0, 0, 1]},\n            {\"name\": \"Green\", \"color\": [0, 1, 0, 1]},\n            {\"name\": \"Blue\", \"color\": [0, 0, 1, 1]},\n            #{\"name\": \"Alpha\", \"color\": [1, 1, 1, 1]}\n        ]\n\n    def get_nchannels(self):\n        return self.nchannels\n\n    def is_rgb(self):\n        return True\n\n    def get_rows(self):\n        return []\n\n    def get_columns(self):\n        return []\n\n    def get_wells(self):\n        return []\n\n    def get_time_points(self):\n        return []\n\n    def get_fields(self):\n        return []\n\n    def get_acquisitions(self):\n        return []\n\n    def get_acquisition_datetime(self):\n        return self.acquisition_datetime\n\n    def get_significant_bits(self):\n        return self.bits_per_pixel\n\n    def close(self):\n        self.slide.close()\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.slide","title":"<code>slide = openslide.open_slide(uri)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.MiraxSource.MiraxSource.__init__","title":"<code>__init__(uri, metadata={})</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def __init__(self, uri, metadata={}):\n    super().__init__(uri, metadata)\n    self.slide = openslide.open_slide(uri)\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.close","title":"<code>close()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def close(self):\n    self.slide.close()\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_acquisition_datetime","title":"<code>get_acquisition_datetime()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_acquisition_datetime(self):\n    return self.acquisition_datetime\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_acquisitions","title":"<code>get_acquisitions()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_acquisitions(self):\n    return []\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_channels","title":"<code>get_channels()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_channels(self):\n    # Mirax is RGB, return NGFF-style channel metadata\n    return [\n        {\"name\": \"Red\", \"color\": [1, 0, 0, 1]},\n        {\"name\": \"Green\", \"color\": [0, 1, 0, 1]},\n        {\"name\": \"Blue\", \"color\": [0, 0, 1, 1]},\n        #{\"name\": \"Alpha\", \"color\": [1, 1, 1, 1]}\n    ]\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_columns","title":"<code>get_columns()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_columns(self):\n    return []\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_data","title":"<code>get_data(dim_order, level=0, well_id=None, field_id=None, **kwargs)</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_data(self, dim_order, level=0, well_id=None, field_id=None, **kwargs):\n    data = self.read_array(0, 0, self.widths[level], self.heights[level], level=level)\n    return redimension_data(data, self.dim_order, dim_order)\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_data_as_dask","title":"<code>get_data_as_dask(dim_order, level=0, **kwargs)</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_data_as_dask(self, dim_order, level=0, **kwargs):\n    dask.config.set(scheduler='single-threaded')\n\n    def get_lazy_tile(x, y, width, height, level=0):\n        lazy_array = dask.delayed(self.read_array)(x, y, width, height, level)\n        return da.from_delayed(lazy_array, shape=(height, width, self.nchannels), dtype=self.dtype)\n\n    y_chunks, x_chunks = da.core.normalize_chunks(TILE_SIZE, self.shapes[level][:2], dtype=self.dtype)\n    y_pos = np.cumsum([0] + list(y_chunks)[:-1])\n    x_pos = np.cumsum([0] + list(x_chunks)[:-1])\n    data = da.concatenate(\n        [da.concatenate(\n            [get_lazy_tile(x, y, width, height, level=level)\n             for x, width in zip(x_pos, x_chunks)], axis=1)\n         for y, height in zip(y_pos, y_chunks)], axis=0)\n    return redimension_data(data, self.dim_order, dim_order)\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_data_as_generator","title":"<code>get_data_as_generator(dim_order, **kwargs)</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_data_as_generator(self, dim_order, **kwargs):\n    def data_generator(scale=1):\n        level, rescale = get_level_from_scale(self.scales, scale)\n        read_size = int(TILE_SIZE / rescale)\n        for y in range(0, self.heights[level], read_size):\n            for x in range(0, self.widths[level], read_size):\n                data = self.read_array(x, y, read_size, read_size, level)\n                if rescale != 1:\n                    shape = np.multiply(data.shape[:2], rescale).astype(int)\n                    data = sk_transform.resize(data, shape, preserve_range=True).astype(data.dtype)\n                yield redimension_data(data, self.dim_order, dim_order)\n    return data_generator\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_dim_order(self):\n    return self.dim_order\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_dtype","title":"<code>get_dtype()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_dtype(self):\n    return self.dtype\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_fields","title":"<code>get_fields()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_fields(self):\n    return []\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_name","title":"<code>get_name()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_name(self):\n    return self.name\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_nchannels(self):\n    return self.nchannels\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_pixel_size_um(self):\n    return self.pixel_size\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_position_um","title":"<code>get_position_um(well_id=None)</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_position_um(self, well_id=None):\n    # Not applicable for Mirax\n    return {'x': 0, 'y': 0}\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_rows","title":"<code>get_rows()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_rows(self):\n    return []\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_scales","title":"<code>get_scales()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_scales(self):\n    return self.scales\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_shape","title":"<code>get_shape()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_shape(self):\n    return self.shape\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_shapes","title":"<code>get_shapes()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_shapes(self):\n    return self.shapes\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_significant_bits","title":"<code>get_significant_bits()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_significant_bits(self):\n    return self.bits_per_pixel\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_time_points","title":"<code>get_time_points()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_time_points(self):\n    return []\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.get_wells","title":"<code>get_wells()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def get_wells(self):\n    return []\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.init_metadata","title":"<code>init_metadata()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def init_metadata(self):\n    self.metadata = {key.lower(): value for key, value in dict(self.slide.properties).items()}\n\n    self.dimensions = self.slide.level_dimensions\n    self.widths = [width for width, height in self.slide.level_dimensions]\n    self.heights = [height for width, height in self.slide.level_dimensions]\n    self.level_downsamples = self.slide.level_downsamples\n    self.scales = [1 / downsample for downsample in self.level_downsamples]\n    self.nchannels = 3      # Mirax is RGBA; convert to RGB\n    self.shapes = [(height, width, self.nchannels) for (width, height) in self.dimensions]\n    self.shape = self.shapes[0]\n    self.dim_order = 'yxc'\n    self.is_rgb_channels = True\n\n    name = None\n    nbits = 8\n    acquisition_datetime = None\n    for key, value in self.metadata.items():\n        if 'slide_name' in key:\n            name = value\n        if 'slide_bitdepth' in key:\n            nbits = int(value)\n        if 'slide_creationdatetime' in key:\n            acquisition_datetime = datetime.strptime(value,'%d/%m/%Y %H:%M:%S')\n    self.dtype = get_bits_type(nbits)\n\n    # OpenSlide stores microns per pixel in properties\n    mpp_x = float(self.metadata.get(openslide.PROPERTY_NAME_MPP_X, 1))\n    mpp_y = float(self.metadata.get(openslide.PROPERTY_NAME_MPP_Y, 1))\n    self.pixel_size = {'x': mpp_x, 'y': mpp_y}\n    background_float = hexrgb_to_rgba(self.metadata.get(openslide.PROPERTY_NAME_BACKGROUND_COLOR, '000000'))[:3]\n    self.background = [np.uint8(value * 255) for value in background_float]\n\n    if not name:\n        name = get_filetitle(self.uri)\n    self.name = name\n    self.acquisition_datetime = acquisition_datetime\n    self.bits_per_pixel = nbits\n    return self.metadata\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.is_rgb","title":"<code>is_rgb()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def is_rgb(self):\n    return True\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.is_screen","title":"<code>is_screen()</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def is_screen(self):\n    # Mirax files are not multi-well screens\n    return False\n</code></pre>"},{"location":"references/#src.MiraxSource.MiraxSource.read_array","title":"<code>read_array(x, y, width, height, level=0)</code>","text":"Source code in <code>src/MiraxSource.py</code> <pre><code>def read_array(self, x, y, width, height, level=0):\n    # OpenSlide uses (x, y) coordinates in level 0 reference size\n    x0 = int(x * self.level_downsamples[level])\n    y0 = int(y * self.level_downsamples[level])\n    #return np.array(self.slide.read_region((x0, y0), level, (width, height)).convert('RGB'))   # discard alpha\n    rgba = np.array(self.slide.read_region((x0, y0), level, (width, height)))\n    alpha = np.atleast_3d(rgba[..., 3] / np.float32(255))\n    rgb = (rgba[..., :3] * alpha + self.background * (1 - alpha)).astype(np.uint8)\n    return rgb\n</code></pre>"},{"location":"references/#src.OmeTiffWriter","title":"<code>OmeTiffWriter</code>","text":""},{"location":"references/#src.OmeTiffWriter.PYRAMID_DOWNSCALE","title":"<code>PYRAMID_DOWNSCALE = 2</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.PYRAMID_LEVELS","title":"<code>PYRAMID_LEVELS = 6</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.RETRY_ATTEMPTS","title":"<code>RETRY_ATTEMPTS = 3</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.TIFF_COMPRESSION","title":"<code>TIFF_COMPRESSION = 'LZW'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.TILE_SIZE","title":"<code>TILE_SIZE = 1024</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.VERSION","title":"<code>VERSION = 'v0.1.18'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.ZARR_CHUNK_SIZE","title":"<code>ZARR_CHUNK_SIZE = TILE_SIZE</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.ZARR_SHARD_MULTIPLIER","title":"<code>ZARR_SHARD_MULTIPLIER = 10</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.OmeTiffWriter","title":"<code>OmeTiffWriter</code>","text":"<p>               Bases: <code>OmeWriter</code></p> <p>Writes image data and metadata to OME-TIFF files.</p> Source code in <code>src/OmeTiffWriter.py</code> <pre><code>class OmeTiffWriter(OmeWriter):\n    \"\"\"\n    Writes image data and metadata to OME-TIFF files.\n    \"\"\"\n    def __init__(self, verbose=False):\n        \"\"\"\n        Initialize OmeTiffWriter.\n\n        Args:\n            verbose (bool): If True, prints progress info.\n        \"\"\"\n        super().__init__()\n        self.verbose = verbose\n\n    def write(self, filepath, source, **kwargs):\n        \"\"\"\n        Writes image or screen data to OME-TIFF files.\n\n        Args:\n            filepath (str): Output file path.\n            source (ImageSource): Source object.\n            **kwargs: Additional options (e.g. wells selection).\n\n        Returns:\n            dict: Containing output_path: str or list Output file path(s) and data window.\n        \"\"\"\n\n        dim_order = ''\n        source_dim_order = source.get_dim_order()\n        if source.get_time_points():\n            dim_order += 't'\n        if 'c' in source_dim_order and not source.is_rgb():\n            dim_order += 'c'\n        if 'z' in source_dim_order:\n            dim_order += 'z'\n        dim_order += 'yx'\n        if 'c' in source_dim_order and source.is_rgb():\n            dim_order += 'c'\n        self.dim_order = dim_order\n\n        if source.is_screen():\n            filepath, total_size, window = self._write_screen(filepath, source, **kwargs)\n        else:\n            filepath, total_size, window = self._write_image(filepath, source, **kwargs)\n\n        if self.verbose:\n            print(f'Total data written: {print_hbytes(total_size)}')\n\n        return {'output_path': filepath, 'window': window}\n\n    def _write_screen(self, filename, source, **kwargs):\n        \"\"\"\n        Writes multi-well screen data to separate TIFF files and companion metadata.\n\n        Args:\n            filename (str): Output file name.\n            source (ImageSource): Source object.\n            **kwargs: Additional options (e.g. wells selection).\n\n        Returns:\n            tuple: (List of output paths, total data size, image window)\n        \"\"\"\n        # writes separate tiff files for each field, and separate metadata companion file\n        window = []\n        output_paths = []\n        filepath, filename = os.path.split(filename)\n        filetitle = os.path.splitext(filename)[0].rstrip('.ome')\n\n        companion_filename = os.path.join(filepath, filetitle + '.companion.ome')\n        companion_uuid = create_uuid()\n\n        wells = kwargs.get('wells', source.get_wells())\n        fields = list(map(str, source.get_fields()))\n\n        total_size = 0\n        image_uuids = []\n        image_filenames = []\n        for well_id in wells:\n            for field_id in fields:\n                resolution, resolution_unit = create_resolution_metadata(source)\n                data = source.get_data(self.dim_order, well_id=well_id, field_id=field_id)\n\n                filename = f'{filetitle}'\n                filename += f'_{pad_leading_zero(well_id)}'\n                if field_id is not None:\n                    filename += f'_{pad_leading_zero(field_id)}'\n                filename = os.path.join(filepath, filename + '.ome.tiff')\n                xml_metadata, image_uuid = create_binaryonly_metadata(os.path.basename(companion_filename), companion_uuid)\n\n                size, window = self._write_tiff(filename, source, data,\n                                                resolution=resolution, resolution_unit=resolution_unit,\n                                                tile_size=TILE_SIZE, compression=TIFF_COMPRESSION,\n                                                xml_metadata=xml_metadata,\n                                                pyramid_levels=PYRAMID_LEVELS, pyramid_downscale=PYRAMID_DOWNSCALE,\n                                                well_id=well_id, field_id=field_id, **kwargs)\n\n                image_uuids.append(image_uuid)\n                image_filenames.append(os.path.basename(filename))\n                output_paths.append(filename)\n                total_size += size\n\n        xml_metadata = create_metadata(source,\n                                       uuid=companion_uuid, image_uuids=image_uuids, image_filenames=image_filenames,\n                                       wells=wells)\n        with open(companion_filename, 'wb') as file:\n            file.write(xml_metadata.encode())\n\n        output_paths = [companion_filename] + output_paths\n\n        return output_paths, total_size, window\n\n    def _write_image(self, filename, source, **kwargs):\n        \"\"\"\n        Writes single image data to a TIFF file.\n\n        Args:\n            filename (str): Output file name.\n            source (ImageSource): Source object.\n            **kwargs: Additional options.\n\n        Returns:\n            tuple: (Output path, data size)\n        \"\"\"\n        xml_metadata = create_metadata(source, image_filenames=[filename])\n        resolution, resolution_unit = create_resolution_metadata(source)\n        data = source.get_data_as_generator(self.dim_order)\n\n        size, window = self._write_tiff(filename, source, data,\n                                        resolution=resolution, resolution_unit=resolution_unit,\n                                        tile_size=TILE_SIZE, compression=TIFF_COMPRESSION,\n                                        xml_metadata=xml_metadata,\n                                        pyramid_levels=PYRAMID_LEVELS, pyramid_downscale=PYRAMID_DOWNSCALE,\n                                        **kwargs)\n\n        return filename, size, window\n\n    def _write_tiff(self, filename, source, data,\n                    resolution=None, resolution_unit=None, tile_size=None, compression=None, compressionargs=None,\n                    xml_metadata=None, pyramid_levels=0, pyramid_downscale=2, well_id=None, field_id=None, **kwargs):\n        \"\"\"\n        Writes image data to a TIFF file with optional pyramids and metadata.\n\n        Args:\n            filename (str): Output file name.\n            source (ImageSource): Source object.\n            data (ndarray or generator): Image data.\n            resolution (tuple, optional): Pixel resolution.\n            resolution_unit (str, optional): Resolution unit.\n            tile_size (int or tuple, optional): Tile size.\n            compression (str, optional): Compression type.\n            xml_metadata (str, optional): OME-XML metadata.\n            pyramid_levels (int): Number of pyramid levels.\n            pyramid_downscale (int): Pyramid downscale factor.\n\n        Returns:\n            int: Data size in bytes.\n        \"\"\"\n        is_generator = inspect.isgeneratorfunction(data)\n        if is_generator:\n            data_generator = data\n            shape = list(source.shape)\n            dtype = source.get_dtype()\n        else:\n            shape = list(data.shape)\n            dtype = data.dtype\n\n        x_index = self.dim_order.index('x')\n        y_index = self.dim_order.index('y')\n        if tile_size is not None:\n            if isinstance(tile_size, int):\n                tile_size = [tile_size] * 2\n            if tile_size[0] &gt; shape[y_index] or tile_size[1] &gt; shape[x_index]:\n                tile_size = None\n\n        if xml_metadata is not None:\n            # set ome=False to provide custom OME xml in description\n            xml_metadata_bytes = xml_metadata.encode()\n            is_ome = False\n        else:\n            xml_metadata_bytes = None\n            is_ome = True\n\n        # maximum size (w/o compression)\n        if is_generator:\n            data_size = np.prod(shape) * dtype.itemsize\n        else:\n            data_size = data.size * data.itemsize\n        max_size = 0\n        scale = 1\n        for level in range(1 + pyramid_levels):\n            max_size += data_size * scale ** 2\n            scale /= pyramid_downscale\n        is_bigtiff = (max_size &gt; 2 ** 32)\n\n        window_scanner = WindowScanner()\n        with TiffWriter(filename, bigtiff=is_bigtiff, ome=is_ome) as writer:\n            for level in range(pyramid_levels + 1):\n                if level == 0:\n                    scale = 1\n                    subifds = pyramid_levels\n                    subfiletype = None\n                    new_shape = shape\n                else:\n                    scale /= pyramid_downscale\n                    new_shape = list(shape)\n                    new_shape[x_index] = int(shape[x_index] * scale)\n                    new_shape[y_index] = int(shape[y_index] * scale)\n                    if not is_generator:\n                        data = resize(data, new_shape, preserve_range=True).astype(dtype)\n                    subifds = None\n                    subfiletype = 1\n                    xml_metadata_bytes = None\n                if is_generator:\n                    data = data_generator(scale)\n                writer.write(data, shape=tuple(new_shape), dtype=dtype, metadata={'axes': self.dim_order},\n                             subifds=subifds, subfiletype=subfiletype,\n                             resolution=resolution, resolutionunit=resolution_unit, tile=tile_size,\n                             compression=compression, compressionargs=compressionargs,\n                             description=xml_metadata_bytes)\n                if level == pyramid_levels:\n                    window = source.get_image_window(window_scanner, well_id=well_id, field_id=field_id, data=data)\n        return data_size, window\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.OmeTiffWriter.verbose","title":"<code>verbose = verbose</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.OmeTiffWriter.OmeTiffWriter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>Initialize OmeTiffWriter.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, prints progress info.</p> <code>False</code> Source code in <code>src/OmeTiffWriter.py</code> <pre><code>def __init__(self, verbose=False):\n    \"\"\"\n    Initialize OmeTiffWriter.\n\n    Args:\n        verbose (bool): If True, prints progress info.\n    \"\"\"\n    super().__init__()\n    self.verbose = verbose\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.OmeTiffWriter.write","title":"<code>write(filepath, source, **kwargs)</code>","text":"<p>Writes image or screen data to OME-TIFF files.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Output file path.</p> required <code>source</code> <code>ImageSource</code> <p>Source object.</p> required <code>**kwargs</code> <p>Additional options (e.g. wells selection).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Containing output_path: str or list Output file path(s) and data window.</p> Source code in <code>src/OmeTiffWriter.py</code> <pre><code>def write(self, filepath, source, **kwargs):\n    \"\"\"\n    Writes image or screen data to OME-TIFF files.\n\n    Args:\n        filepath (str): Output file path.\n        source (ImageSource): Source object.\n        **kwargs: Additional options (e.g. wells selection).\n\n    Returns:\n        dict: Containing output_path: str or list Output file path(s) and data window.\n    \"\"\"\n\n    dim_order = ''\n    source_dim_order = source.get_dim_order()\n    if source.get_time_points():\n        dim_order += 't'\n    if 'c' in source_dim_order and not source.is_rgb():\n        dim_order += 'c'\n    if 'z' in source_dim_order:\n        dim_order += 'z'\n    dim_order += 'yx'\n    if 'c' in source_dim_order and source.is_rgb():\n        dim_order += 'c'\n    self.dim_order = dim_order\n\n    if source.is_screen():\n        filepath, total_size, window = self._write_screen(filepath, source, **kwargs)\n    else:\n        filepath, total_size, window = self._write_image(filepath, source, **kwargs)\n\n    if self.verbose:\n        print(f'Total data written: {print_hbytes(total_size)}')\n\n    return {'output_path': filepath, 'window': window}\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.convert_dotnet_ticks_to_datetime","title":"<code>convert_dotnet_ticks_to_datetime(net_ticks)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def convert_dotnet_ticks_to_datetime(net_ticks):\n    return datetime(1, 1, 1) + timedelta(microseconds=net_ticks // 10)\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.convert_to_um","title":"<code>convert_to_um(value, unit)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def convert_to_um(value, unit):\n    conversions = {\n        'nm': 1e-3,\n        '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'micron': 1,\n        'mm': 1e3, 'millimeter': 1e3,\n        'cm': 1e4, 'centimeter': 1e4,\n        'm': 1e6, 'meter': 1e6\n    }\n    return value * conversions.get(unit, 1)\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.ensure_list","title":"<code>ensure_list(item)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def ensure_list(item):\n    if not isinstance(item, (list, tuple)):\n        item = [item]\n    return item\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.get_bits_type","title":"<code>get_bits_type(nbits)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_bits_type(nbits):\n    if nbits &lt;= 8:\n        dtype = np.uint8\n    elif nbits &lt;= 16:\n        dtype = np.uint16\n    elif nbits &lt;= 32:\n        dtype = np.uint32\n    else:\n        dtype = np.uint64\n    return np.dtype(dtype)\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_filetitle(filename):\n    return os.path.basename(os.path.splitext(filename)[0])\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.get_level_from_scale","title":"<code>get_level_from_scale(source_scales, target_scale=1)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_level_from_scale(source_scales, target_scale=1):\n    best_level_scale = 0, target_scale\n    for level, scale in enumerate(source_scales):\n        if np.isclose(scale, target_scale, rtol=1e-4):\n            return level, 1\n        if scale &lt;= target_scale:\n            best_level_scale = level, target_scale / scale\n    return best_level_scale\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.get_numpy_data","title":"<code>get_numpy_data(data, dim_order, t, c, z, y, x, y_size, x_size)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_numpy_data(data, dim_order, t, c, z, y, x, y_size, x_size):\n    x_index = dim_order.index('x')\n    y_index = dim_order.index('y')\n    slices = [slice(None)] * len(dim_order)\n    if 't' in dim_order:\n        slices[dim_order.index('t')] = t\n    if 'c' in dim_order:\n        slices[dim_order.index('c')] = c\n    if 'z' in dim_order:\n        slices[dim_order.index('z')] = z\n    slices[y_index] = slice(y, y + y_size)\n    slices[x_index] = slice(x, x + x_size)\n    return data[tuple(slices)]\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.get_rows_cols_plate","title":"<code>get_rows_cols_plate(nwells)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_rows_cols_plate(nwells):\n    nrows_cols = {\n        6: (2, 3),\n        12: (3, 4),\n        24: (4, 6),\n        48: (6, 8),\n        96: (8, 12),\n        384: (16, 24)\n    }\n    nrows, ncols = nrows_cols[nwells]\n    rows = [chr(ord('A') + i) for i in range(nrows)]\n    cols = [str(i + 1) for i in range(ncols)]\n    return rows, cols\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.pad_leading_zero","title":"<code>pad_leading_zero(input_string, num_digits=2)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def pad_leading_zero(input_string, num_digits=2):\n    output = str(input_string)\n    is_well = not output[0].isdigit()\n    if is_well:\n        row, col = split_well_name(output, remove_leading_zeros=True)\n        output = str(col)\n    while len(output) &lt; num_digits:\n        output = '0' + output\n    if is_well:\n        output = row + output\n    return output\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.print_dict","title":"<code>print_dict(value, tab=0, max_len=250, bullet=False)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def print_dict(value, tab=0, max_len=250, bullet=False):\n    s = ''\n    if isinstance(value, dict):\n        for key, subvalue in value.items():\n            s += '\\n'\n            if bullet:\n                s += '-'\n                bullet = False\n            s += '\\t' * tab + str(key) + ': '\n            if isinstance(subvalue, dict):\n                s += print_dict(subvalue, tab+1)\n            elif isinstance(subvalue, list):\n                for v in subvalue:\n                    s += print_dict(v, tab+1, bullet=True)\n            else:\n                subvalue = str(subvalue)\n                if len(subvalue) &gt; max_len:\n                    subvalue = subvalue[:max_len] + '...'\n                s += subvalue\n    else:\n        s += str(value) + ' '\n    return s\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def print_hbytes(nbytes):\n    exps = ['', 'K', 'M', 'G', 'T', 'P', 'E']\n    div = 1024\n    exp = 0\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    if exp &lt; len(exps):\n        e = exps[exp]\n    else:\n        e = f'e{exp * 3}'\n    return f'{nbytes:.1f}{e}B'\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.redimension_data","title":"<code>redimension_data(data, old_order, new_order, **indices)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def redimension_data(data, old_order, new_order, **indices):\n    # able to provide optional dimension values e.g. t=0, z=0\n    if new_order == old_order:\n        return data\n\n    new_data = data\n    order = old_order\n    # remove\n    for o in old_order:\n        if o not in new_order:\n            index = order.index(o)\n            dim_value = indices.get(o, 0)\n            new_data = np.take(new_data, indices=dim_value, axis=index)\n            order = order[:index] + order[index + 1:]\n    # add\n    for o in new_order:\n        if o not in order:\n            new_data = np.expand_dims(new_data, 0)\n            order = o + order\n    # move\n    old_indices = [order.index(o) for o in new_order]\n    new_indices = list(range(len(new_order)))\n    new_data = np.moveaxis(new_data, old_indices, new_indices)\n    return new_data\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.split_well_name","title":"<code>split_well_name(well_name, remove_leading_zeros=True, col_as_int=False)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def split_well_name(well_name, remove_leading_zeros=True, col_as_int=False):\n    matches = re.findall(r'(\\D+)(\\d+)', well_name)\n    if len(matches) &gt; 0:\n        row, col = matches[0]\n        if col_as_int or remove_leading_zeros:\n            try:\n                col = int(col)\n            except ValueError:\n                pass\n        if not col_as_int:\n            col = str(col)\n        return row, col\n    else:\n        raise ValueError(f\"Invalid well name format: {well_name}. Expected format like 'A1', 'B2', etc.\")\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.splitall","title":"<code>splitall(path)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def splitall(path):\n    allparts = []\n    while True:\n        parts = os.path.split(path)\n        if parts[0] == path:  # sentinel for absolute paths\n            allparts.insert(0, parts[0])\n            break\n        elif parts[1] == path: # sentinel for relative paths\n            allparts.insert(0, parts[1])\n            break\n        else:\n            path = parts[0]\n            allparts.insert(0, parts[1])\n    return allparts\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.strip_leading_zeros","title":"<code>strip_leading_zeros(well_name)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def strip_leading_zeros(well_name):\n    row, col = split_well_name(well_name, remove_leading_zeros=True)\n    return f'{row}{col}'\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.validate_filename","title":"<code>validate_filename(filename)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def validate_filename(filename):\n    return re.sub(r'[^\\w_.)(-]', '_', filename)\n</code></pre>"},{"location":"references/#src.OmeTiffWriter.xml_content_to_dict","title":"<code>xml_content_to_dict(element)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def xml_content_to_dict(element):\n    key = element.tag\n    children = list(element)\n    if key == 'Array':\n        res = [xml_content_to_dict(child) for child in children]\n        return res\n    if len(children) &gt; 0:\n        if children[0].tag == 'Array':\n            value = []\n        else:\n            value = {}\n        for child in children:\n            child_value = xml_content_to_dict(child)\n            if isinstance(child_value, list):\n                value.extend(child_value)\n            else:\n                value |= child_value\n    else:\n        value = element.text\n        if value is not None:\n            if '\"' in value:\n                value = value.replace('\"', '')\n            else:\n                for t in (float, int, bool):\n                    try:\n                        if t == bool:\n                            if value.lower() == 'true':\n                                value = True\n                            if value.lower() == 'false':\n                                value = False\n                        else:\n                            value = t(value)\n                        break\n                    except (TypeError, ValueError):\n                        pass\n\n    if key == 'DataObject':\n        key = element.attrib['ObjectType']\n    if key == 'Attribute':\n        key = element.attrib['Name']\n    return {key: value}\n</code></pre>"},{"location":"references/#src.OmeWriter","title":"<code>OmeWriter</code>","text":""},{"location":"references/#src.OmeWriter.OmeWriter","title":"<code>OmeWriter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for OME writers.</p> Source code in <code>src/OmeWriter.py</code> <pre><code>class OmeWriter(ABC):\n    \"\"\"\n    Abstract base class for OME writers.\n    \"\"\"\n\n    def write(self, filepath, source, verbose=False, **kwargs) -&gt; str:\n        \"\"\"\n        Write image data and metadata to output.\n\n        Args:\n            filepath (str): Output file path.\n            source (ImageSource): Source object.\n            verbose (bool): If True, prints progress info.\n            **kwargs: Additional options.\n\n        Returns:\n            dict: Containing output_path: str or list Output file path(s), and other optional output.\n        \"\"\"\n        # Expect to return output path (or filepath)\n        raise NotImplementedError(\"This method should be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.OmeWriter.OmeWriter.write","title":"<code>write(filepath, source, verbose=False, **kwargs)</code>","text":"<p>Write image data and metadata to output.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Output file path.</p> required <code>source</code> <code>ImageSource</code> <p>Source object.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints progress info.</p> <code>False</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>str</code> <p>Containing output_path: str or list Output file path(s), and other optional output.</p> Source code in <code>src/OmeWriter.py</code> <pre><code>def write(self, filepath, source, verbose=False, **kwargs) -&gt; str:\n    \"\"\"\n    Write image data and metadata to output.\n\n    Args:\n        filepath (str): Output file path.\n        source (ImageSource): Source object.\n        verbose (bool): If True, prints progress info.\n        **kwargs: Additional options.\n\n    Returns:\n        dict: Containing output_path: str or list Output file path(s), and other optional output.\n    \"\"\"\n    # Expect to return output path (or filepath)\n    raise NotImplementedError(\"This method should be implemented by subclasses.\")\n</code></pre>"},{"location":"references/#src.OmeZarrSource","title":"<code>OmeZarrSource</code>","text":""},{"location":"references/#src.OmeZarrSource.OmeZarrSource","title":"<code>OmeZarrSource</code>","text":"<p>               Bases: <code>ImageSource</code></p> Source code in <code>src/OmeZarrSource.py</code> <pre><code>class OmeZarrSource(ImageSource):\n\n    def _get_reader(self, add_path=None):\n        uri = self.uri\n        if add_path:\n            uri = os.path.join(uri, add_path)\n        location = parse_url(uri)\n        if location is None:\n            raise FileNotFoundError(f'Error parsing ome-zarr file {uri}')\n        reader = Reader(location)\n        nodes = list(reader())\n        return reader, nodes\n\n    def _get_metadata(self, add_path=None):\n        metadata = {}\n        _, nodes = self._get_reader(add_path)\n        if len(nodes) &gt; 0:\n            metadata = nodes[0].metadata\n        return metadata\n\n    def init_metadata(self):\n        reader, nodes = self._get_reader()\n        if 'bioformats2raw.layout' in reader.zarr.root_attrs:\n            # TODO: use paths provided in metadata\n            reader, nodes = self._get_reader('0')\n        # nodes may include images, labels etc\n        if len(nodes) == 0:\n            raise FileNotFoundError(f'No image data found in ome-zarr file {self.uri}')\n        # first node will be the image pixel data\n        image_node = nodes[0]\n        self.metadata = image_node.metadata\n        # channel metadata from ome-zarr-py limited; get from root_attrs manually\n        #self.root_metadata = reader.zarr.root_attrs\n\n        axes = self.metadata.get('axes', [])\n        self.dim_order = ''.join([axis.get('name') for axis in axes])\n        units = {axis['name']: axis['unit'] for axis in axes if 'unit' in axis}\n        self.plate = self.metadata.get('metadata', {}).get('plate')\n        self.is_plate = self.plate is not None\n\n        scales = [transform['scale'] for transform_set in self.metadata['coordinateTransformations']\n                  for transform in transform_set if transform['type'] == 'scale']\n        self.pixel_size = {dim: convert_to_um(pixel_size, units.get(dim, '')) for dim, pixel_size\n                           in zip(self.dim_order, scales[0]) if dim in 'xyz'}\n        x_index, y_index = self.dim_order.index('x'), self.dim_order.index('y')\n        scale0 = np.mean([scales[0][x_index] + scales[0][y_index]])\n        self.scales = [float(scale0 / np.mean([scale[x_index] + scale[y_index]])) for scale in scales]\n        if self.is_plate:\n            self.name = self.plate.get('name', '')\n            self.rows = [row['name'] for row in self.plate.get('rows', [])]\n            self.columns = [column['name'] for column in self.plate.get('columns', [])]\n            self.wells = {well['path'].replace('/', ''): well['path'] for well in self.plate.get('wells')}\n            self.fields = list(range(self.plate.get('field_count', 0)))\n            self.paths = {well_id: {field: f'{well_path}/{field}' for field in self.fields} for well_id, well_path in self.wells.items()}\n            self.acquisitions = self.plate.get('acquisitions', [])\n            self.acquisition_datetime = datetime.fromisoformat(self.acquisitions[0]['date_created'])\n            self.data = None    # data will be read per plate well\n        else:\n            self.name = self.metadata.get('name', '')\n            self.acquisition_datetime = datetime.fromtimestamp(os.path.getctime(self.uri))\n            self.data = image_node.data\n        if not self.name:\n            self.name = get_filetitle(self.uri)\n        self.name = str(self.name).rstrip('.ome')\n\n        self.shapes = [data.shape for data in image_node.data]\n        self.shape = self.shapes[0]\n        self.heights = [shape[y_index] for shape in self.shapes]\n        self.widths = [shape[x_index] for shape in self.shapes]\n        self.dtype = image_node.data[0].dtype\n        self.bits_per_pixel = self.dtype.itemsize * 8\n        return self.metadata\n\n    def is_screen(self):\n        return self.is_plate\n\n    def get_shape(self):\n        return self.shape\n\n    def get_shapes(self):\n        return self.shapes\n\n    def get_scales(self):\n        return self.scales\n\n    def get_data(self, level=0, well_id=None, field_id=None, **kwargs):\n        if well_id is None and field_id is None:\n            return self.data[level]\n        else:\n            _, nodes = self._get_reader(self.paths[well_id][field_id])\n            return nodes[0].data[level]\n\n    def get_data_as_generator(self, dim_order, **kwargs):\n        def data_generator(scale=1):\n            level, rescale = get_level_from_scale(self.scales, scale)\n            level_data = self.data[level]\n            read_size = int(TILE_SIZE / rescale)\n            nz = self.shape[self.dim_order.index('z')] if 'z' in self.dim_order else 1\n            for t in range(len(self.get_time_points())):\n                for c in range(self.get_nchannels()):\n                    for z in range(nz):\n                        for y in range(0, self.heights[level], read_size):\n                            for x in range(0, self.widths[level], read_size):\n                                data = get_numpy_data(level_data, dim_order, t, c, z, y, x, read_size, read_size)\n                                if rescale != 1:\n                                    data = sk_transform.resize(data,\n                                                               (np.array(data.shape) * rescale).astype(int),\n                                                               preserve_range=True).astype(data.dtype)\n                                yield redimension_data(data, self.dim_order, dim_order)\n        return data_generator\n\n    def get_image_window(self, window_scanner, well_id=None, field_id=None, data=None):\n        if well_id is None and field_id is None:\n            metadata = self.metadata\n        else:\n            metadata = self._get_metadata(self.paths[well_id][field_id])\n        window = np.transpose(metadata.get('contrast_limits', ([], [])))\n        return window\n\n    def get_name(self):\n        return self.name\n\n    def get_dim_order(self):\n        return self.dim_order\n\n    def get_dtype(self):\n        return self.dtype\n\n    def get_pixel_size_um(self):\n        return self.pixel_size\n\n    def get_position_um(self, well_id=None):\n        metadata = self._get_metadata(self.paths[well_id][0])\n        for transforms in metadata['coordinateTransformations'][0]:\n            if transforms['type'] == 'translation':\n                return {dim:value for dim, value in zip(self.dim_order, transforms['translation'])}\n        return {}\n\n    def get_channels(self):\n        channels = []\n        colormaps = self.metadata['colormap']\n        for channeli, channel_name in enumerate(self.metadata['channel_names']):\n            channel = {'label': channel_name}\n            if channeli &lt; len(colormaps):\n                channel['color'] = colormaps[channeli][-1]\n            channels.append(channel)\n        return channels\n\n    def get_nchannels(self):\n        return self.shape[self.dim_order.index('c')] if 'c' in self.dim_order else 1\n\n    def is_rgb(self):\n        return self.get_nchannels() in (3, 4)\n\n    def get_rows(self):\n        return self.rows\n\n    def get_columns(self):\n        return self.columns\n\n    def get_wells(self):\n        return self.wells\n\n    def get_time_points(self):\n        nt = self.shape[self.dim_order.index('t')] if 't' in self.dim_order else 1\n        return list(range(nt))\n\n    def get_fields(self):\n        return self.fields\n\n    def get_acquisitions(self):\n        return self.acquisitions\n\n    def get_acquisition_datetime(self):\n        return self.acquisition_datetime\n\n    def get_significant_bits(self):\n        return self.bits_per_pixel\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_acquisition_datetime","title":"<code>get_acquisition_datetime()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_acquisition_datetime(self):\n    return self.acquisition_datetime\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_acquisitions","title":"<code>get_acquisitions()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_acquisitions(self):\n    return self.acquisitions\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_channels","title":"<code>get_channels()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_channels(self):\n    channels = []\n    colormaps = self.metadata['colormap']\n    for channeli, channel_name in enumerate(self.metadata['channel_names']):\n        channel = {'label': channel_name}\n        if channeli &lt; len(colormaps):\n            channel['color'] = colormaps[channeli][-1]\n        channels.append(channel)\n    return channels\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_columns","title":"<code>get_columns()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_columns(self):\n    return self.columns\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_data","title":"<code>get_data(level=0, well_id=None, field_id=None, **kwargs)</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_data(self, level=0, well_id=None, field_id=None, **kwargs):\n    if well_id is None and field_id is None:\n        return self.data[level]\n    else:\n        _, nodes = self._get_reader(self.paths[well_id][field_id])\n        return nodes[0].data[level]\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_data_as_generator","title":"<code>get_data_as_generator(dim_order, **kwargs)</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_data_as_generator(self, dim_order, **kwargs):\n    def data_generator(scale=1):\n        level, rescale = get_level_from_scale(self.scales, scale)\n        level_data = self.data[level]\n        read_size = int(TILE_SIZE / rescale)\n        nz = self.shape[self.dim_order.index('z')] if 'z' in self.dim_order else 1\n        for t in range(len(self.get_time_points())):\n            for c in range(self.get_nchannels()):\n                for z in range(nz):\n                    for y in range(0, self.heights[level], read_size):\n                        for x in range(0, self.widths[level], read_size):\n                            data = get_numpy_data(level_data, dim_order, t, c, z, y, x, read_size, read_size)\n                            if rescale != 1:\n                                data = sk_transform.resize(data,\n                                                           (np.array(data.shape) * rescale).astype(int),\n                                                           preserve_range=True).astype(data.dtype)\n                            yield redimension_data(data, self.dim_order, dim_order)\n    return data_generator\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_dim_order(self):\n    return self.dim_order\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_dtype","title":"<code>get_dtype()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_dtype(self):\n    return self.dtype\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_fields","title":"<code>get_fields()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_fields(self):\n    return self.fields\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_image_window","title":"<code>get_image_window(window_scanner, well_id=None, field_id=None, data=None)</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_image_window(self, window_scanner, well_id=None, field_id=None, data=None):\n    if well_id is None and field_id is None:\n        metadata = self.metadata\n    else:\n        metadata = self._get_metadata(self.paths[well_id][field_id])\n    window = np.transpose(metadata.get('contrast_limits', ([], [])))\n    return window\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_name","title":"<code>get_name()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_name(self):\n    return self.name\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_nchannels(self):\n    return self.shape[self.dim_order.index('c')] if 'c' in self.dim_order else 1\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_pixel_size_um(self):\n    return self.pixel_size\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_position_um","title":"<code>get_position_um(well_id=None)</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_position_um(self, well_id=None):\n    metadata = self._get_metadata(self.paths[well_id][0])\n    for transforms in metadata['coordinateTransformations'][0]:\n        if transforms['type'] == 'translation':\n            return {dim:value for dim, value in zip(self.dim_order, transforms['translation'])}\n    return {}\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_rows","title":"<code>get_rows()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_rows(self):\n    return self.rows\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_scales","title":"<code>get_scales()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_scales(self):\n    return self.scales\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_shape","title":"<code>get_shape()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_shape(self):\n    return self.shape\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_shapes","title":"<code>get_shapes()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_shapes(self):\n    return self.shapes\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_significant_bits","title":"<code>get_significant_bits()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_significant_bits(self):\n    return self.bits_per_pixel\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_time_points","title":"<code>get_time_points()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_time_points(self):\n    nt = self.shape[self.dim_order.index('t')] if 't' in self.dim_order else 1\n    return list(range(nt))\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.get_wells","title":"<code>get_wells()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def get_wells(self):\n    return self.wells\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.init_metadata","title":"<code>init_metadata()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def init_metadata(self):\n    reader, nodes = self._get_reader()\n    if 'bioformats2raw.layout' in reader.zarr.root_attrs:\n        # TODO: use paths provided in metadata\n        reader, nodes = self._get_reader('0')\n    # nodes may include images, labels etc\n    if len(nodes) == 0:\n        raise FileNotFoundError(f'No image data found in ome-zarr file {self.uri}')\n    # first node will be the image pixel data\n    image_node = nodes[0]\n    self.metadata = image_node.metadata\n    # channel metadata from ome-zarr-py limited; get from root_attrs manually\n    #self.root_metadata = reader.zarr.root_attrs\n\n    axes = self.metadata.get('axes', [])\n    self.dim_order = ''.join([axis.get('name') for axis in axes])\n    units = {axis['name']: axis['unit'] for axis in axes if 'unit' in axis}\n    self.plate = self.metadata.get('metadata', {}).get('plate')\n    self.is_plate = self.plate is not None\n\n    scales = [transform['scale'] for transform_set in self.metadata['coordinateTransformations']\n              for transform in transform_set if transform['type'] == 'scale']\n    self.pixel_size = {dim: convert_to_um(pixel_size, units.get(dim, '')) for dim, pixel_size\n                       in zip(self.dim_order, scales[0]) if dim in 'xyz'}\n    x_index, y_index = self.dim_order.index('x'), self.dim_order.index('y')\n    scale0 = np.mean([scales[0][x_index] + scales[0][y_index]])\n    self.scales = [float(scale0 / np.mean([scale[x_index] + scale[y_index]])) for scale in scales]\n    if self.is_plate:\n        self.name = self.plate.get('name', '')\n        self.rows = [row['name'] for row in self.plate.get('rows', [])]\n        self.columns = [column['name'] for column in self.plate.get('columns', [])]\n        self.wells = {well['path'].replace('/', ''): well['path'] for well in self.plate.get('wells')}\n        self.fields = list(range(self.plate.get('field_count', 0)))\n        self.paths = {well_id: {field: f'{well_path}/{field}' for field in self.fields} for well_id, well_path in self.wells.items()}\n        self.acquisitions = self.plate.get('acquisitions', [])\n        self.acquisition_datetime = datetime.fromisoformat(self.acquisitions[0]['date_created'])\n        self.data = None    # data will be read per plate well\n    else:\n        self.name = self.metadata.get('name', '')\n        self.acquisition_datetime = datetime.fromtimestamp(os.path.getctime(self.uri))\n        self.data = image_node.data\n    if not self.name:\n        self.name = get_filetitle(self.uri)\n    self.name = str(self.name).rstrip('.ome')\n\n    self.shapes = [data.shape for data in image_node.data]\n    self.shape = self.shapes[0]\n    self.heights = [shape[y_index] for shape in self.shapes]\n    self.widths = [shape[x_index] for shape in self.shapes]\n    self.dtype = image_node.data[0].dtype\n    self.bits_per_pixel = self.dtype.itemsize * 8\n    return self.metadata\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.is_rgb","title":"<code>is_rgb()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def is_rgb(self):\n    return self.get_nchannels() in (3, 4)\n</code></pre>"},{"location":"references/#src.OmeZarrSource.OmeZarrSource.is_screen","title":"<code>is_screen()</code>","text":"Source code in <code>src/OmeZarrSource.py</code> <pre><code>def is_screen(self):\n    return self.is_plate\n</code></pre>"},{"location":"references/#src.OmeZarrSource.create_axes_metadata","title":"<code>create_axes_metadata(dimension_order)</code>","text":"<p>Create axes metadata for OME-Zarr from dimension order.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of axis metadata dictionaries.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_axes_metadata(dimension_order):\n    \"\"\"\n    Create axes metadata for OME-Zarr from dimension order.\n\n    Args:\n        dimension_order (str): String of dimension characters.\n\n    Returns:\n        list: List of axis metadata dictionaries.\n    \"\"\"\n    axes = []\n    for dimension in dimension_order:\n        unit1 = None\n        if dimension == 't':\n            type1 = 'time'\n            unit1 = 'millisecond'\n        elif dimension == 'c':\n            type1 = 'channel'\n        else:\n            type1 = 'space'\n            unit1 = 'micrometer'\n        axis = {'name': dimension, 'type': type1}\n        if unit1 is not None and unit1 != '':\n            axis['unit'] = unit1\n        axes.append(axis)\n    return axes\n</code></pre>"},{"location":"references/#src.OmeZarrSource.create_channel_metadata","title":"<code>create_channel_metadata(dtype, channels, nchannels, is_rgb, window, ome_version)</code>","text":"<p>Create channel metadata for OME-Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <p>Numpy dtype of image data.</p> required <code>channels</code> <code>list</code> <p>List of channel dicts.</p> required <code>nchannels</code> <code>int</code> <p>Number of channels.</p> required <code>window</code> <code>tuple</code> <p>Min/max window values.</p> required <code>ome_version</code> <code>str</code> <p>OME-Zarr version.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Channel metadata dictionary.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_channel_metadata(dtype, channels, nchannels, is_rgb, window, ome_version):\n    \"\"\"\n    Create channel metadata for OME-Zarr.\n\n    Args:\n        dtype: Numpy dtype of image data.\n        channels (list): List of channel dicts.\n        nchannels (int): Number of channels.\n        window (tuple): Min/max window values.\n        ome_version (str): OME-Zarr version.\n\n    Returns:\n        dict: Channel metadata dictionary.\n    \"\"\"\n    if len(channels) &lt; nchannels:\n        labels = []\n        colors = []\n        if is_rgb and nchannels in (3, 4):\n            labels = ['Red', 'Green', 'Blue']\n            colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n        if is_rgb and nchannels == 4:\n            labels += ['Alpha']\n            colors += [(1, 1, 1)]\n        channels = [{'label': label, 'color': color} for label, color in zip(labels, colors)]\n\n    omezarr_channels = []\n    starts, ends = window\n    for channeli, channel in enumerate(channels):\n        omezarr_channel = {'label': channel.get('label', channel.get('Name', f'{channeli}')), 'active': True}\n        color = channel.get('color', channel.get('Color'))\n        if color is not None:\n            omezarr_channel['color'] = rgba_to_hexrgb(color)\n        if np.dtype(dtype).kind == 'f':\n            min, max = 0, 1\n        else:\n            info = np.iinfo(dtype)\n            min, max = info.min, info.max\n        if starts and ends:\n            start, end = starts[channeli], ends[channeli]\n        else:\n            start, end = min, max\n        omezarr_channel['window'] = {'min': min, 'max': max, 'start': start, 'end': end}\n        omezarr_channels.append(omezarr_channel)\n\n    metadata = {\n        'version': ome_version,\n        'channels': omezarr_channels,\n    }\n    return metadata\n</code></pre>"},{"location":"references/#src.OmeZarrSource.create_transformation_metadata","title":"<code>create_transformation_metadata(dimension_order, pixel_size_um, factor, translation_um=None)</code>","text":"<p>Create transformation metadata (scale and translation) for OME-Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <code>pixel_size_um</code> <code>dict</code> <p>Pixel size in micrometers per dimension.</p> required <code>factor</code> <code>float</code> <p>Scaling factor.</p> required <code>translation_um</code> <code>dict</code> <p>Translation in micrometers per dimension.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>List of transformation metadata dictionaries.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_transformation_metadata(dimension_order, pixel_size_um, factor, translation_um=None):\n    \"\"\"\n    Create transformation metadata (scale and translation) for OME-Zarr.\n\n    Args:\n        dimension_order (str): String of dimension characters.\n        pixel_size_um (dict): Pixel size in micrometers per dimension.\n        factor (float): Scaling factor.\n        translation_um (dict, optional): Translation in micrometers per dimension.\n\n    Returns:\n        list: List of transformation metadata dictionaries.\n    \"\"\"\n    metadata = []\n    pixel_size_scale = []\n    translation_scale = []\n    for dim in dimension_order:\n        pixel_size_scale1 = pixel_size_um.get(dim, 1)\n        if dim in 'xy':\n            pixel_size_scale1 *= factor\n        if pixel_size_scale1 == 0:\n            pixel_size_scale1 = 1\n        pixel_size_scale.append(pixel_size_scale1)\n\n        if translation_um is not None:\n            translation1 = translation_um.get(dim, 0)\n            # translation_pyramid = translation + (scale - 1) * pixel_size / 2\n            if dim in 'xy':\n                translation1 += (factor - 1) * pixel_size_um[dim] / 2\n            translation_scale.append(translation1)\n\n    metadata.append({'type': 'scale', 'scale': pixel_size_scale})\n    if translation_um is not None:\n        metadata.append({'type': 'translation', 'translation': translation_scale})\n    return metadata\n</code></pre>"},{"location":"references/#src.OmeZarrSource.rgba_to_hexrgb","title":"<code>rgba_to_hexrgb(rgba)</code>","text":"Source code in <code>src/color_conversion.py</code> <pre><code>def rgba_to_hexrgb(rgba: list) -&gt; str:\n    hexrgb = ''.join([hex(int(x * 255))[2:].upper().zfill(2) for x in rgba[:3]])\n    return hexrgb\n</code></pre>"},{"location":"references/#src.OmeZarrSource.scale_dimensions_dict","title":"<code>scale_dimensions_dict(shape0, scale)</code>","text":"<p>Scale x and y dimensions in a shape dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>shape0</code> <code>dict</code> <p>Original shape dictionary.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Scaled shape dictionary.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def scale_dimensions_dict(shape0, scale):\n    \"\"\"\n    Scale x and y dimensions in a shape dictionary.\n\n    Args:\n        shape0 (dict): Original shape dictionary.\n        scale (float): Scaling factor.\n\n    Returns:\n        dict: Scaled shape dictionary.\n    \"\"\"\n    shape = {}\n    if scale == 1:\n        return shape0\n    for dimension, shape1 in shape0.items():\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape[dimension] = shape1\n    return shape\n</code></pre>"},{"location":"references/#src.OmeZarrSource.scale_dimensions_xy","title":"<code>scale_dimensions_xy(shape0, dimension_order, scale)</code>","text":"<p>Scale x and y dimensions in a shape tuple.</p> <p>Parameters:</p> Name Type Description Default <code>shape0</code> <code>tuple</code> <p>Original shape.</p> required <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Scaled shape.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def scale_dimensions_xy(shape0, dimension_order, scale):\n    \"\"\"\n    Scale x and y dimensions in a shape tuple.\n\n    Args:\n        shape0 (tuple): Original shape.\n        dimension_order (str): String of dimension characters.\n        scale (float): Scaling factor.\n\n    Returns:\n        list: Scaled shape.\n    \"\"\"\n    shape = []\n    if scale == 1:\n        return shape0\n    for shape1, dimension in zip(shape0, dimension_order):\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape.append(shape1)\n    return shape\n</code></pre>"},{"location":"references/#src.OmeZarrWriter","title":"<code>OmeZarrWriter</code>","text":""},{"location":"references/#src.OmeZarrWriter.PYRAMID_DOWNSCALE","title":"<code>PYRAMID_DOWNSCALE = 2</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.PYRAMID_LEVELS","title":"<code>PYRAMID_LEVELS = 6</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.RETRY_ATTEMPTS","title":"<code>RETRY_ATTEMPTS = 3</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.TIFF_COMPRESSION","title":"<code>TIFF_COMPRESSION = 'LZW'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.TILE_SIZE","title":"<code>TILE_SIZE = 1024</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.VERSION","title":"<code>VERSION = 'v0.1.18'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.ZARR_CHUNK_SIZE","title":"<code>ZARR_CHUNK_SIZE = TILE_SIZE</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.ZARR_SHARD_MULTIPLIER","title":"<code>ZARR_SHARD_MULTIPLIER = 10</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter","title":"<code>OmeZarrWriter</code>","text":"<p>               Bases: <code>OmeWriter</code></p> <p>Writer for exporting image or screen data to OME-Zarr format. Supports both single images and high-content screening (HCS) plates.</p> Source code in <code>src/OmeZarrWriter.py</code> <pre><code>class OmeZarrWriter(OmeWriter):\n    \"\"\"\n    Writer for exporting image or screen data to OME-Zarr format.\n    Supports both single images and high-content screening (HCS) plates.\n    \"\"\"\n\n    def __init__(self, zarr_version=2, ome_version='0.4', verbose=False):\n        \"\"\"\n        Initialize the OmeZarrWriter.\n\n        Args:\n            zarr_version (int): Zarr format version (2 or 3).\n            ome_version (str): OME-Zarr metadata version ('0.4' or '0.5').\n            verbose (bool): If True, print additional information.\n        \"\"\"\n        super().__init__()\n        self.zarr_version = zarr_version\n        self.ome_version = ome_version\n        if ome_version == '0.4':\n            from ome_zarr.format import FormatV04\n            self.ome_format = FormatV04()\n        elif ome_version == '0.5':\n            from ome_zarr.format import FormatV05\n            self.ome_format = FormatV05()\n        else:\n            self.ome_format = None\n        self.verbose = verbose\n        self.dim_order = 'tczyx'\n\n    def write(self, filepath, source, **kwargs):\n        \"\"\"\n        Write the provided source data to an OME-Zarr file.\n\n        Args:\n            filepath (str): Output path for the Zarr file.\n            source: source reader supporting required interface.\n            **kwargs: Additional arguments (e.g. wells selection).\n\n        Returns:\n            dict: Containing output_path: str Output file path.\n        \"\"\"\n        if source.is_screen():\n            zarr_root, total_size = self._write_screen(filepath, source, **kwargs)\n        else:\n            zarr_root, total_size = self._write_image(filepath, source, **kwargs)\n\n        zarr_root.attrs['_creator'] = {'name': 'nl.biomero.OmeZarrWriter', 'version': VERSION}\n\n        if self.verbose:\n            print(f'Total data written: {print_hbytes(total_size)}')\n\n        return {'output_path': filepath}\n\n    def _write_screen(self, filepath, source, **kwargs):\n        \"\"\"\n        Write a high-content screening (HCS) plate to OME-Zarr.\n\n        Args:\n            filepath (str): Output path for the Zarr file.\n            source: source reader supporting required interface.\n            **kwargs: Additional arguments (e.g., wells).\n\n        Returns:\n            tuple: (zarr_root, total_size) where zarr_root is the root group and total_size is bytes written.\n        \"\"\"\n        #zarr_location = parse_url(filename, mode='w', fmt=self.ome_format)\n        zarr_location = filepath\n        zarr_root = zarr.open_group(zarr_location, mode='w', zarr_version=self.zarr_version)\n\n        row_names = [chr(ord('A') + index) for index\n                     in range(max([ord(row_name.upper()) - ord('A') for row_name in source.get_rows()]) + 1)]\n        col_names = [str(index) for index\n                     in range(1, max([int(col) for col in source.get_columns()]) + 1)]\n        wells = kwargs.get('wells', source.get_wells())\n        well_paths = ['/'.join(split_well_name(well)) for well in wells]\n        fields = list(map(str, source.get_fields()))\n\n        acquisitions = source.get_acquisitions()\n        name = source.get_name()\n        write_plate_metadata(zarr_root, row_names, col_names, well_paths,\n                             name=name, field_count=len(fields), acquisitions=acquisitions,\n                             fmt=self.ome_format)\n        total_size = 0\n        for well_id in wells:\n            row, col = split_well_name(well_id)\n            row_group = zarr_root.require_group(str(row))\n            well_group = row_group.require_group(str(col))\n            write_well_metadata(well_group, fields, fmt=self.ome_format)\n            position = source.get_position_um(well_id)\n            for field_id in fields:\n                image_group = well_group.require_group(field_id)\n                data = source.get_data(self.dim_order, well_id=well_id, field_id=field_id)\n                window_scanner = WindowScanner()\n                window = source.get_image_window(window_scanner, well_id=well_id, field_id=field_id, data=data)\n                size = self._write_data(image_group, data, source, window, position=position)\n                total_size += size\n\n        return zarr_root, total_size\n\n    def _write_image(self, filepath, source, **kwargs):\n        \"\"\"\n        Write a single image to OME-Zarr.\n\n        Args:\n            filepath (str): Output path for the Zarr file.\n            source: source reader for image data.\n            **kwargs: Additional arguments.\n\n        Returns:\n            tuple: (zarr_root, size) where zarr_root is the root group and size is bytes written.\n        \"\"\"\n        #zarr_location = parse_url(filename, mode='w', fmt=self.ome_format)\n        zarr_location = filepath\n        zarr_root = zarr.open_group(zarr_location, mode='w', zarr_version=self.zarr_version)\n\n        nlevels = len(source.get_scales())\n        size0 = np.prod(source.get_shape()) * source.get_dtype().itemsize\n        available = psutil.virtual_memory().available\n\n        pyramid_data = []\n        scale = 1\n        last_level = None\n        if nlevels &gt; 1:\n            # load best matching levels for pyramid\n            for index in range(PYRAMID_LEVELS + 1):\n                level, rescale = get_level_from_scale(source.get_scales(), scale)\n                if level != last_level:\n                    if size0 &lt; available:\n                        data = np.asarray(source.get_data(self.dim_order, level=level))\n                    else:\n                        data = source.get_data_as_dask(self.dim_order, level=level)\n                    last_level = level\n                if index == 0:\n                    shape0 = data.shape\n                if rescale != 1:\n                    shape = list(shape0)\n                    shape[-2:] = np.multiply(shape0[-2:], scale).astype(int)\n                    if isinstance(data, da.Array):\n                        data = dask_utils.resize(data, shape)\n                    else:\n                        data = resize(data, shape, preserve_range=True).astype(data.dtype)\n                pyramid_data.append(data)\n                scale /= PYRAMID_DOWNSCALE\n        else:\n            # no source pyramids sizes available\n            if size0 &lt; available:\n                pyramid_data = np.asarray(source.get_data(self.dim_order))\n            else:\n                pyramid_data = source.get_data_as_dask(self.dim_order)\n\n        window_scanner = WindowScanner()\n        window = source.get_image_window(window_scanner)\n        size = self._write_data(zarr_root, pyramid_data, source, window, position=source.get_position_um())\n        return zarr_root, size\n\n    def _write_data(self, group, data, source, window, position=None):\n        \"\"\"\n        Write image data and metadata to a Zarr group.\n\n        Args:\n            group: Zarr group to write into.\n            data: Image data array.\n            source: source reader.\n            window: Image window information.\n            position: Optional position information.\n\n        Returns:\n            int: Number of bytes written.\n        \"\"\"\n        dim_order = self.dim_order\n        dtype = source.get_dtype()\n        channels = source.get_channels()\n        nchannels = source.get_nchannels()\n        is_rgb = source.is_rgb()\n\n        axes = create_axes_metadata(dim_order)\n        pixel_size_scales, scaler = self._create_scale_metadata(source, dim_order, position)\n        metadata = {'omero': create_channel_metadata(dtype, channels, nchannels, is_rgb, window, self.ome_version),\n                    'method': scaler.method}\n\n        is_pyramid = isinstance(data, list)\n        if is_pyramid:\n            data0 = data[0]\n        else:\n            data0 = data\n        storage_options = None\n        if self.zarr_version &gt;= 3:\n            if not hasattr(data0, 'chunksize'):\n                chunks = []\n                shards = []\n                for dim, n in zip(dim_order, data0.shape):\n                    if dim in 'xy':\n                        chunks += [ZARR_CHUNK_SIZE]\n                        shards += [ZARR_CHUNK_SIZE * ZARR_SHARD_MULTIPLIER]\n                    else:\n                        chunks += [1]\n                        shards += [1]\n                storage_options = {'chunks': chunks, 'shards': shards}\n\n        size = data0.size * data0.itemsize\n        if is_pyramid:\n            #images = [Image.fromarray(data1) for data1 in data]\n            #ngff_zarr.from_ngff_zarr() # use this to see construction\n            #axes1 = [Axis()]\n            #datasets1 = [Dataset()]\n            #coordinateTransformations1 = Transform()\n            #metadata = Metadata(axes1, datasets1, coordinateTransformations1)\n            #multiscales = Multiscales(images, metadata)\n            #ngff_zarr.to_ngff_zarr(group, multiscales=multiscales)\n\n            write_multiscale(pyramid=data, group=group, axes=axes, coordinate_transformations=pixel_size_scales,\n                            fmt=self.ome_format, storage_options=storage_options,\n                            name=source.get_name(), metadata=metadata)\n        else:\n            write_image(image=data, group=group, axes=axes, coordinate_transformations=pixel_size_scales,\n                        scaler=scaler, fmt=self.ome_format, storage_options=storage_options,\n                        name=source.get_name(), metadata=metadata)\n        return size\n\n    def _create_scale_metadata(self, source, dim_order, translation=None, scaler=None):\n        \"\"\"\n        Create coordinate transformation metadata for multiscale images.\n\n        Args:\n            source: source reader.\n            dim_order (str): Dimension order string.\n            translation: Translation or position information.\n            scaler: Optional Scaler object.\n\n        Returns:\n            tuple: (pixel_size_scales, scaler)\n        \"\"\"\n        if scaler is None:\n            scaler = Scaler(downscale=PYRAMID_DOWNSCALE, max_layer=PYRAMID_LEVELS)\n        pixel_size_scales = []\n        factor = 1\n        for i in range(scaler.max_layer + 1):\n            pixel_size_scales.append(\n                create_transformation_metadata(dim_order, source.get_pixel_size_um(),\n                                               factor, translation))\n            factor *= scaler.downscale\n        return pixel_size_scales, scaler\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.dim_order","title":"<code>dim_order = 'tczyx'</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.ome_format","title":"<code>ome_format = FormatV04()</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.ome_version","title":"<code>ome_version = ome_version</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.verbose","title":"<code>verbose = verbose</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.zarr_version","title":"<code>zarr_version = zarr_version</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.__init__","title":"<code>__init__(zarr_version=2, ome_version='0.4', verbose=False)</code>","text":"<p>Initialize the OmeZarrWriter.</p> <p>Parameters:</p> Name Type Description Default <code>zarr_version</code> <code>int</code> <p>Zarr format version (2 or 3).</p> <code>2</code> <code>ome_version</code> <code>str</code> <p>OME-Zarr metadata version ('0.4' or '0.5').</p> <code>'0.4'</code> <code>verbose</code> <code>bool</code> <p>If True, print additional information.</p> <code>False</code> Source code in <code>src/OmeZarrWriter.py</code> <pre><code>def __init__(self, zarr_version=2, ome_version='0.4', verbose=False):\n    \"\"\"\n    Initialize the OmeZarrWriter.\n\n    Args:\n        zarr_version (int): Zarr format version (2 or 3).\n        ome_version (str): OME-Zarr metadata version ('0.4' or '0.5').\n        verbose (bool): If True, print additional information.\n    \"\"\"\n    super().__init__()\n    self.zarr_version = zarr_version\n    self.ome_version = ome_version\n    if ome_version == '0.4':\n        from ome_zarr.format import FormatV04\n        self.ome_format = FormatV04()\n    elif ome_version == '0.5':\n        from ome_zarr.format import FormatV05\n        self.ome_format = FormatV05()\n    else:\n        self.ome_format = None\n    self.verbose = verbose\n    self.dim_order = 'tczyx'\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.OmeZarrWriter.write","title":"<code>write(filepath, source, **kwargs)</code>","text":"<p>Write the provided source data to an OME-Zarr file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Output path for the Zarr file.</p> required <code>source</code> <p>source reader supporting required interface.</p> required <code>**kwargs</code> <p>Additional arguments (e.g. wells selection).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Containing output_path: str Output file path.</p> Source code in <code>src/OmeZarrWriter.py</code> <pre><code>def write(self, filepath, source, **kwargs):\n    \"\"\"\n    Write the provided source data to an OME-Zarr file.\n\n    Args:\n        filepath (str): Output path for the Zarr file.\n        source: source reader supporting required interface.\n        **kwargs: Additional arguments (e.g. wells selection).\n\n    Returns:\n        dict: Containing output_path: str Output file path.\n    \"\"\"\n    if source.is_screen():\n        zarr_root, total_size = self._write_screen(filepath, source, **kwargs)\n    else:\n        zarr_root, total_size = self._write_image(filepath, source, **kwargs)\n\n    zarr_root.attrs['_creator'] = {'name': 'nl.biomero.OmeZarrWriter', 'version': VERSION}\n\n    if self.verbose:\n        print(f'Total data written: {print_hbytes(total_size)}')\n\n    return {'output_path': filepath}\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.create_axes_metadata","title":"<code>create_axes_metadata(dimension_order)</code>","text":"<p>Create axes metadata for OME-Zarr from dimension order.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of axis metadata dictionaries.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_axes_metadata(dimension_order):\n    \"\"\"\n    Create axes metadata for OME-Zarr from dimension order.\n\n    Args:\n        dimension_order (str): String of dimension characters.\n\n    Returns:\n        list: List of axis metadata dictionaries.\n    \"\"\"\n    axes = []\n    for dimension in dimension_order:\n        unit1 = None\n        if dimension == 't':\n            type1 = 'time'\n            unit1 = 'millisecond'\n        elif dimension == 'c':\n            type1 = 'channel'\n        else:\n            type1 = 'space'\n            unit1 = 'micrometer'\n        axis = {'name': dimension, 'type': type1}\n        if unit1 is not None and unit1 != '':\n            axis['unit'] = unit1\n        axes.append(axis)\n    return axes\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.create_channel_metadata","title":"<code>create_channel_metadata(dtype, channels, nchannels, is_rgb, window, ome_version)</code>","text":"<p>Create channel metadata for OME-Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <p>Numpy dtype of image data.</p> required <code>channels</code> <code>list</code> <p>List of channel dicts.</p> required <code>nchannels</code> <code>int</code> <p>Number of channels.</p> required <code>window</code> <code>tuple</code> <p>Min/max window values.</p> required <code>ome_version</code> <code>str</code> <p>OME-Zarr version.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Channel metadata dictionary.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_channel_metadata(dtype, channels, nchannels, is_rgb, window, ome_version):\n    \"\"\"\n    Create channel metadata for OME-Zarr.\n\n    Args:\n        dtype: Numpy dtype of image data.\n        channels (list): List of channel dicts.\n        nchannels (int): Number of channels.\n        window (tuple): Min/max window values.\n        ome_version (str): OME-Zarr version.\n\n    Returns:\n        dict: Channel metadata dictionary.\n    \"\"\"\n    if len(channels) &lt; nchannels:\n        labels = []\n        colors = []\n        if is_rgb and nchannels in (3, 4):\n            labels = ['Red', 'Green', 'Blue']\n            colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n        if is_rgb and nchannels == 4:\n            labels += ['Alpha']\n            colors += [(1, 1, 1)]\n        channels = [{'label': label, 'color': color} for label, color in zip(labels, colors)]\n\n    omezarr_channels = []\n    starts, ends = window\n    for channeli, channel in enumerate(channels):\n        omezarr_channel = {'label': channel.get('label', channel.get('Name', f'{channeli}')), 'active': True}\n        color = channel.get('color', channel.get('Color'))\n        if color is not None:\n            omezarr_channel['color'] = rgba_to_hexrgb(color)\n        if np.dtype(dtype).kind == 'f':\n            min, max = 0, 1\n        else:\n            info = np.iinfo(dtype)\n            min, max = info.min, info.max\n        if starts and ends:\n            start, end = starts[channeli], ends[channeli]\n        else:\n            start, end = min, max\n        omezarr_channel['window'] = {'min': min, 'max': max, 'start': start, 'end': end}\n        omezarr_channels.append(omezarr_channel)\n\n    metadata = {\n        'version': ome_version,\n        'channels': omezarr_channels,\n    }\n    return metadata\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.create_transformation_metadata","title":"<code>create_transformation_metadata(dimension_order, pixel_size_um, factor, translation_um=None)</code>","text":"<p>Create transformation metadata (scale and translation) for OME-Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <code>pixel_size_um</code> <code>dict</code> <p>Pixel size in micrometers per dimension.</p> required <code>factor</code> <code>float</code> <p>Scaling factor.</p> required <code>translation_um</code> <code>dict</code> <p>Translation in micrometers per dimension.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>List of transformation metadata dictionaries.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_transformation_metadata(dimension_order, pixel_size_um, factor, translation_um=None):\n    \"\"\"\n    Create transformation metadata (scale and translation) for OME-Zarr.\n\n    Args:\n        dimension_order (str): String of dimension characters.\n        pixel_size_um (dict): Pixel size in micrometers per dimension.\n        factor (float): Scaling factor.\n        translation_um (dict, optional): Translation in micrometers per dimension.\n\n    Returns:\n        list: List of transformation metadata dictionaries.\n    \"\"\"\n    metadata = []\n    pixel_size_scale = []\n    translation_scale = []\n    for dim in dimension_order:\n        pixel_size_scale1 = pixel_size_um.get(dim, 1)\n        if dim in 'xy':\n            pixel_size_scale1 *= factor\n        if pixel_size_scale1 == 0:\n            pixel_size_scale1 = 1\n        pixel_size_scale.append(pixel_size_scale1)\n\n        if translation_um is not None:\n            translation1 = translation_um.get(dim, 0)\n            # translation_pyramid = translation + (scale - 1) * pixel_size / 2\n            if dim in 'xy':\n                translation1 += (factor - 1) * pixel_size_um[dim] / 2\n            translation_scale.append(translation1)\n\n    metadata.append({'type': 'scale', 'scale': pixel_size_scale})\n    if translation_um is not None:\n        metadata.append({'type': 'translation', 'translation': translation_scale})\n    return metadata\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.rgba_to_hexrgb","title":"<code>rgba_to_hexrgb(rgba)</code>","text":"Source code in <code>src/color_conversion.py</code> <pre><code>def rgba_to_hexrgb(rgba: list) -&gt; str:\n    hexrgb = ''.join([hex(int(x * 255))[2:].upper().zfill(2) for x in rgba[:3]])\n    return hexrgb\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.scale_dimensions_dict","title":"<code>scale_dimensions_dict(shape0, scale)</code>","text":"<p>Scale x and y dimensions in a shape dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>shape0</code> <code>dict</code> <p>Original shape dictionary.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Scaled shape dictionary.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def scale_dimensions_dict(shape0, scale):\n    \"\"\"\n    Scale x and y dimensions in a shape dictionary.\n\n    Args:\n        shape0 (dict): Original shape dictionary.\n        scale (float): Scaling factor.\n\n    Returns:\n        dict: Scaled shape dictionary.\n    \"\"\"\n    shape = {}\n    if scale == 1:\n        return shape0\n    for dimension, shape1 in shape0.items():\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape[dimension] = shape1\n    return shape\n</code></pre>"},{"location":"references/#src.OmeZarrWriter.scale_dimensions_xy","title":"<code>scale_dimensions_xy(shape0, dimension_order, scale)</code>","text":"<p>Scale x and y dimensions in a shape tuple.</p> <p>Parameters:</p> Name Type Description Default <code>shape0</code> <code>tuple</code> <p>Original shape.</p> required <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Scaled shape.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def scale_dimensions_xy(shape0, dimension_order, scale):\n    \"\"\"\n    Scale x and y dimensions in a shape tuple.\n\n    Args:\n        shape0 (tuple): Original shape.\n        dimension_order (str): String of dimension characters.\n        scale (float): Scaling factor.\n\n    Returns:\n        list: Scaled shape.\n    \"\"\"\n    shape = []\n    if scale == 1:\n        return shape0\n    for shape1, dimension in zip(shape0, dimension_order):\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape.append(shape1)\n    return shape\n</code></pre>"},{"location":"references/#src.TiffSource","title":"<code>TiffSource</code>","text":""},{"location":"references/#src.TiffSource.TiffSource","title":"<code>TiffSource</code>","text":"<p>               Bases: <code>ImageSource</code></p> <p>Loads image and metadata from TIFF or OME-TIFF files.</p> Source code in <code>src/TiffSource.py</code> <pre><code>class TiffSource(ImageSource):\n    \"\"\"\n    Loads image and metadata from TIFF or OME-TIFF files.\n    \"\"\"\n    def __init__(self, uri, metadata={}):\n        \"\"\"\n        Initialize TiffSource.\n\n        Args:\n            uri (str): Path to the TIFF file.\n            metadata (dict): Optional metadata dictionary.\n        \"\"\"\n        super().__init__(uri, metadata)\n        image_filename = None\n        ext = os.path.splitext(uri)[1].lower()\n        if 'tif' in ext:\n            image_filename = uri\n        elif 'ome' in ext:\n            # read metadata\n            with open(uri, 'rb') as file:\n                self.metadata = metadata_to_dict(file.read().decode())\n            # try to open a ome-tiff file\n            self.image_filenames = {}\n            for image in ensure_list(self.metadata.get('Image', {})):\n                filename = image.get('Pixels', {}).get('TiffData', {}).get('UUID', {}).get('FileName')\n                if filename:\n                    filepath = os.path.join(os.path.dirname(uri), filename)\n                    self.image_filenames[image['ID']] = filepath\n                    if image_filename is None:\n                        image_filename = filepath\n        else:\n            raise RuntimeError(f'Unsupported tiff extension: {ext}')\n\n        self.tiff = TiffFile(image_filename)\n\n    def init_metadata(self):\n        self.is_ome = self.tiff.is_ome\n        self.is_imagej = self.tiff.is_imagej\n        pixel_size = {}\n        position = {}\n        channels = []\n\n        if self.tiff.series:\n            pages = self.tiff.series\n            page = pages[0]\n        else:\n            pages = self.tiff.pages\n            page = self.tiff.pages.first\n        if hasattr(page, 'levels'):\n            pages = page.levels\n        self.shapes = [page.shape for page in pages]\n        self.shape = page.shape\n        self.dim_order = page.axes.lower().replace('s', 'c').replace('r', '')\n        x_index, y_index = self.dim_order.index('x'), self.dim_order.index('y')\n        self.scales = [float(np.mean([shape[x_index] / self.shape[x_index], shape[y_index] / self.shape[y_index]]))\n                       for shape in self.shapes]\n        self.is_photometric_rgb = (self.tiff.pages.first.photometric == PHOTOMETRIC.RGB)\n        self.nchannels = self.shape[self.dim_order.index('c')] if 'c' in self.dim_order else 1\n\n        if self.is_ome:\n            metadata = metadata_to_dict(self.tiff.ome_metadata)\n            if metadata and not 'BinaryOnly' in metadata:\n                self.metadata = metadata\n            image0 = ensure_list(self.metadata.get('Image', []))[0]\n            self.is_plate = 'Plate' in self.metadata\n            if self.is_plate:\n                plate = self.metadata['Plate']\n                name = plate.get('Name')\n                rows = set()\n                columns = set()\n                wells = {}\n                fields = []\n                image_refs = {}\n                for well in ensure_list(plate['Well']):\n                    row = create_row_col_label(well['Row'], plate['RowNamingConvention'])\n                    column = create_row_col_label(well['Column'], plate['ColumnNamingConvention'])\n                    rows.add(row)\n                    columns.add(column)\n                    label = f'{row}{column}'\n                    wells[label] = well['ID']\n                    image_refs[label] = {}\n                    for sample in ensure_list(well.get('WellSample')):\n                        index = sample.get('Index', 0)\n                        image_refs[label][str(index)] = sample['ImageRef']['ID']\n                        if index not in fields:\n                            fields.append(index)\n                self.rows = sorted(rows)\n                self.columns = list(columns)\n                self.wells = list(wells.keys())\n                self.fields = fields\n                self.image_refs = image_refs\n            else:\n                name = image0.get('Name')\n            if not name:\n                name = get_filetitle(self.uri)\n            self.acquisition_datetime = image0.get('AcquisitionDate')\n            pixels = image0.get('Pixels', {})\n            self.dtype = np.dtype(pixels['Type'])\n            if 'PhysicalSizeX' in pixels:\n                pixel_size['x'] = convert_to_um(float(pixels.get('PhysicalSizeX')), pixels.get('PhysicalSizeXUnit'))\n            if 'PhysicalSizeY' in pixels:\n                pixel_size['y'] = convert_to_um(float(pixels.get('PhysicalSizeY')), pixels.get('PhysicalSizeYUnit'))\n            if 'PhysicalSizeZ' in pixels:\n                pixel_size['z'] = convert_to_um(float(pixels.get('PhysicalSizeZ')), pixels.get('PhysicalSizeZUnit'))\n            plane = pixels.get('Plane')\n            if plane:\n                if 'PositionX' in plane:\n                    position['x'] = convert_to_um(float(plane.get('PositionX')), plane.get('PositionXUnit'))\n                if 'PositionY' in plane:\n                    position['y'] = convert_to_um(float(plane.get('PositionY')), plane.get('PositionYUnit'))\n                if 'PositionZ' in plane:\n                    position['z'] = convert_to_um(float(plane.get('PositionZ')), plane.get('PositionZUnit'))\n            for channel0 in ensure_list(pixels.get('Channel')):\n                channel = {}\n                if 'Name' in channel0:\n                    channel['label'] = channel0['Name']\n                if 'Color' in channel0:\n                    channel['color'] = int_to_rgba(channel0['Color'])\n                channels.append(channel)\n            if 'SignificantBits' in pixels:\n                self.bits_per_pixel = int(pixels['SignificantBits'])\n            else:\n                self.bits_per_pixel = self.dtype.itemsize * 8\n        else:\n            self.is_plate = False\n            if self.is_imagej:\n                self.imagej_metadata = self.tiff.imagej_metadata\n                pixel_size_unit = self.imagej_metadata.get('unit', '').encode().decode('unicode_escape')\n                if 'scales' in self.imagej_metadata:\n                    for dim, scale in zip(['x', 'y'], self.imagej_metadata['scales'].split(',')):\n                        scale = scale.strip()\n                        if scale != '':\n                            pixel_size[dim] = convert_to_um(float(scale), pixel_size_unit)\n                if 'spacing' in self.imagej_metadata:\n                    pixel_size['z'] = convert_to_um(self.imagej_metadata['spacing'], pixel_size_unit)\n            self.metadata = tags_to_dict(self.tiff.pages.first.tags)\n            name = os.path.splitext(self.tiff.filename)[0]\n            if 'DateTime' in self.metadata:\n                self.acquisition_datetime = datetime.strptime(self.metadata['DateTime'],'%Y:%m:%d %H:%M:%S')\n            else:\n                self.acquisition_datetime = datetime.fromtimestamp(self.tiff.fstat.st_ctime)\n            self.dtype = page.dtype\n            self.bits_per_pixel = self.dtype.itemsize * 8\n            res_unit = self.metadata.get('ResolutionUnit', '')\n            if isinstance(res_unit, Enum):\n                res_unit = res_unit.name\n            res_unit = res_unit.lower()\n            if res_unit == 'none':\n                res_unit = ''\n            if 'x' not in pixel_size:\n                res0 = convert_rational_value(self.metadata.get('XResolution'))\n                if res0 is not None and res0 != 0:\n                    pixel_size['x'] = convert_to_um(1 / res0, res_unit)\n            if 'y' not in pixel_size:\n                res0 = convert_rational_value(self.metadata.get('YResolution'))\n                if res0 is not None and res0 != 0:\n                    pixel_size['y'] = convert_to_um(1 / res0, res_unit)\n        self.name = str(name).rstrip('.tiff').rstrip('.tif').rstrip('.ome')\n        self.pixel_size = pixel_size\n        self.position = position\n        self.channels = channels\n        return self.metadata\n\n    def is_screen(self):\n        return self.is_plate\n\n    def get_shape(self):\n        return self.shape\n\n    def get_shapes(self):\n        return self.shapes\n\n    def get_scales(self):\n        return self.scales\n\n    def get_data(self, dim_order, level=0, well_id=None, field_id=None, **kwargs):\n        if well_id is not None:\n            index = self.image_refs[well_id][str(field_id)]\n            tiff = TiffFile(self.image_filenames[index])\n        else:\n            tiff = self.tiff\n        data = tiff.asarray(level=level)\n        return redimension_data(data, self.dim_order, dim_order)\n\n    def get_data_as_dask(self, dim_order, level=0, **kwargs):\n        #lazy_array = dask.delayed(imread)(self.uri, level=level)\n        #data = da.from_delayed(lazy_array, shape=self.shapes[level], dtype=self.dtype)\n        data = da.from_zarr(imread(self.uri, level=level, aszarr=True))\n        if data.chunksize == data.shape:\n            data = data.rechunk(TILE_SIZE)\n        return redimension_data(data, self.dim_order, dim_order)\n\n    def get_name(self):\n        return self.name\n\n    def get_dim_order(self):\n        return self.dim_order\n\n    def get_dtype(self):\n        return self.dtype\n\n    def get_pixel_size_um(self):\n        if self.pixel_size:\n            return self.pixel_size\n        else:\n            return {'x': 1, 'y': 1}\n\n    def get_position_um(self, well_id=None):\n        return self.position\n\n    def get_channels(self):\n        return self.channels\n\n    def get_nchannels(self):\n        return self.nchannels\n\n    def is_rgb(self):\n        return self.is_photometric_rgb\n\n    def get_rows(self):\n        return self.rows\n\n    def get_columns(self):\n        return self.columns\n\n    def get_wells(self):\n        return self.wells\n\n    def get_time_points(self):\n        nt = 1\n        if 't' in self.dim_order:\n            t_index = self.dim_order.index('t')\n            nt = self.tiff.pages.first.shape[t_index]\n        return list(range(nt))\n\n    def get_fields(self):\n        return self.fields\n\n    def get_acquisitions(self):\n        return []\n\n    def get_acquisition_datetime(self):\n        return self.acquisition_datetime\n\n    def get_significant_bits(self):\n        return self.bits_per_pixel\n\n    def close(self):\n        self.tiff.close()\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.image_filenames","title":"<code>image_filenames = {}</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.TiffSource.TiffSource.metadata","title":"<code>metadata = metadata_to_dict(file.read().decode())</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.TiffSource.TiffSource.tiff","title":"<code>tiff = TiffFile(image_filename)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.TiffSource.TiffSource.__init__","title":"<code>__init__(uri, metadata={})</code>","text":"<p>Initialize TiffSource.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>Path to the TIFF file.</p> required <code>metadata</code> <code>dict</code> <p>Optional metadata dictionary.</p> <code>{}</code> Source code in <code>src/TiffSource.py</code> <pre><code>def __init__(self, uri, metadata={}):\n    \"\"\"\n    Initialize TiffSource.\n\n    Args:\n        uri (str): Path to the TIFF file.\n        metadata (dict): Optional metadata dictionary.\n    \"\"\"\n    super().__init__(uri, metadata)\n    image_filename = None\n    ext = os.path.splitext(uri)[1].lower()\n    if 'tif' in ext:\n        image_filename = uri\n    elif 'ome' in ext:\n        # read metadata\n        with open(uri, 'rb') as file:\n            self.metadata = metadata_to_dict(file.read().decode())\n        # try to open a ome-tiff file\n        self.image_filenames = {}\n        for image in ensure_list(self.metadata.get('Image', {})):\n            filename = image.get('Pixels', {}).get('TiffData', {}).get('UUID', {}).get('FileName')\n            if filename:\n                filepath = os.path.join(os.path.dirname(uri), filename)\n                self.image_filenames[image['ID']] = filepath\n                if image_filename is None:\n                    image_filename = filepath\n    else:\n        raise RuntimeError(f'Unsupported tiff extension: {ext}')\n\n    self.tiff = TiffFile(image_filename)\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.close","title":"<code>close()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def close(self):\n    self.tiff.close()\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_acquisition_datetime","title":"<code>get_acquisition_datetime()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_acquisition_datetime(self):\n    return self.acquisition_datetime\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_acquisitions","title":"<code>get_acquisitions()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_acquisitions(self):\n    return []\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_channels","title":"<code>get_channels()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_channels(self):\n    return self.channels\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_columns","title":"<code>get_columns()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_columns(self):\n    return self.columns\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_data","title":"<code>get_data(dim_order, level=0, well_id=None, field_id=None, **kwargs)</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_data(self, dim_order, level=0, well_id=None, field_id=None, **kwargs):\n    if well_id is not None:\n        index = self.image_refs[well_id][str(field_id)]\n        tiff = TiffFile(self.image_filenames[index])\n    else:\n        tiff = self.tiff\n    data = tiff.asarray(level=level)\n    return redimension_data(data, self.dim_order, dim_order)\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_data_as_dask","title":"<code>get_data_as_dask(dim_order, level=0, **kwargs)</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_data_as_dask(self, dim_order, level=0, **kwargs):\n    #lazy_array = dask.delayed(imread)(self.uri, level=level)\n    #data = da.from_delayed(lazy_array, shape=self.shapes[level], dtype=self.dtype)\n    data = da.from_zarr(imread(self.uri, level=level, aszarr=True))\n    if data.chunksize == data.shape:\n        data = data.rechunk(TILE_SIZE)\n    return redimension_data(data, self.dim_order, dim_order)\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_dim_order","title":"<code>get_dim_order()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_dim_order(self):\n    return self.dim_order\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_dtype","title":"<code>get_dtype()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_dtype(self):\n    return self.dtype\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_fields","title":"<code>get_fields()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_fields(self):\n    return self.fields\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_name","title":"<code>get_name()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_name(self):\n    return self.name\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_nchannels(self):\n    return self.nchannels\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_pixel_size_um","title":"<code>get_pixel_size_um()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_pixel_size_um(self):\n    if self.pixel_size:\n        return self.pixel_size\n    else:\n        return {'x': 1, 'y': 1}\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_position_um","title":"<code>get_position_um(well_id=None)</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_position_um(self, well_id=None):\n    return self.position\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_rows","title":"<code>get_rows()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_rows(self):\n    return self.rows\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_scales","title":"<code>get_scales()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_scales(self):\n    return self.scales\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_shape","title":"<code>get_shape()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_shape(self):\n    return self.shape\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_shapes","title":"<code>get_shapes()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_shapes(self):\n    return self.shapes\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_significant_bits","title":"<code>get_significant_bits()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_significant_bits(self):\n    return self.bits_per_pixel\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_time_points","title":"<code>get_time_points()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_time_points(self):\n    nt = 1\n    if 't' in self.dim_order:\n        t_index = self.dim_order.index('t')\n        nt = self.tiff.pages.first.shape[t_index]\n    return list(range(nt))\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.get_wells","title":"<code>get_wells()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def get_wells(self):\n    return self.wells\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.init_metadata","title":"<code>init_metadata()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def init_metadata(self):\n    self.is_ome = self.tiff.is_ome\n    self.is_imagej = self.tiff.is_imagej\n    pixel_size = {}\n    position = {}\n    channels = []\n\n    if self.tiff.series:\n        pages = self.tiff.series\n        page = pages[0]\n    else:\n        pages = self.tiff.pages\n        page = self.tiff.pages.first\n    if hasattr(page, 'levels'):\n        pages = page.levels\n    self.shapes = [page.shape for page in pages]\n    self.shape = page.shape\n    self.dim_order = page.axes.lower().replace('s', 'c').replace('r', '')\n    x_index, y_index = self.dim_order.index('x'), self.dim_order.index('y')\n    self.scales = [float(np.mean([shape[x_index] / self.shape[x_index], shape[y_index] / self.shape[y_index]]))\n                   for shape in self.shapes]\n    self.is_photometric_rgb = (self.tiff.pages.first.photometric == PHOTOMETRIC.RGB)\n    self.nchannels = self.shape[self.dim_order.index('c')] if 'c' in self.dim_order else 1\n\n    if self.is_ome:\n        metadata = metadata_to_dict(self.tiff.ome_metadata)\n        if metadata and not 'BinaryOnly' in metadata:\n            self.metadata = metadata\n        image0 = ensure_list(self.metadata.get('Image', []))[0]\n        self.is_plate = 'Plate' in self.metadata\n        if self.is_plate:\n            plate = self.metadata['Plate']\n            name = plate.get('Name')\n            rows = set()\n            columns = set()\n            wells = {}\n            fields = []\n            image_refs = {}\n            for well in ensure_list(plate['Well']):\n                row = create_row_col_label(well['Row'], plate['RowNamingConvention'])\n                column = create_row_col_label(well['Column'], plate['ColumnNamingConvention'])\n                rows.add(row)\n                columns.add(column)\n                label = f'{row}{column}'\n                wells[label] = well['ID']\n                image_refs[label] = {}\n                for sample in ensure_list(well.get('WellSample')):\n                    index = sample.get('Index', 0)\n                    image_refs[label][str(index)] = sample['ImageRef']['ID']\n                    if index not in fields:\n                        fields.append(index)\n            self.rows = sorted(rows)\n            self.columns = list(columns)\n            self.wells = list(wells.keys())\n            self.fields = fields\n            self.image_refs = image_refs\n        else:\n            name = image0.get('Name')\n        if not name:\n            name = get_filetitle(self.uri)\n        self.acquisition_datetime = image0.get('AcquisitionDate')\n        pixels = image0.get('Pixels', {})\n        self.dtype = np.dtype(pixels['Type'])\n        if 'PhysicalSizeX' in pixels:\n            pixel_size['x'] = convert_to_um(float(pixels.get('PhysicalSizeX')), pixels.get('PhysicalSizeXUnit'))\n        if 'PhysicalSizeY' in pixels:\n            pixel_size['y'] = convert_to_um(float(pixels.get('PhysicalSizeY')), pixels.get('PhysicalSizeYUnit'))\n        if 'PhysicalSizeZ' in pixels:\n            pixel_size['z'] = convert_to_um(float(pixels.get('PhysicalSizeZ')), pixels.get('PhysicalSizeZUnit'))\n        plane = pixels.get('Plane')\n        if plane:\n            if 'PositionX' in plane:\n                position['x'] = convert_to_um(float(plane.get('PositionX')), plane.get('PositionXUnit'))\n            if 'PositionY' in plane:\n                position['y'] = convert_to_um(float(plane.get('PositionY')), plane.get('PositionYUnit'))\n            if 'PositionZ' in plane:\n                position['z'] = convert_to_um(float(plane.get('PositionZ')), plane.get('PositionZUnit'))\n        for channel0 in ensure_list(pixels.get('Channel')):\n            channel = {}\n            if 'Name' in channel0:\n                channel['label'] = channel0['Name']\n            if 'Color' in channel0:\n                channel['color'] = int_to_rgba(channel0['Color'])\n            channels.append(channel)\n        if 'SignificantBits' in pixels:\n            self.bits_per_pixel = int(pixels['SignificantBits'])\n        else:\n            self.bits_per_pixel = self.dtype.itemsize * 8\n    else:\n        self.is_plate = False\n        if self.is_imagej:\n            self.imagej_metadata = self.tiff.imagej_metadata\n            pixel_size_unit = self.imagej_metadata.get('unit', '').encode().decode('unicode_escape')\n            if 'scales' in self.imagej_metadata:\n                for dim, scale in zip(['x', 'y'], self.imagej_metadata['scales'].split(',')):\n                    scale = scale.strip()\n                    if scale != '':\n                        pixel_size[dim] = convert_to_um(float(scale), pixel_size_unit)\n            if 'spacing' in self.imagej_metadata:\n                pixel_size['z'] = convert_to_um(self.imagej_metadata['spacing'], pixel_size_unit)\n        self.metadata = tags_to_dict(self.tiff.pages.first.tags)\n        name = os.path.splitext(self.tiff.filename)[0]\n        if 'DateTime' in self.metadata:\n            self.acquisition_datetime = datetime.strptime(self.metadata['DateTime'],'%Y:%m:%d %H:%M:%S')\n        else:\n            self.acquisition_datetime = datetime.fromtimestamp(self.tiff.fstat.st_ctime)\n        self.dtype = page.dtype\n        self.bits_per_pixel = self.dtype.itemsize * 8\n        res_unit = self.metadata.get('ResolutionUnit', '')\n        if isinstance(res_unit, Enum):\n            res_unit = res_unit.name\n        res_unit = res_unit.lower()\n        if res_unit == 'none':\n            res_unit = ''\n        if 'x' not in pixel_size:\n            res0 = convert_rational_value(self.metadata.get('XResolution'))\n            if res0 is not None and res0 != 0:\n                pixel_size['x'] = convert_to_um(1 / res0, res_unit)\n        if 'y' not in pixel_size:\n            res0 = convert_rational_value(self.metadata.get('YResolution'))\n            if res0 is not None and res0 != 0:\n                pixel_size['y'] = convert_to_um(1 / res0, res_unit)\n    self.name = str(name).rstrip('.tiff').rstrip('.tif').rstrip('.ome')\n    self.pixel_size = pixel_size\n    self.position = position\n    self.channels = channels\n    return self.metadata\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.is_rgb","title":"<code>is_rgb()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def is_rgb(self):\n    return self.is_photometric_rgb\n</code></pre>"},{"location":"references/#src.TiffSource.TiffSource.is_screen","title":"<code>is_screen()</code>","text":"Source code in <code>src/TiffSource.py</code> <pre><code>def is_screen(self):\n    return self.is_plate\n</code></pre>"},{"location":"references/#src.TiffSource.convert_rational_value","title":"<code>convert_rational_value(value)</code>","text":"<p>Converts a rational value tuple to a float.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple or None</code> <p>Rational value.</p> required <p>Returns:</p> Type Description <p>float or None: Converted value.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def convert_rational_value(value):\n    \"\"\"\n    Converts a rational value tuple to a float.\n\n    Args:\n        value (tuple or None): Rational value.\n\n    Returns:\n        float or None: Converted value.\n    \"\"\"\n    if value is not None and isinstance(value, tuple):\n        if value[0] == value[1]:\n            value = value[0]\n        else:\n            value = value[0] / value[1]\n    return value\n</code></pre>"},{"location":"references/#src.TiffSource.tags_to_dict","title":"<code>tags_to_dict(tags)</code>","text":"<p>Converts TIFF tags to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>tags</code> <p>TIFF tags object.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Tag name-value mapping.</p> Source code in <code>src/TiffSource.py</code> <pre><code>def tags_to_dict(tags):\n    \"\"\"\n    Converts TIFF tags to a dictionary.\n\n    Args:\n        tags: TIFF tags object.\n\n    Returns:\n        dict: Tag name-value mapping.\n    \"\"\"\n    tag_dict = {}\n    for tag in tags.values():\n        tag_dict[tag.name] = tag.value\n    return tag_dict\n</code></pre>"},{"location":"references/#src.Timer","title":"<code>Timer</code>","text":""},{"location":"references/#src.Timer.Timer","title":"<code>Timer</code>","text":"<p>               Bases: <code>object</code></p> <p>Context manager for timing code execution and logging the elapsed time.</p> Source code in <code>src/Timer.py</code> <pre><code>class Timer(object):\n    \"\"\"\n    Context manager for timing code execution and logging the elapsed time.\n    \"\"\"\n\n    def __init__(self, title, auto_unit=True, verbose=True):\n        \"\"\"\n        Initialize the Timer.\n\n        Args:\n            title (str): Description for the timed block.\n            auto_unit (bool): Automatically select time unit (seconds/minutes/hours).\n            verbose (bool): If True, log the elapsed time.\n        \"\"\"\n        self.title = title\n        self.auto_unit = auto_unit\n        self.verbose = verbose\n\n    def __enter__(self):\n        \"\"\"\n        Start timing.\n        \"\"\"\n        self.ptime_start = time.process_time()\n        self.time_start = time.time()\n\n    def __exit__(self, type, value, traceback):\n        \"\"\"\n        Stop timing and log the elapsed time.\n\n        Args:\n            type: Exception type, if any.\n            value: Exception value, if any.\n            traceback: Exception traceback, if any.\n        \"\"\"\n        if self.verbose:\n            ptime_end = time.process_time()\n            time_end = time.time()\n            pelapsed = ptime_end - self.ptime_start\n            elapsed = time_end - self.time_start\n            unit = 'seconds'\n            if self.auto_unit and elapsed &gt;= 60:\n                pelapsed /= 60\n                elapsed /= 60\n                unit = 'minutes'\n                if elapsed &gt;= 60:\n                    pelapsed /= 60\n                    elapsed /= 60\n                    unit = 'hours'\n            logging.info(f'Time {self.title}: {elapsed:.1f} ({pelapsed:.1f}) {unit}')\n</code></pre>"},{"location":"references/#src.Timer.Timer.auto_unit","title":"<code>auto_unit = auto_unit</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.Timer.Timer.title","title":"<code>title = title</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.Timer.Timer.verbose","title":"<code>verbose = verbose</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.Timer.Timer.__enter__","title":"<code>__enter__()</code>","text":"<p>Start timing.</p> Source code in <code>src/Timer.py</code> <pre><code>def __enter__(self):\n    \"\"\"\n    Start timing.\n    \"\"\"\n    self.ptime_start = time.process_time()\n    self.time_start = time.time()\n</code></pre>"},{"location":"references/#src.Timer.Timer.__exit__","title":"<code>__exit__(type, value, traceback)</code>","text":"<p>Stop timing and log the elapsed time.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <p>Exception type, if any.</p> required <code>value</code> <p>Exception value, if any.</p> required <code>traceback</code> <p>Exception traceback, if any.</p> required Source code in <code>src/Timer.py</code> <pre><code>def __exit__(self, type, value, traceback):\n    \"\"\"\n    Stop timing and log the elapsed time.\n\n    Args:\n        type: Exception type, if any.\n        value: Exception value, if any.\n        traceback: Exception traceback, if any.\n    \"\"\"\n    if self.verbose:\n        ptime_end = time.process_time()\n        time_end = time.time()\n        pelapsed = ptime_end - self.ptime_start\n        elapsed = time_end - self.time_start\n        unit = 'seconds'\n        if self.auto_unit and elapsed &gt;= 60:\n            pelapsed /= 60\n            elapsed /= 60\n            unit = 'minutes'\n            if elapsed &gt;= 60:\n                pelapsed /= 60\n                elapsed /= 60\n                unit = 'hours'\n        logging.info(f'Time {self.title}: {elapsed:.1f} ({pelapsed:.1f}) {unit}')\n</code></pre>"},{"location":"references/#src.Timer.Timer.__init__","title":"<code>__init__(title, auto_unit=True, verbose=True)</code>","text":"<p>Initialize the Timer.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Description for the timed block.</p> required <code>auto_unit</code> <code>bool</code> <p>Automatically select time unit (seconds/minutes/hours).</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>If True, log the elapsed time.</p> <code>True</code> Source code in <code>src/Timer.py</code> <pre><code>def __init__(self, title, auto_unit=True, verbose=True):\n    \"\"\"\n    Initialize the Timer.\n\n    Args:\n        title (str): Description for the timed block.\n        auto_unit (bool): Automatically select time unit (seconds/minutes/hours).\n        verbose (bool): If True, log the elapsed time.\n    \"\"\"\n    self.title = title\n    self.auto_unit = auto_unit\n    self.verbose = verbose\n</code></pre>"},{"location":"references/#src.WindowScanner","title":"<code>WindowScanner</code>","text":""},{"location":"references/#src.WindowScanner.WindowScanner","title":"<code>WindowScanner</code>","text":"<p>Computes quantile-based min/max window for image channels.</p> Source code in <code>src/WindowScanner.py</code> <pre><code>class WindowScanner:\n    \"\"\"\n    Computes quantile-based min/max window for image channels.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize WindowScanner.\n        \"\"\"\n        self.mins = []\n        self.maxs = []\n\n    def process(self, data, dim_order, min_quantile=0.01, max_quantile=0.99):\n        \"\"\"\n        Processes image data to compute min/max quantiles for each channel.\n\n        Args:\n            data (ndarray): Image data.\n            dim_order (str): Dimension order string.\n            min_quantile (float): Lower quantile.\n            max_quantile (float): Upper quantile.\n        \"\"\"\n        axis = []\n        if 't' in dim_order:\n            axis += [dim_order.index('t')]\n        if 'z' in dim_order:\n            axis += [dim_order.index('z')]\n        axis += [dim_order.index('y'), dim_order.index('x')]\n        values = np.quantile(data, axis=axis, q=[min_quantile, max_quantile])\n        mins, maxs = values\n        if len(self.mins) == 0:\n            self.mins = mins\n            self.maxs = maxs\n        else:\n            self.mins = np.min([mins, self.mins], axis=0)\n            self.maxs = np.max([maxs, self.maxs], axis=0)\n\n    def get_window(self):\n        \"\"\"\n        Returns the computed min/max window for channels.\n\n        Returns:\n            tuple: (min dict, max dict)\n        \"\"\"\n        return ensure_list(np.array(self.mins).tolist()), ensure_list(np.array(self.maxs).tolist())\n</code></pre>"},{"location":"references/#src.WindowScanner.WindowScanner.maxs","title":"<code>maxs = []</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.WindowScanner.WindowScanner.mins","title":"<code>mins = []</code>  <code>instance-attribute</code>","text":""},{"location":"references/#src.WindowScanner.WindowScanner.__init__","title":"<code>__init__()</code>","text":"<p>Initialize WindowScanner.</p> Source code in <code>src/WindowScanner.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize WindowScanner.\n    \"\"\"\n    self.mins = []\n    self.maxs = []\n</code></pre>"},{"location":"references/#src.WindowScanner.WindowScanner.get_window","title":"<code>get_window()</code>","text":"<p>Returns the computed min/max window for channels.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(min dict, max dict)</p> Source code in <code>src/WindowScanner.py</code> <pre><code>def get_window(self):\n    \"\"\"\n    Returns the computed min/max window for channels.\n\n    Returns:\n        tuple: (min dict, max dict)\n    \"\"\"\n    return ensure_list(np.array(self.mins).tolist()), ensure_list(np.array(self.maxs).tolist())\n</code></pre>"},{"location":"references/#src.WindowScanner.WindowScanner.process","title":"<code>process(data, dim_order, min_quantile=0.01, max_quantile=0.99)</code>","text":"<p>Processes image data to compute min/max quantiles for each channel.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Image data.</p> required <code>dim_order</code> <code>str</code> <p>Dimension order string.</p> required <code>min_quantile</code> <code>float</code> <p>Lower quantile.</p> <code>0.01</code> <code>max_quantile</code> <code>float</code> <p>Upper quantile.</p> <code>0.99</code> Source code in <code>src/WindowScanner.py</code> <pre><code>def process(self, data, dim_order, min_quantile=0.01, max_quantile=0.99):\n    \"\"\"\n    Processes image data to compute min/max quantiles for each channel.\n\n    Args:\n        data (ndarray): Image data.\n        dim_order (str): Dimension order string.\n        min_quantile (float): Lower quantile.\n        max_quantile (float): Upper quantile.\n    \"\"\"\n    axis = []\n    if 't' in dim_order:\n        axis += [dim_order.index('t')]\n    if 'z' in dim_order:\n        axis += [dim_order.index('z')]\n    axis += [dim_order.index('y'), dim_order.index('x')]\n    values = np.quantile(data, axis=axis, q=[min_quantile, max_quantile])\n    mins, maxs = values\n    if len(self.mins) == 0:\n        self.mins = mins\n        self.maxs = maxs\n    else:\n        self.mins = np.min([mins, self.mins], axis=0)\n        self.maxs = np.max([maxs, self.maxs], axis=0)\n</code></pre>"},{"location":"references/#src.color_conversion","title":"<code>color_conversion</code>","text":""},{"location":"references/#src.color_conversion.hexrgb_to_rgba","title":"<code>hexrgb_to_rgba(hexrgb)</code>","text":"Source code in <code>src/color_conversion.py</code> <pre><code>def hexrgb_to_rgba(hexrgb: str) -&gt; list:\n    hexrgb = hexrgb.lstrip('#')\n    if len(hexrgb) == 6:\n        hexrgb += 'FF'  # add alpha\n    rgba = int_to_rgba(eval('0x' + hexrgb))\n    return rgba\n</code></pre>"},{"location":"references/#src.color_conversion.int_to_rgba","title":"<code>int_to_rgba(intrgba)</code>","text":"Source code in <code>src/color_conversion.py</code> <pre><code>def int_to_rgba(intrgba: int) -&gt; list:\n    signed = (intrgba &lt; 0)\n    rgba = [x / 255 for x in intrgba.to_bytes(4, signed=signed, byteorder=\"big\")]\n    if rgba[-1] == 0:\n        rgba[-1] = 1\n    return rgba\n</code></pre>"},{"location":"references/#src.color_conversion.rgba_to_hexrgb","title":"<code>rgba_to_hexrgb(rgba)</code>","text":"Source code in <code>src/color_conversion.py</code> <pre><code>def rgba_to_hexrgb(rgba: list) -&gt; str:\n    hexrgb = ''.join([hex(int(x * 255))[2:].upper().zfill(2) for x in rgba[:3]])\n    return hexrgb\n</code></pre>"},{"location":"references/#src.color_conversion.rgba_to_int","title":"<code>rgba_to_int(rgba)</code>","text":"Source code in <code>src/color_conversion.py</code> <pre><code>def rgba_to_int(rgba: list) -&gt; int:\n    intrgba = int.from_bytes([int(x * 255) for x in rgba], signed=True, byteorder=\"big\")\n    return intrgba\n</code></pre>"},{"location":"references/#src.helper","title":"<code>helper</code>","text":""},{"location":"references/#src.helper.create_incucyte_source","title":"<code>create_incucyte_source(filename, plate_id=None)</code>","text":"<p>Create an IncucyteSource object for a specific plate.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the Incucyte archive folder or .icarch file.</p> required <code>plate_id</code> <code>str</code> <p>Specific plate ID to process. If None,                      uses the first available plate if multiple                      plates exist.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>IncucyteSource</code> <p>Source object for the specified plate.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path is not a valid Incucyte archive.</p> Source code in <code>src/helper.py</code> <pre><code>def create_incucyte_source(filename, plate_id=None):\n    \"\"\"\n    Create an IncucyteSource object for a specific plate.\n\n    Args:\n        filename (str): Path to the Incucyte archive folder or .icarch file.\n        plate_id (str, optional): Specific plate ID to process. If None,\n                                 uses the first available plate if multiple\n                                 plates exist.\n\n    Returns:\n        IncucyteSource: Source object for the specified plate.\n\n    Raises:\n        ValueError: If the path is not a valid Incucyte archive.\n    \"\"\"\n    # If it's an .icarch file, use its parent folder\n    if os.path.isfile(filename) and filename.lower().endswith('.icarch'):\n        archive_folder = os.path.dirname(filename)\n    elif os.path.isdir(filename):\n        archive_folder = filename\n    else:\n        raise ValueError(\n            f'Invalid Incucyte archive path. Expected folder or .icarch '\n            f'file: {filename}'\n        )\n\n    from src.IncucyteSource import IncucyteSource\n    return IncucyteSource(archive_folder, plate_id=plate_id)\n</code></pre>"},{"location":"references/#src.helper.create_source","title":"<code>create_source(filename, **kwargs)</code>","text":"<p>Create an image source object based on the input file extension.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the input file or Incucyte .icarch file.</p> required <code>**kwargs</code> <p>Source-specific parameters (e.g., plate_id for Incucyte).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ImageSource</code> <p>Source object for the input file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file format is unsupported.</p> Source code in <code>src/helper.py</code> <pre><code>def create_source(filename, **kwargs):\n    \"\"\"\n    Create an image source object based on the input file extension.\n\n    Args:\n        filename (str): Path to the input file or Incucyte .icarch file.\n        **kwargs: Source-specific parameters (e.g., plate_id for Incucyte).\n\n    Returns:\n        ImageSource: Source object for the input file.\n\n    Raises:\n        ValueError: If the file format is unsupported.\n    \"\"\"\n    input_ext = os.path.splitext(filename)[1].lower()\n\n    if input_ext == '.db':\n        from src.ImageDbSource import ImageDbSource\n        source = ImageDbSource(filename)\n    elif input_ext == '.icarch':\n        # Incucyte archive file - use parent folder for source\n        if not os.path.isfile(filename):\n            raise ValueError(\n                f'Incucyte archive file not found: {filename}'\n            )\n        archive_folder = os.path.dirname(filename)\n        # Verify EssenFiles folder exists\n        essen_path = os.path.join(archive_folder, 'EssenFiles')\n        if not os.path.isdir(essen_path):\n            raise ValueError(\n                f'EssenFiles folder not found in: {archive_folder}. '\n                f'Expected Incucyte archive structure.'\n            )\n        from src.IncucyteSource import IncucyteSource\n        # Pass kwargs to IncucyteSource (e.g., plate_id)\n        source = IncucyteSource(archive_folder, **kwargs)\n    elif input_ext == '.isyntax':\n        from src.ISyntaxSource import ISyntaxSource\n        source = ISyntaxSource(filename)\n    elif input_ext == '.mrxs':\n        from src.MiraxSource import MiraxSource\n        source = MiraxSource(filename)\n    elif input_ext in ['.dcm', '.dicom']:\n        from src.DicomSource import DicomSource\n        source = DicomSource(filename)\n    elif '.zar' in input_ext:\n        from src.OmeZarrSource import OmeZarrSource\n        source = OmeZarrSource(filename)\n    elif '.tif' in input_ext or input_ext == '.ome':\n        from src.TiffSource import TiffSource\n        source = TiffSource(filename)\n    else:\n        from src.GenericSource import GenericSource\n        error = ''\n        source = GenericSource(filename)\n        if source.format == 'dicom':\n            from src.DicomSource import DicomSource\n            source = DicomSource(filename)\n        if error:\n            raise ValueError(f'Unsupported input file format: {input_ext}\\n{error}')\n    return source\n</code></pre>"},{"location":"references/#src.helper.create_writer","title":"<code>create_writer(output_format, verbose=False)</code>","text":"<p>Create a writer object and output extension based on the output format.</p> <p>Parameters:</p> Name Type Description Default <code>output_format</code> <code>str</code> <p>Output format string.</p> required <code>verbose</code> <code>bool</code> <p>If True, enables verbose output.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(writer object, output file extension)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the output format is unsupported.</p> Source code in <code>src/helper.py</code> <pre><code>def create_writer(output_format, verbose=False):\n    \"\"\"\n    Create a writer object and output extension based on the output format.\n\n    Args:\n        output_format (str): Output format string.\n        verbose (bool): If True, enables verbose output.\n\n    Returns:\n        tuple: (writer object, output file extension)\n\n    Raises:\n        ValueError: If the output format is unsupported.\n    \"\"\"\n    if 'zar' in output_format:\n        if '3' in output_format:\n            zarr_version = 3\n            ome_version = '0.5'\n        else:\n            zarr_version = 2\n            ome_version = '0.4'\n        from src.OmeZarrWriter import OmeZarrWriter\n        writer = OmeZarrWriter(zarr_version=zarr_version, ome_version=ome_version, verbose=verbose)\n        ext = '.ome.zarr'\n    elif 'tif' in output_format:\n        from src.OmeTiffWriter import OmeTiffWriter\n        writer = OmeTiffWriter(verbose=verbose)\n        ext = '.ome.tiff'\n    else:\n        raise ValueError(f'Unsupported output format: {output_format}')\n    return writer, ext\n</code></pre>"},{"location":"references/#src.helper.get_incucyte_plates","title":"<code>get_incucyte_plates(filename)</code>","text":"<p>Get all available plate IDs from an Incucyte archive.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to the Incucyte archive folder or .icarch file.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of plate IDs (strings) found in the archive.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path is not a valid Incucyte archive.</p> Source code in <code>src/helper.py</code> <pre><code>def get_incucyte_plates(filename):\n    \"\"\"\n    Get all available plate IDs from an Incucyte archive.\n\n    Args:\n        filename (str): Path to the Incucyte archive folder or .icarch file.\n\n    Returns:\n        list: List of plate IDs (strings) found in the archive.\n\n    Raises:\n        ValueError: If the path is not a valid Incucyte archive.\n    \"\"\"\n    # If it's an .icarch file, use its parent folder\n    if os.path.isfile(filename) and filename.lower().endswith('.icarch'):\n        archive_folder = os.path.dirname(filename)\n    elif os.path.isdir(filename):\n        archive_folder = filename\n    else:\n        raise ValueError(\n            f'Invalid Incucyte archive path. Expected folder or .icarch '\n            f'file: {filename}'\n        )\n\n    from src.IncucyteSource import IncucyteSource\n    return IncucyteSource.get_available_plates(archive_folder)\n</code></pre>"},{"location":"references/#src.ome_tiff_util","title":"<code>ome_tiff_util</code>","text":""},{"location":"references/#src.ome_tiff_util.create_binaryonly_metadata","title":"<code>create_binaryonly_metadata(metadata_filename, companion_uuid)</code>","text":"Source code in <code>src/ome_tiff_util.py</code> <pre><code>def create_binaryonly_metadata(metadata_filename, companion_uuid):\n    ome = OME()\n    ome.uuid = create_uuid()\n    ome.creator = f'nl.biomero.OmeTiffWriter {VERSION}'\n    ome.binary_only = OME.BinaryOnly(metadata_file=metadata_filename, uuid=companion_uuid)\n    return to_xml(ome), ome.uuid\n</code></pre>"},{"location":"references/#src.ome_tiff_util.create_image_metadata","title":"<code>create_image_metadata(source, image_name, dim_order='tczyx', image_uuid=None, image_filename=None)</code>","text":"Source code in <code>src/ome_tiff_util.py</code> <pre><code>def create_image_metadata(source, image_name, dim_order='tczyx', image_uuid=None, image_filename=None):\n    t, c, z, y, x = [source.get_shape()[source.dim_order.index(dim)] if dim in source.get_dim_order() else 1\n                     for dim in 'tczyx']\n    pixel_size = source.get_pixel_size_um()\n    channels = source.get_channels()\n    if source.is_rgb():\n        ome_channels = [Channel(name='rgb', samples_per_pixel=3)]\n    elif len(channels) &lt; c:\n        ome_channels = [Channel(name=f'{channeli}', samples_per_pixel=1) for channeli in range(c)]\n    else:\n        ome_channels = []\n        for channeli, channel in enumerate(channels):\n            ome_channel = Channel()\n            ome_channel.name = channel.get('label', channel.get('Name', f'{channeli}'))\n            ome_channel.samples_per_pixel = 1\n            color = channel.get('color', channel.get('Color'))\n            if color is not None:\n                ome_channel.color = Color(rgba_to_int(color))\n            ome_channels.append(ome_channel)\n\n    tiff_data = TiffData()\n    tiff_data.uuid = TiffData.UUID(value=image_uuid, file_name=image_filename)\n\n    pixels = Pixels(\n        dimension_order=Pixels_DimensionOrder(dim_order[::-1].upper()),\n        type=PixelType(str(source.get_dtype())),\n        channels=ome_channels,\n        size_t=t, size_c=c, size_z=z, size_y=y, size_x=x,\n        tiff_data_blocks=[tiff_data]\n    )\n    if 'x' in pixel_size:\n        pixels.physical_size_x = pixel_size['x']\n        pixels.physical_size_x_unit = UnitsLength.MICROMETER\n    if 'y' in pixel_size:\n        pixels.physical_size_y = pixel_size['y']\n        pixels.physical_size_y_unit = UnitsLength.MICROMETER\n    if 'z' in pixel_size:\n        pixels.physical_size_z = pixel_size['z']\n        pixels.physical_size_z_unit = UnitsLength.MICROMETER\n    significant_bits = source.get_significant_bits()\n    if significant_bits:\n        pixels.significant_bits = significant_bits\n\n    image = Image(name=image_name, pixels=pixels)\n    acquisition_datetime = source.get_acquisition_datetime()\n    if acquisition_datetime:\n        image.acquisition_date = acquisition_datetime\n    index = pixels.id.split(':')[1]\n    for channeli, channel in enumerate(pixels.channels):\n        channel.id = f'Channel:{index}:{channeli}'\n    return image\n</code></pre>"},{"location":"references/#src.ome_tiff_util.create_metadata","title":"<code>create_metadata(source, dim_order='tczyx', uuid=None, image_uuids=None, image_filenames=None, wells=None)</code>","text":"Source code in <code>src/ome_tiff_util.py</code> <pre><code>def create_metadata(source, dim_order='tczyx', uuid=None, image_uuids=None, image_filenames=None, wells=None):\n    ome = OME()\n    if uuid is None:\n        uuid = create_uuid()\n    ome.uuid = uuid\n    ome.creator = f'nl.biomero.OmeTiffWriter {VERSION}'\n\n    if source.is_screen():\n        if wells is None:\n            wells = source.get_wells()\n\n        nrows, row_type = get_row_col_len_type(source.get_rows())\n        ncols, col_type = get_row_col_len_type(source.get_columns())\n\n        plate = Plate()\n        plate.name = source.get_name()\n        plate.rows = nrows\n        plate.columns = ncols\n        plate.row_naming_convention = row_type\n        plate.column_naming_convention = col_type\n\n        image_index = 0\n        for well_id in wells:\n            row, col = split_well_name(well_id)\n            row_index = get_row_col_index(row)\n            col_index = get_row_col_index(col)\n            well = Well(row=row_index, column=col_index)\n            well.id = f'Well:{row_index}:{col_index}'\n            for field in source.get_fields():\n                sample = WellSample(index=image_index)\n                sample.id = f'WellSample:{row_index}:{col_index}:{field}'\n                position = source.get_position_um(well_id)\n                if 'x' in position:\n                    sample.position_x = position['x']\n                    sample.position_x_unit = UnitsLength.MICROMETER\n                if 'y' in position:\n                    sample.position_y = position['y']\n                    sample.position_y_unit = UnitsLength.MICROMETER\n\n                image_name = f'Well {well_id}, Field #{int(field) + 1}'\n                image = create_image_metadata(source,\n                                              image_name,\n                                              dim_order,\n                                              image_uuids[image_index],\n                                              image_filenames[image_index])\n                ome.images.append(image)\n\n                image_ref = ImageRef(id=image.id)   # assign id at instantiation to avoid auto sequence increment\n                sample.image_ref = image_ref\n                well.well_samples.append(sample)\n\n                image_index += 1\n\n            plate.wells.append(well)\n\n        ome.plates = [plate]\n    else:\n        ome.images = [create_image_metadata(source, source.get_name(), dim_order, ome.uuid, image_filenames[0])]\n\n    return to_xml(ome)\n</code></pre>"},{"location":"references/#src.ome_tiff_util.create_resolution_metadata","title":"<code>create_resolution_metadata(source)</code>","text":"Source code in <code>src/ome_tiff_util.py</code> <pre><code>def create_resolution_metadata(source):\n    pixel_size_um = source.get_pixel_size_um()\n    resolution_unit = 'CENTIMETER'\n    resolution = [1e4 / pixel_size_um[dim] for dim in 'xy']\n    return resolution, resolution_unit\n</code></pre>"},{"location":"references/#src.ome_tiff_util.create_row_col_label","title":"<code>create_row_col_label(index, naming_convention)</code>","text":"Source code in <code>src/ome_tiff_util.py</code> <pre><code>def create_row_col_label(index, naming_convention):\n    if naming_convention.lower() == NamingConvention.LETTER.name.lower():\n        label = chr(ord('A') + index)\n    else:\n        label = index + 1\n    return str(label)\n</code></pre>"},{"location":"references/#src.ome_tiff_util.create_uuid","title":"<code>create_uuid()</code>","text":"Source code in <code>src/ome_tiff_util.py</code> <pre><code>def create_uuid():\n    return f'urn:uuid:{uuid.uuid4()}'\n</code></pre>"},{"location":"references/#src.ome_tiff_util.get_row_col_index","title":"<code>get_row_col_index(label)</code>","text":"Source code in <code>src/ome_tiff_util.py</code> <pre><code>def get_row_col_index(label):\n    if label.isdigit():\n        index = int(label) - 1\n    else:\n        index = ord(label.upper()) - ord('A')\n    return index\n</code></pre>"},{"location":"references/#src.ome_tiff_util.get_row_col_len_type","title":"<code>get_row_col_len_type(labels)</code>","text":"Source code in <code>src/ome_tiff_util.py</code> <pre><code>def get_row_col_len_type(labels):\n    max_index = max(get_row_col_index(label) for label in labels)\n    nlen = max_index + 1\n    is_digits = [label.isdigit() for label in labels]\n    if np.all(is_digits):\n        naming_convention = NamingConvention.NUMBER\n    else:\n        naming_convention = NamingConvention.LETTER\n    return nlen, naming_convention\n</code></pre>"},{"location":"references/#src.ome_tiff_util.metadata_to_dict","title":"<code>metadata_to_dict(xml_metadata)</code>","text":"Source code in <code>src/ome_tiff_util.py</code> <pre><code>def metadata_to_dict(xml_metadata):\n    metadata = xml2dict(xml_metadata)\n    if 'OME' in metadata:\n        metadata = metadata['OME']\n    return metadata\n</code></pre>"},{"location":"references/#src.ome_zarr_util","title":"<code>ome_zarr_util</code>","text":""},{"location":"references/#src.ome_zarr_util.create_axes_metadata","title":"<code>create_axes_metadata(dimension_order)</code>","text":"<p>Create axes metadata for OME-Zarr from dimension order.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>List of axis metadata dictionaries.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_axes_metadata(dimension_order):\n    \"\"\"\n    Create axes metadata for OME-Zarr from dimension order.\n\n    Args:\n        dimension_order (str): String of dimension characters.\n\n    Returns:\n        list: List of axis metadata dictionaries.\n    \"\"\"\n    axes = []\n    for dimension in dimension_order:\n        unit1 = None\n        if dimension == 't':\n            type1 = 'time'\n            unit1 = 'millisecond'\n        elif dimension == 'c':\n            type1 = 'channel'\n        else:\n            type1 = 'space'\n            unit1 = 'micrometer'\n        axis = {'name': dimension, 'type': type1}\n        if unit1 is not None and unit1 != '':\n            axis['unit'] = unit1\n        axes.append(axis)\n    return axes\n</code></pre>"},{"location":"references/#src.ome_zarr_util.create_channel_metadata","title":"<code>create_channel_metadata(dtype, channels, nchannels, is_rgb, window, ome_version)</code>","text":"<p>Create channel metadata for OME-Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <p>Numpy dtype of image data.</p> required <code>channels</code> <code>list</code> <p>List of channel dicts.</p> required <code>nchannels</code> <code>int</code> <p>Number of channels.</p> required <code>window</code> <code>tuple</code> <p>Min/max window values.</p> required <code>ome_version</code> <code>str</code> <p>OME-Zarr version.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Channel metadata dictionary.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_channel_metadata(dtype, channels, nchannels, is_rgb, window, ome_version):\n    \"\"\"\n    Create channel metadata for OME-Zarr.\n\n    Args:\n        dtype: Numpy dtype of image data.\n        channels (list): List of channel dicts.\n        nchannels (int): Number of channels.\n        window (tuple): Min/max window values.\n        ome_version (str): OME-Zarr version.\n\n    Returns:\n        dict: Channel metadata dictionary.\n    \"\"\"\n    if len(channels) &lt; nchannels:\n        labels = []\n        colors = []\n        if is_rgb and nchannels in (3, 4):\n            labels = ['Red', 'Green', 'Blue']\n            colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n        if is_rgb and nchannels == 4:\n            labels += ['Alpha']\n            colors += [(1, 1, 1)]\n        channels = [{'label': label, 'color': color} for label, color in zip(labels, colors)]\n\n    omezarr_channels = []\n    starts, ends = window\n    for channeli, channel in enumerate(channels):\n        omezarr_channel = {'label': channel.get('label', channel.get('Name', f'{channeli}')), 'active': True}\n        color = channel.get('color', channel.get('Color'))\n        if color is not None:\n            omezarr_channel['color'] = rgba_to_hexrgb(color)\n        if np.dtype(dtype).kind == 'f':\n            min, max = 0, 1\n        else:\n            info = np.iinfo(dtype)\n            min, max = info.min, info.max\n        if starts and ends:\n            start, end = starts[channeli], ends[channeli]\n        else:\n            start, end = min, max\n        omezarr_channel['window'] = {'min': min, 'max': max, 'start': start, 'end': end}\n        omezarr_channels.append(omezarr_channel)\n\n    metadata = {\n        'version': ome_version,\n        'channels': omezarr_channels,\n    }\n    return metadata\n</code></pre>"},{"location":"references/#src.ome_zarr_util.create_transformation_metadata","title":"<code>create_transformation_metadata(dimension_order, pixel_size_um, factor, translation_um=None)</code>","text":"<p>Create transformation metadata (scale and translation) for OME-Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <code>pixel_size_um</code> <code>dict</code> <p>Pixel size in micrometers per dimension.</p> required <code>factor</code> <code>float</code> <p>Scaling factor.</p> required <code>translation_um</code> <code>dict</code> <p>Translation in micrometers per dimension.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>List of transformation metadata dictionaries.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def create_transformation_metadata(dimension_order, pixel_size_um, factor, translation_um=None):\n    \"\"\"\n    Create transformation metadata (scale and translation) for OME-Zarr.\n\n    Args:\n        dimension_order (str): String of dimension characters.\n        pixel_size_um (dict): Pixel size in micrometers per dimension.\n        factor (float): Scaling factor.\n        translation_um (dict, optional): Translation in micrometers per dimension.\n\n    Returns:\n        list: List of transformation metadata dictionaries.\n    \"\"\"\n    metadata = []\n    pixel_size_scale = []\n    translation_scale = []\n    for dim in dimension_order:\n        pixel_size_scale1 = pixel_size_um.get(dim, 1)\n        if dim in 'xy':\n            pixel_size_scale1 *= factor\n        if pixel_size_scale1 == 0:\n            pixel_size_scale1 = 1\n        pixel_size_scale.append(pixel_size_scale1)\n\n        if translation_um is not None:\n            translation1 = translation_um.get(dim, 0)\n            # translation_pyramid = translation + (scale - 1) * pixel_size / 2\n            if dim in 'xy':\n                translation1 += (factor - 1) * pixel_size_um[dim] / 2\n            translation_scale.append(translation1)\n\n    metadata.append({'type': 'scale', 'scale': pixel_size_scale})\n    if translation_um is not None:\n        metadata.append({'type': 'translation', 'translation': translation_scale})\n    return metadata\n</code></pre>"},{"location":"references/#src.ome_zarr_util.scale_dimensions_dict","title":"<code>scale_dimensions_dict(shape0, scale)</code>","text":"<p>Scale x and y dimensions in a shape dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>shape0</code> <code>dict</code> <p>Original shape dictionary.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Scaled shape dictionary.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def scale_dimensions_dict(shape0, scale):\n    \"\"\"\n    Scale x and y dimensions in a shape dictionary.\n\n    Args:\n        shape0 (dict): Original shape dictionary.\n        scale (float): Scaling factor.\n\n    Returns:\n        dict: Scaled shape dictionary.\n    \"\"\"\n    shape = {}\n    if scale == 1:\n        return shape0\n    for dimension, shape1 in shape0.items():\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape[dimension] = shape1\n    return shape\n</code></pre>"},{"location":"references/#src.ome_zarr_util.scale_dimensions_xy","title":"<code>scale_dimensions_xy(shape0, dimension_order, scale)</code>","text":"<p>Scale x and y dimensions in a shape tuple.</p> <p>Parameters:</p> Name Type Description Default <code>shape0</code> <code>tuple</code> <p>Original shape.</p> required <code>dimension_order</code> <code>str</code> <p>String of dimension characters.</p> required <code>scale</code> <code>float</code> <p>Scaling factor.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Scaled shape.</p> Source code in <code>src/ome_zarr_util.py</code> <pre><code>def scale_dimensions_xy(shape0, dimension_order, scale):\n    \"\"\"\n    Scale x and y dimensions in a shape tuple.\n\n    Args:\n        shape0 (tuple): Original shape.\n        dimension_order (str): String of dimension characters.\n        scale (float): Scaling factor.\n\n    Returns:\n        list: Scaled shape.\n    \"\"\"\n    shape = []\n    if scale == 1:\n        return shape0\n    for shape1, dimension in zip(shape0, dimension_order):\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape.append(shape1)\n    return shape\n</code></pre>"},{"location":"references/#src.parameters","title":"<code>parameters</code>","text":""},{"location":"references/#src.parameters.PYRAMID_DOWNSCALE","title":"<code>PYRAMID_DOWNSCALE = 2</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.parameters.PYRAMID_LEVELS","title":"<code>PYRAMID_LEVELS = 6</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.parameters.RETRY_ATTEMPTS","title":"<code>RETRY_ATTEMPTS = 3</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.parameters.TIFF_COMPRESSION","title":"<code>TIFF_COMPRESSION = 'LZW'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.parameters.TILE_SIZE","title":"<code>TILE_SIZE = 1024</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.parameters.VERSION","title":"<code>VERSION = 'v0.1.18'</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.parameters.ZARR_CHUNK_SIZE","title":"<code>ZARR_CHUNK_SIZE = TILE_SIZE</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.parameters.ZARR_SHARD_MULTIPLIER","title":"<code>ZARR_SHARD_MULTIPLIER = 10</code>  <code>module-attribute</code>","text":""},{"location":"references/#src.util","title":"<code>util</code>","text":""},{"location":"references/#src.util.convert_dotnet_ticks_to_datetime","title":"<code>convert_dotnet_ticks_to_datetime(net_ticks)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def convert_dotnet_ticks_to_datetime(net_ticks):\n    return datetime(1, 1, 1) + timedelta(microseconds=net_ticks // 10)\n</code></pre>"},{"location":"references/#src.util.convert_to_um","title":"<code>convert_to_um(value, unit)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def convert_to_um(value, unit):\n    conversions = {\n        'nm': 1e-3,\n        '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'micron': 1,\n        'mm': 1e3, 'millimeter': 1e3,\n        'cm': 1e4, 'centimeter': 1e4,\n        'm': 1e6, 'meter': 1e6\n    }\n    return value * conversions.get(unit, 1)\n</code></pre>"},{"location":"references/#src.util.ensure_list","title":"<code>ensure_list(item)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def ensure_list(item):\n    if not isinstance(item, (list, tuple)):\n        item = [item]\n    return item\n</code></pre>"},{"location":"references/#src.util.get_bits_type","title":"<code>get_bits_type(nbits)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_bits_type(nbits):\n    if nbits &lt;= 8:\n        dtype = np.uint8\n    elif nbits &lt;= 16:\n        dtype = np.uint16\n    elif nbits &lt;= 32:\n        dtype = np.uint32\n    else:\n        dtype = np.uint64\n    return np.dtype(dtype)\n</code></pre>"},{"location":"references/#src.util.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_filetitle(filename):\n    return os.path.basename(os.path.splitext(filename)[0])\n</code></pre>"},{"location":"references/#src.util.get_level_from_scale","title":"<code>get_level_from_scale(source_scales, target_scale=1)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_level_from_scale(source_scales, target_scale=1):\n    best_level_scale = 0, target_scale\n    for level, scale in enumerate(source_scales):\n        if np.isclose(scale, target_scale, rtol=1e-4):\n            return level, 1\n        if scale &lt;= target_scale:\n            best_level_scale = level, target_scale / scale\n    return best_level_scale\n</code></pre>"},{"location":"references/#src.util.get_numpy_data","title":"<code>get_numpy_data(data, dim_order, t, c, z, y, x, y_size, x_size)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_numpy_data(data, dim_order, t, c, z, y, x, y_size, x_size):\n    x_index = dim_order.index('x')\n    y_index = dim_order.index('y')\n    slices = [slice(None)] * len(dim_order)\n    if 't' in dim_order:\n        slices[dim_order.index('t')] = t\n    if 'c' in dim_order:\n        slices[dim_order.index('c')] = c\n    if 'z' in dim_order:\n        slices[dim_order.index('z')] = z\n    slices[y_index] = slice(y, y + y_size)\n    slices[x_index] = slice(x, x + x_size)\n    return data[tuple(slices)]\n</code></pre>"},{"location":"references/#src.util.get_rows_cols_plate","title":"<code>get_rows_cols_plate(nwells)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def get_rows_cols_plate(nwells):\n    nrows_cols = {\n        6: (2, 3),\n        12: (3, 4),\n        24: (4, 6),\n        48: (6, 8),\n        96: (8, 12),\n        384: (16, 24)\n    }\n    nrows, ncols = nrows_cols[nwells]\n    rows = [chr(ord('A') + i) for i in range(nrows)]\n    cols = [str(i + 1) for i in range(ncols)]\n    return rows, cols\n</code></pre>"},{"location":"references/#src.util.pad_leading_zero","title":"<code>pad_leading_zero(input_string, num_digits=2)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def pad_leading_zero(input_string, num_digits=2):\n    output = str(input_string)\n    is_well = not output[0].isdigit()\n    if is_well:\n        row, col = split_well_name(output, remove_leading_zeros=True)\n        output = str(col)\n    while len(output) &lt; num_digits:\n        output = '0' + output\n    if is_well:\n        output = row + output\n    return output\n</code></pre>"},{"location":"references/#src.util.print_dict","title":"<code>print_dict(value, tab=0, max_len=250, bullet=False)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def print_dict(value, tab=0, max_len=250, bullet=False):\n    s = ''\n    if isinstance(value, dict):\n        for key, subvalue in value.items():\n            s += '\\n'\n            if bullet:\n                s += '-'\n                bullet = False\n            s += '\\t' * tab + str(key) + ': '\n            if isinstance(subvalue, dict):\n                s += print_dict(subvalue, tab+1)\n            elif isinstance(subvalue, list):\n                for v in subvalue:\n                    s += print_dict(v, tab+1, bullet=True)\n            else:\n                subvalue = str(subvalue)\n                if len(subvalue) &gt; max_len:\n                    subvalue = subvalue[:max_len] + '...'\n                s += subvalue\n    else:\n        s += str(value) + ' '\n    return s\n</code></pre>"},{"location":"references/#src.util.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def print_hbytes(nbytes):\n    exps = ['', 'K', 'M', 'G', 'T', 'P', 'E']\n    div = 1024\n    exp = 0\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    if exp &lt; len(exps):\n        e = exps[exp]\n    else:\n        e = f'e{exp * 3}'\n    return f'{nbytes:.1f}{e}B'\n</code></pre>"},{"location":"references/#src.util.redimension_data","title":"<code>redimension_data(data, old_order, new_order, **indices)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def redimension_data(data, old_order, new_order, **indices):\n    # able to provide optional dimension values e.g. t=0, z=0\n    if new_order == old_order:\n        return data\n\n    new_data = data\n    order = old_order\n    # remove\n    for o in old_order:\n        if o not in new_order:\n            index = order.index(o)\n            dim_value = indices.get(o, 0)\n            new_data = np.take(new_data, indices=dim_value, axis=index)\n            order = order[:index] + order[index + 1:]\n    # add\n    for o in new_order:\n        if o not in order:\n            new_data = np.expand_dims(new_data, 0)\n            order = o + order\n    # move\n    old_indices = [order.index(o) for o in new_order]\n    new_indices = list(range(len(new_order)))\n    new_data = np.moveaxis(new_data, old_indices, new_indices)\n    return new_data\n</code></pre>"},{"location":"references/#src.util.split_well_name","title":"<code>split_well_name(well_name, remove_leading_zeros=True, col_as_int=False)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def split_well_name(well_name, remove_leading_zeros=True, col_as_int=False):\n    matches = re.findall(r'(\\D+)(\\d+)', well_name)\n    if len(matches) &gt; 0:\n        row, col = matches[0]\n        if col_as_int or remove_leading_zeros:\n            try:\n                col = int(col)\n            except ValueError:\n                pass\n        if not col_as_int:\n            col = str(col)\n        return row, col\n    else:\n        raise ValueError(f\"Invalid well name format: {well_name}. Expected format like 'A1', 'B2', etc.\")\n</code></pre>"},{"location":"references/#src.util.splitall","title":"<code>splitall(path)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def splitall(path):\n    allparts = []\n    while True:\n        parts = os.path.split(path)\n        if parts[0] == path:  # sentinel for absolute paths\n            allparts.insert(0, parts[0])\n            break\n        elif parts[1] == path: # sentinel for relative paths\n            allparts.insert(0, parts[1])\n            break\n        else:\n            path = parts[0]\n            allparts.insert(0, parts[1])\n    return allparts\n</code></pre>"},{"location":"references/#src.util.strip_leading_zeros","title":"<code>strip_leading_zeros(well_name)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def strip_leading_zeros(well_name):\n    row, col = split_well_name(well_name, remove_leading_zeros=True)\n    return f'{row}{col}'\n</code></pre>"},{"location":"references/#src.util.validate_filename","title":"<code>validate_filename(filename)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def validate_filename(filename):\n    return re.sub(r'[^\\w_.)(-]', '_', filename)\n</code></pre>"},{"location":"references/#src.util.xml_content_to_dict","title":"<code>xml_content_to_dict(element)</code>","text":"Source code in <code>src/util.py</code> <pre><code>def xml_content_to_dict(element):\n    key = element.tag\n    children = list(element)\n    if key == 'Array':\n        res = [xml_content_to_dict(child) for child in children]\n        return res\n    if len(children) &gt; 0:\n        if children[0].tag == 'Array':\n            value = []\n        else:\n            value = {}\n        for child in children:\n            child_value = xml_content_to_dict(child)\n            if isinstance(child_value, list):\n                value.extend(child_value)\n            else:\n                value |= child_value\n    else:\n        value = element.text\n        if value is not None:\n            if '\"' in value:\n                value = value.replace('\"', '')\n            else:\n                for t in (float, int, bool):\n                    try:\n                        if t == bool:\n                            if value.lower() == 'true':\n                                value = True\n                            if value.lower() == 'false':\n                                value = False\n                        else:\n                            value = t(value)\n                        break\n                    except (TypeError, ValueError):\n                        pass\n\n    if key == 'DataObject':\n        key = element.attrib['ObjectType']\n    if key == 'Attribute':\n        key = element.attrib['Name']\n    return {key: value}\n</code></pre>"}]}